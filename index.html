<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Neko Day ğŸ±</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Nunito:wght@400;700;900&family=Fredoka+One&display=swap');
:root{
  --pink:#f48fb1;--lavender:#ce93d8;--peach:#ffcc80;--mint:#b2dfdb;
  --text:#5d4037;--shadow:rgba(180,100,140,0.22);
  --W:420px;--H:700px;
}
*{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent;}
html,body{
  width:100%;height:100%;height:100dvh;
  font-family:'Nunito',sans-serif;
  background:#1a0a2e;
  display:flex;align-items:center;justify-content:center;
  overflow:hidden;user-select:none;overscroll-behavior:none;
}
#app{
  width:min(420px,100vw);
  height:min(700px,100dvh);
  position:relative;overflow:hidden;
  background:#fff9f0;
  border-radius:clamp(0px,3vw,24px);
  box-shadow:0 0 80px rgba(244,143,177,0.4),0 0 0 1px rgba(255,255,255,0.1);
}

/* â”€â”€ SCREENS â”€â”€ */
.screen{
  position:absolute;inset:0;
  display:flex;flex-direction:column;
  align-items:center;justify-content:center;
  gap:14px;padding:20px 18px;
  overflow-y:auto;
  transition:opacity 0.3s;
}
.screen.hidden{display:none;}

/* â”€â”€ TITLE â”€â”€ */
#title-screen{
  background:linear-gradient(170deg,#fde8f5 0%,#f3e5f5 40%,#e8f5e9 100%);
}
.title-logo{
  font-family:'Fredoka One',cursive;
  font-size:52px;color:var(--text);
  text-shadow:3px 3px 0 var(--pink),6px 6px 0 rgba(244,143,177,.25);
  letter-spacing:2px;text-align:center;
  animation:titleBounce 2.2s ease-in-out infinite;
}
.title-sub{font-size:14px;color:#a0887a;font-weight:700;text-align:center;line-height:1.7;}
#title-cat-preview{
  width:140px;height:140px;
  border-radius:50%;
  background:white;
  box-shadow:0 8px 32px var(--shadow),0 0 0 4px rgba(244,143,177,0.2);
  display:flex;align-items:center;justify-content:center;
  overflow:hidden;
}
#title-cat-preview canvas{display:block;}

/* â”€â”€ CUSTOM â”€â”€ */
#custom-screen{
  background:linear-gradient(170deg,#e8f5e9 0%,#f3e5f5 60%,#fde8f5 100%);
  justify-content:flex-start;padding-top:16px;
  gap:10px;
}
#custom-screen h2{
  font-family:'Fredoka One',cursive;
  font-size:28px;color:var(--text);
  text-shadow:2px 2px 0 var(--pink);
  margin-top:4px;
}
.custom-section{width:100%;max-width:360px;}
.custom-label{
  font-size:12px;font-weight:900;color:#b06090;
  text-transform:uppercase;letter-spacing:1px;
  margin-bottom:6px;display:block;
}
.swatch-row{display:flex;gap:7px;flex-wrap:wrap;}
.swatch{
  width:36px;height:36px;border-radius:50%;
  border:3px solid transparent;cursor:pointer;
  transition:transform .12s,border-color .12s;
  touch-action:manipulation;
  box-shadow:0 2px 6px rgba(0,0,0,.15);
}
.swatch.selected{border-color:#5d4037;transform:scale(1.2);}
.swatch:active{transform:scale(0.9);}
.option-row{display:flex;gap:7px;flex-wrap:wrap;}
.opt-btn{
  padding:6px 12px;border-radius:20px;
  border:2.5px solid transparent;
  background:white;cursor:pointer;
  font-family:'Nunito',sans-serif;font-size:12px;font-weight:900;
  color:var(--text);box-shadow:0 2px 8px var(--shadow);
  transition:all .12s;touch-action:manipulation;
}
.opt-btn.selected{border-color:var(--pink);background:#fce4ec;color:#ad1457;}
.opt-btn:active{transform:scale(0.93);}

/* cat preview card */
#custom-preview-wrap{
  display:flex;flex-direction:column;align-items:center;gap:6px;
}
#preview-canvas-wrap{
  width:100px;height:100px;border-radius:50%;
  background:white;box-shadow:0 4px 18px var(--shadow),0 0 0 3px rgba(244,143,177,0.3);
  display:flex;align-items:center;justify-content:center;overflow:hidden;
}
#cat-name-input{
  padding:8px 18px;border-radius:30px;
  border:2.5px solid #f8bbd0;
  font-family:'Nunito',sans-serif;font-size:15px;font-weight:700;
  color:var(--text);background:white;text-align:center;outline:none;
  width:180px;box-shadow:0 2px 8px var(--shadow);
}
#cat-name-input:focus{border-color:var(--pink);}

/* â”€â”€ DIFF SELECT â”€â”€ */
#diff-screen{
  background:linear-gradient(170deg,#fff9f0 0%,#fce4ec 100%);
}
#diff-screen h2{
  font-family:'Fredoka One',cursive;font-size:28px;
  color:var(--text);text-shadow:2px 2px 0 var(--peach);
}
.diff-cards{display:flex;flex-direction:column;gap:10px;width:100%;max-width:340px;}
.diff-card{
  background:white;border-radius:18px;padding:14px 18px;
  border:3px solid transparent;cursor:pointer;
  display:flex;align-items:center;gap:14px;
  box-shadow:0 4px 14px var(--shadow);
  transition:all .15s;touch-action:manipulation;
}
.diff-card:active{transform:scale(0.97);}
.diff-card.selected{border-color:var(--pink);background:#fce4ec;}
.diff-card.selected.easy{border-color:#66bb6a;background:#f1f8e9;}
.diff-card.selected.hard{border-color:#ff7043;background:#fbe9e7;}
.diff-card.selected.paws{border-color:#7e57c2;background:#ede7f6;}
.diff-icon-big{font-size:32px;flex-shrink:0;}
.diff-card-text{}
.diff-card-name{font-size:16px;font-weight:900;color:var(--text);}
.diff-card-desc{font-size:11px;font-weight:700;color:#a0887a;margin-top:2px;}

/* â”€â”€ LEVEL SELECT â”€â”€ */
#level-screen{
  background:linear-gradient(170deg,#fff9f0 0%,#fce4ec 60%,#f3e5f5 100%);
}
#level-screen h2{
  font-family:'Fredoka One',cursive;font-size:28px;
  color:var(--text);text-shadow:2px 2px 0 var(--peach);
}
.level-list{display:flex;flex-direction:column;gap:10px;width:100%;max-width:340px;}
.level-card{
  background:white;border-radius:18px;padding:14px 18px;
  border:3px solid transparent;cursor:pointer;
  display:flex;align-items:center;gap:14px;
  box-shadow:0 4px 14px var(--shadow);
  transition:all .15s;touch-action:manipulation;
}
.level-card.unlocked{border-color:var(--pink);}
.level-card.locked{opacity:.5;cursor:not-allowed;filter:grayscale(.5);}
.level-card:active:not(.locked){transform:scale(0.97);}
.level-icon{font-size:32px;flex-shrink:0;}
.level-card-text{}
.level-card-name{font-size:15px;font-weight:900;color:var(--text);}
.level-card-desc{font-size:11px;font-weight:700;color:#a0887a;margin-top:2px;}

/* â”€â”€ GAME OVER / COMPLETE â”€â”€ */
#gameover-screen{background:rgba(253,232,245,.97);}
#levelcomplete-screen{background:rgba(240,255,244,.97);}
#gameover-screen h2,#levelcomplete-screen h2{
  font-family:'Fredoka One',cursive;font-size:36px;
  color:var(--text);text-align:center;
}
.result-emoji{font-size:72px;animation:titleBounce 1.5s ease-in-out infinite;}
.result-score{font-size:22px;font-weight:900;color:var(--text);}

/* â”€â”€ BUTTONS â”€â”€ */
.btn{
  background:linear-gradient(135deg,var(--pink),var(--lavender));
  color:white;border:none;
  padding:12px 36px;border-radius:50px;
  font-family:'Fredoka One',cursive;font-size:18px;
  cursor:pointer;
  box-shadow:0 5px 0 #b06090,0 8px 18px rgba(200,100,150,.3);
  transition:transform .1s,box-shadow .1s;touch-action:manipulation;
}
.btn:active{transform:translateY(3px);box-shadow:0 2px 0 #b06090;}
.btn-green{background:linear-gradient(135deg,#66bb6a,#26a69a);box-shadow:0 5px 0 #2e7d32,0 8px 16px rgba(50,150,80,.3);}
.btn-green:active{box-shadow:0 2px 0 #2e7d32;}
.btn-sm{font-size:14px;padding:9px 24px;}
.btn-grey{background:linear-gradient(135deg,#ce93d8,#b0bec5);box-shadow:0 5px 0 #7b6080;}
.btn-grey:active{box-shadow:0 2px 0 #7b6080;}
.btn-row{display:flex;gap:10px;flex-wrap:wrap;justify-content:center;}

/* â”€â”€ HUD â”€â”€ */
#hud{
  position:absolute;top:0;left:0;right:0;
  display:none;
  padding:6px 10px 4px;
  background:linear-gradient(180deg,rgba(255,249,240,0.95),rgba(255,249,240,0));
  z-index:20;pointer-events:none;
}
.hud-row{display:flex;align-items:center;gap:6px;}
.hud-pill{
  background:rgba(255,255,255,0.88);
  backdrop-filter:blur(4px);
  border-radius:20px;padding:3px 10px;
  display:flex;align-items:center;gap:5px;
  box-shadow:0 2px 8px var(--shadow);
  font-size:11px;font-weight:700;color:var(--text);
}
#score-val{font-size:13px;font-weight:900;color:var(--text);}
#key-indicator{font-size:14px;}
#diff-badge-hud{font-size:10px;font-weight:900;padding:2px 7px;border-radius:12px;}
#diff-badge-hud.easy{background:#c8e6c9;color:#2e7d32;}
#diff-badge-hud.normal{background:#fce4ec;color:#ad1457;}
#diff-badge-hud.hard{background:#ffe0b2;color:#e65100;}
#diff-badge-hud.paws{background:#ede7f6;color:#4527a0;}

/* â”€â”€ GAME CANVAS â”€â”€ */
#game-canvas-wrap{
  position:absolute;inset:0;
  display:none;
}
#gameCanvas{display:block;width:100%;height:100%;}

/* â”€â”€ TOUCH CONTROLS â”€â”€ */
#touch-controls{
  position:absolute;bottom:0;left:0;right:0;
  display:none;
  padding:12px 16px 20px;
  justify-content:space-between;align-items:flex-end;
  pointer-events:none;
  z-index:25;
}
#joystick-zone{
  width:110px;height:110px;
  border-radius:50%;
  background:rgba(255,255,255,0.25);
  backdrop-filter:blur(6px);
  border:2px solid rgba(255,255,255,0.4);
  position:relative;pointer-events:auto;
  touch-action:none;
}
#joystick-knob{
  position:absolute;
  width:46px;height:46px;border-radius:50%;
  background:rgba(255,255,255,0.75);
  border:2.5px solid rgba(244,143,177,0.8);
  box-shadow:0 3px 10px rgba(180,100,140,.3);
  top:50%;left:50%;
  transform:translate(-50%,-50%);
  transition:transform 0.05s;
  pointer-events:none;
}
.action-btns{display:flex;flex-direction:column;gap:10px;align-items:flex-end;pointer-events:auto;}
.touch-action-btn{
  width:64px;height:64px;border-radius:50%;
  background:rgba(255,255,255,0.65);
  backdrop-filter:blur(6px);
  border:2.5px solid rgba(244,143,177,0.6);
  box-shadow:0 3px 12px rgba(180,100,140,.25);
  display:flex;align-items:center;justify-content:center;
  font-size:22px;cursor:pointer;touch-action:manipulation;
  user-select:none;-webkit-user-select:none;
  transition:transform .08s,background .1s;
  pointer-events:auto;
}
.touch-action-btn.pressed{background:rgba(244,143,177,0.5);transform:scale(0.88);}
#scratch-btn{
  background:linear-gradient(135deg,rgba(244,143,177,0.7),rgba(206,147,216,0.7));
  border-color:rgba(244,143,177,0.9);width:72px;height:72px;font-size:26px;
}

/* â”€â”€ POPUP SCORES â”€â”€ */
.pop{
  position:absolute;pointer-events:none;z-index:30;
  font-size:16px;font-weight:900;
  font-family:'Nunito',sans-serif;color:var(--text);
  animation:popUp 1.1s ease-out forwards;
  white-space:nowrap;
}
@keyframes popUp{0%{transform:translateY(0) scale(.7);opacity:1;}100%{transform:translateY(-60px) scale(1.1);opacity:0;}}
@keyframes titleBounce{0%,100%{transform:translateY(0)}50%{transform:translateY(-8px)}}
@keyframes doorShake{0%,100%{transform:translateX(0)}20%{transform:translateX(-5px)}40%{transform:translateX(5px)}60%{transform:translateX(-4px)}80%{transform:translateX(4px)}}
@keyframes keyPulse{0%,100%{filter:drop-shadow(0 0 4px #ffd700)}50%{filter:drop-shadow(0 0 12px #ffd700) drop-shadow(0 0 4px #ff8c00)}}

@media(pointer:coarse){#touch-controls{display:flex;}}
@media(min-width:421px){
  #app{box-shadow:0 0 100px rgba(244,143,177,0.5),0 0 0 1px rgba(255,255,255,0.08);}
}
</style>
</head>
<body>
<div id="app">

<!-- TITLE -->
<div class="screen" id="title-screen">
  <div id="title-cat-preview"><canvas id="titleCatCanvas" width="130" height="130"></canvas></div>
  <div class="title-logo">Neko Day âœ¨</div>
  <div class="title-sub">A cozy top-down cat adventure!<br>Find the ğŸ—ï¸ key Â· give treats ğŸ¦´ to dogs Â· befriend everyone!</div>
      <div style="position:absolute;top:14px;right:14px;"><button class="btn btn-grey" style="padding:6px 14px;font-size:13px;" onclick="toggleMusic()" title="Toggle music">ğŸµ Music</button></div>
  <button class="btn" onclick="showScreen('custom-screen')">Customize Your Cat ğŸ±</button>
  <button class="btn btn-grey btn-sm" style="margin-top:-4px" onclick="quickPlay()">Quick Play â†’</button>
</div>

<!-- CUSTOMISE -->
<div class="screen hidden" id="custom-screen">
  <h2>Your Cat âœ¨</h2>
  <div id="custom-preview-wrap">
    <div id="preview-canvas-wrap"><canvas id="previewCanvas" width="90" height="90"></canvas></div>
    <input class="name-box" id="cat-name-input" placeholder="Mochi" maxlength="14" value="Mochi" oninput="updatePreview()"/>
  </div>

  <div class="custom-section">
    <span class="custom-label">ğŸ¨ Fur Color</span>
    <div class="swatch-row" id="color-swatches">
      <div class="swatch selected" data-idx="0" style="background:#fff9f0;border:2px solid #ddd" onclick="setCatProp('colorIdx',0)"></div>
      <div class="swatch" data-idx="1" style="background:#ffb74d" onclick="setCatProp('colorIdx',1)"></div>
      <div class="swatch" data-idx="2" style="background:#9e9e9e" onclick="setCatProp('colorIdx',2)"></div>
      <div class="swatch" data-idx="3" style="background:#424242" onclick="setCatProp('colorIdx',3)"></div>
      <div class="swatch" data-idx="4" style="background:#ffcc80" onclick="setCatProp('colorIdx',4)"></div>
      <div class="swatch" data-idx="5" style="background:#a1887f" onclick="setCatProp('colorIdx',5)"></div>
      <div class="swatch" data-idx="6" style="background:#f8bbd0" onclick="setCatProp('colorIdx',6)"></div>
    </div>
  </div>

  <div class="custom-section">
    <span class="custom-label">ğŸ¾ Pattern</span>
    <div class="option-row" id="pattern-opts">
      <div class="opt-btn selected" data-val="solid" onclick="setCatProp('pattern','solid')">Solid</div>
      <div class="opt-btn" data-val="tabby" onclick="setCatProp('pattern','tabby')">Tabby</div>
      <div class="opt-btn" data-val="spots" onclick="setCatProp('pattern','spots')">Spotty</div>
      <div class="opt-btn" data-val="tuxedo" onclick="setCatProp('pattern','tuxedo')">Tuxedo</div>
      <div class="opt-btn" data-val="calico" onclick="setCatProp('pattern','calico')">Calico</div>
    </div>
  </div>

  <div class="custom-section">
    <span class="custom-label">ğŸ‘ï¸ Eye Color</span>
    <div class="swatch-row" id="eye-swatches">
      <div class="swatch selected" data-idx="0" style="background:#4caf50" onclick="setCatProp('eyeIdx',0)"></div>
      <div class="swatch" data-idx="1" style="background:#2196f3" onclick="setCatProp('eyeIdx',1)"></div>
      <div class="swatch" data-idx="2" style="background:#ff9800" onclick="setCatProp('eyeIdx',2)"></div>
      <div class="swatch" data-idx="3" style="background:#9c27b0" onclick="setCatProp('eyeIdx',3)"></div>
      <div class="swatch" data-idx="4" style="background:linear-gradient(135deg,#2196f3,#ff9800)" onclick="setCatProp('eyeIdx',4)"></div>
    </div>
  </div>

  <div class="custom-section">
    <span class="custom-label">ğŸ€ Accessory</span>
    <div class="option-row" id="acc-opts">
      <div class="opt-btn selected" data-val="none" onclick="setCatProp('accessory','none')">None</div>
      <div class="opt-btn" data-val="bow" onclick="setCatProp('accessory','bow')">ğŸ€ Bow</div>
      <div class="opt-btn" data-val="flower" onclick="setCatProp('accessory','flower')">ğŸŒ¸ Flower</div>
      <div class="opt-btn" data-val="hat" onclick="setCatProp('accessory','hat')">ğŸ© Hat</div>
      <div class="opt-btn" data-val="stars" onclick="setCatProp('accessory','stars')">â­ Stars</div>
      <div class="opt-btn" data-val="crown" onclick="setCatProp('accessory','crown')">ğŸ‘‘ Crown</div>
    </div>
  </div>

  <div class="btn-row">
    <button class="btn btn-grey btn-sm" onclick="showScreen('title-screen')">â† Back</button>
    <button class="btn btn-sm" onclick="showScreen('diff-screen')">Next â†’</button>
  </div>
</div>

<!-- DIFFICULTY -->
<div class="screen hidden" id="diff-screen">
  <h2>Difficulty ğŸ®</h2>
  <div class="diff-cards">
    <div class="diff-card easy selected" data-diff="easy" onclick="selectDiff('easy')">
      <div class="diff-icon-big">ğŸŒ¸</div>
      <div class="diff-card-text">
        <div class="diff-card-name">Easy</div>
        <div class="diff-card-desc">Slow lazy dogs Â· treats work easily Â· max cozy vibes</div>
      </div>
    </div>
    <div class="diff-card normal" data-diff="normal" onclick="selectDiff('normal')">
      <div class="diff-icon-big">â­</div>
      <div class="diff-card-text">
        <div class="diff-card-name">Normal</div>
        <div class="diff-card-desc">Balanced fun Â· dogs need the right treats</div>
      </div>
    </div>
    <div class="diff-card hard" data-diff="hard" onclick="selectDiff('hard')">
      <div class="diff-icon-big">ğŸ”¥</div>
      <div class="diff-card-text">
        <div class="diff-card-name">Hard</div>
        <div class="diff-card-desc">Frisky dogs Â· picky eaters Â· bring plenty!</div>
      </div>
    </div>
    <div class="diff-card paws" data-diff="paws" onclick="selectDiff('paws')">
      <div class="diff-icon-big">ğŸ¾</div>
      <div class="diff-card-text">
        <div class="diff-card-name">Paws of Fury</div>
        <div class="diff-card-desc">Maximum chaos Â· very picky dogs Â· good luck!</div>
      </div>
    </div>
  </div>
  <div class="btn-row">
    <button class="btn btn-grey btn-sm" onclick="showScreen('custom-screen')">â† Back</button>
    <button class="btn btn-sm" onclick="goLevelSelect()">Choose Level â†’</button>
  </div>
</div>

<!-- LEVEL SELECT -->
<div class="screen hidden" id="level-screen">
  <h2>Choose Adventure ğŸ—ºï¸</h2>
  <div class="level-list" id="level-list">
    <div class="level-card unlocked" id="lc-0" onclick="beginLevel(0)">
      <div class="level-icon">ğŸ </div>
      <div class="level-card-text">
        <div class="level-card-name">Home Sweet Home</div>
        <div class="level-card-desc">Cosy rooms Â· scratch furniture Â· find the key!</div>
      </div>
    </div>
    <div class="level-card locked" id="lc-1">
      <div class="level-icon">ğŸŒ³</div>
      <div class="level-card-text">
        <div class="level-card-name">Neighbourhood Park</div>
        <div class="level-card-desc">Grassy paths Â· benches Â· pond to navigate</div>
      </div>
    </div>
    <div class="level-card locked" id="lc-2">
      <div class="level-icon">ğŸ¢</div>
      <div class="level-card-text">
        <div class="level-card-name">The Big Building</div>
        <div class="level-card-desc">Office floors Â· rooftop escape</div>
      </div>
    </div>
    <div class="level-card locked" id="lc-3">
      <div class="level-icon">ğŸš‰</div>
      <div class="level-card-text">
        <div class="level-card-name">Train Station</div>
        <div class="level-card-desc">Platform rush Â· dodge luggage Â· catch the train!</div>
      </div>
    </div>
  </div>
  <button class="btn btn-grey btn-sm" onclick="showScreen('diff-screen')">â† Back</button>
</div>

<!-- GAME OVER -->
<div class="screen hidden" id="gameover-screen">
  <div class="result-emoji">ğŸ˜¿</div>
  <h2>Nap Timeâ€¦</h2>
  <div id="go-name" style="font-size:15px;color:#8d6e63;font-weight:700;text-align:center"></div>
  <div id="go-score" class="result-score"></div>
  <div class="btn-row">
    <button class="btn btn-sm" onclick="retryLevel()">Try Again ğŸŒ¸</button>
    <button class="btn btn-grey btn-sm" onclick="goLevelSelect()">Levels</button>
  </div>
</div>

<!-- LEVEL COMPLETE -->
<div class="screen hidden" id="levelcomplete-screen">
  <div class="result-emoji" id="lc-emoji">ğŸ‰</div>
  <h2 id="lc-title">Level Complete!</h2>
  <div id="lc-desc" style="font-size:14px;color:#5d4037;font-weight:700;text-align:center;max-width:280px"></div>
  <div id="lc-score" class="result-score"></div>
  <div class="btn-row">
    <button class="btn btn-green btn-sm" id="lc-next-btn" onclick="nextLevel()">Next Level â†’</button>
    <button class="btn btn-grey btn-sm" onclick="goLevelSelect()">Levels</button>
  </div>
</div>

<!-- HUD -->
<div id="hud">
  <div class="hud-row">
    <div class="hud-pill">â­ <span id="score-val">0</span></div>
    <div class="hud-pill"><span id="key-indicator">ğŸ”‘ âœ—</span></div>
    <div class="hud-pill" id="treat-hud"><span id="treat-display">ğŸ¦´Ã—0</span></div>
    <div class="hud-pill" id="happy-hud" style="display:none"><span id="happy-display">ğŸŒˆ</span></div>
    <div class="hud-pill"><span id="diff-badge-hud" class="normal">â­</span></div>
    <div class="hud-pill" style="cursor:pointer;padding:4px 10px;" onclick="toggleMusic()" id="music-toggle-btn" title="Music: On">ğŸµ</div>
  </div>
</div>

<!-- CANVAS -->
<div id="game-canvas-wrap">
  <canvas id="gameCanvas" width="420" height="700"></canvas>
  <!-- TOUCH -->
  <div id="touch-controls">
    <div id="joystick-zone"><div id="joystick-knob"></div></div>
    <div class="action-btns">
      <div class="touch-action-btn" id="scratch-btn" ontouchstart="onScratchDown(event)" ontouchend="onScratchUp(event)">ğŸ¾</div>
    </div>
  </div>
</div>

<!-- POPUP CONTAINER -->
<div id="popup-layer" style="position:absolute;inset:0;pointer-events:none;z-index:30;overflow:hidden;"></div>

</div><!-- #app -->

</body>
</html>
<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AUDIO ENGINE (Web Audio API â€” no files needed)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let audioCtx = null;
function getAudio() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if (audioCtx.state === 'suspended') audioCtx.resume();
  return audioCtx;
}

function playMeow() {
  try {
    const ac = getAudio(), t = ac.currentTime;
    // Meow: two formants, pitch glide
    const osc1 = ac.createOscillator(), osc2 = ac.createOscillator();
    const gain = ac.createGain(), gain2 = ac.createGain();
    const filter = ac.createBiquadFilter();
    filter.type = 'bandpass'; filter.frequency.value = 1200; filter.Q.value = 3;
    osc1.type = 'sawtooth'; osc2.type = 'sine';
    osc1.frequency.setValueAtTime(340, t);
    osc1.frequency.exponentialRampToValueAtTime(520, t + 0.12);
    osc1.frequency.exponentialRampToValueAtTime(380, t + 0.28);
    osc2.frequency.setValueAtTime(680, t);
    osc2.frequency.exponentialRampToValueAtTime(1040, t + 0.12);
    osc2.frequency.exponentialRampToValueAtTime(760, t + 0.28);
    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(0.28, t + 0.04);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.32);
    gain2.gain.setValueAtTime(0.08, t);
    gain2.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
    osc1.connect(filter); filter.connect(gain); gain.connect(ac.destination);
    osc2.connect(gain2); gain2.connect(ac.destination);
    osc1.start(t); osc1.stop(t + 0.35);
    osc2.start(t); osc2.stop(t + 0.30);
  } catch(e) {}
}

function playHit() {
  try {
    const ac = getAudio(), t = ac.currentTime;
    const buf = ac.createBuffer(1, ac.sampleRate * 0.12, ac.sampleRate);
    const d = buf.getChannelData(0);
    for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / d.length, 2);
    const src = ac.createBufferSource(), g = ac.createGain();
    const f = ac.createBiquadFilter(); f.type = 'lowpass'; f.frequency.value = 800;
    src.buffer = buf; g.gain.setValueAtTime(0.35, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
    src.connect(f); f.connect(g); g.connect(ac.destination); src.start(t);
  } catch(e) {}
}

function playCollect() {
  try {
    const ac = getAudio(), t = ac.currentTime;
    [0, 0.07, 0.14].forEach((dt, i) => {
      const o = ac.createOscillator(), g = ac.createGain();
      o.type = 'sine'; o.frequency.value = [523, 659, 784][i];
      g.gain.setValueAtTime(0.18, t + dt); g.gain.exponentialRampToValueAtTime(0.001, t + dt + 0.18);
      o.connect(g); g.connect(ac.destination); o.start(t + dt); o.stop(t + dt + 0.2);
    });
  } catch(e) {}
}

function playKeyPickup() {
  try {
    const ac = getAudio(), t = ac.currentTime;
    [0, 0.08, 0.16, 0.24].forEach((dt, i) => {
      const o = ac.createOscillator(), g = ac.createGain();
      o.type = 'triangle'; o.frequency.value = [392, 523, 659, 1047][i];
      g.gain.setValueAtTime(0.22, t + dt); g.gain.exponentialRampToValueAtTime(0.001, t + dt + 0.25);
      o.connect(g); g.connect(ac.destination); o.start(t + dt); o.stop(t + dt + 0.3);
    });
  } catch(e) {}
}

function playDoorOpen() {
  try {
    const ac = getAudio(), t = ac.currentTime;
    [0, 0.1, 0.2, 0.3, 0.4].forEach((dt, i) => {
      const o = ac.createOscillator(), g = ac.createGain();
      o.type = 'sine'; o.frequency.value = [261, 329, 392, 523, 784][i];
      g.gain.setValueAtTime(0.2, t + dt); g.gain.exponentialRampToValueAtTime(0.001, t + dt + 0.35);
      o.connect(g); g.connect(ac.destination); o.start(t + dt); o.stop(t + dt + 0.4);
    });
  } catch(e) {}
}

function playLeverClick() {
  try {
    const ac = getAudio(), t = ac.currentTime;
    const o = ac.createOscillator(), g = ac.createGain();
    o.type = 'square'; o.frequency.setValueAtTime(180, t); o.frequency.exponentialRampToValueAtTime(90, t + 0.08);
    g.gain.setValueAtTime(0.25, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
    o.connect(g); g.connect(ac.destination); o.start(t); o.stop(t + 0.12);
  } catch(e) {}
}

function playBreak() {
  try {
    const ac = getAudio(), t = ac.currentTime;
    const buf = ac.createBuffer(1, ac.sampleRate * 0.18, ac.sampleRate);
    const d = buf.getChannelData(0);
    for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / d.length, 1.5) * 0.6;
    const src = ac.createBufferSource(), g = ac.createGain();
    const f = ac.createBiquadFilter(); f.type = 'highpass'; f.frequency.value = 400;
    src.buffer = buf; g.gain.setValueAtTime(0.4, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.18);
    src.connect(f); f.connect(g); g.connect(ac.destination); src.start(t);
  } catch(e) {}
}

function playWoof() {
  try {
    const ac = getAudio(), t = ac.currentTime;
    // Two-part woof: sharp attack bark + tail resonance
    const osc1 = ac.createOscillator(), osc2 = ac.createOscillator();
    const g1 = ac.createGain(), g2 = ac.createGain();
    const dist = ac.createWaveShaper();
    // Soft distortion for rough bark texture
    const curve = new Float32Array(256);
    for (let i = 0; i < 256; i++) { const x = (i * 2) / 256 - 1; curve[i] = (Math.PI + 200) * x / (Math.PI + 200 * Math.abs(x)); }
    dist.curve = curve;
    osc1.type = 'sawtooth';
    osc1.frequency.setValueAtTime(220, t);
    osc1.frequency.exponentialRampToValueAtTime(140, t + 0.08);
    osc1.frequency.exponentialRampToValueAtTime(100, t + 0.22);
    osc2.type = 'sine';
    osc2.frequency.setValueAtTime(180, t);
    osc2.frequency.exponentialRampToValueAtTime(80, t + 0.18);
    g1.gain.setValueAtTime(0, t);
    g1.gain.linearRampToValueAtTime(0.35, t + 0.02);
    g1.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
    g2.gain.setValueAtTime(0.15, t);
    g2.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
    osc1.connect(dist); dist.connect(g1); g1.connect(ac.destination);
    osc2.connect(g2); g2.connect(ac.destination);
    osc1.start(t); osc1.stop(t + 0.28);
    osc2.start(t); osc2.stop(t + 0.22);
  } catch(e) {}
}

function playDash() {
  try {
    const ac = getAudio(), t = ac.currentTime;
    const o = ac.createOscillator(), g = ac.createGain();
    const f = ac.createBiquadFilter(); f.type='highpass'; f.frequency.value=300;
    o.type='sawtooth';
    o.frequency.setValueAtTime(600,t); o.frequency.exponentialRampToValueAtTime(200,t+0.12);
    g.gain.setValueAtTime(0.18,t); g.gain.exponentialRampToValueAtTime(0.001,t+0.14);
    o.connect(f); f.connect(g); g.connect(ac.destination); o.start(t); o.stop(t+0.15);
  } catch(e){}
}

function playPurr() {
  try {
    const ac = getAudio(), t = ac.currentTime;
    // Low rumble oscillating â€” purring
    const o1 = ac.createOscillator(), o2 = ac.createOscillator();
    const lfo = ac.createOscillator(), lfoG = ac.createGain();
    const g = ac.createGain();
    o1.type='sine'; o1.frequency.value=55;
    o2.type='sine'; o2.frequency.value=60;
    lfo.type='sine'; lfo.frequency.value=28; // purr rate
    lfoG.gain.value=20;
    lfo.connect(lfoG); lfoG.connect(o1.frequency); lfoG.connect(o2.frequency);
    g.gain.setValueAtTime(0,t);
    g.gain.linearRampToValueAtTime(0.22,t+0.1);
    g.gain.setValueAtTime(0.22,t+0.55);
    g.gain.exponentialRampToValueAtTime(0.001,t+0.75);
    o1.connect(g); o2.connect(g); g.connect(ac.destination);
    o1.start(t); o1.stop(t+0.8);
    o2.start(t); o2.stop(t+0.8);
    lfo.start(t); lfo.stop(t+0.8);
  } catch(e){}
}

function playPlatformStart() {
  try {
    const ac = getAudio(), t = ac.currentTime;
    const o = ac.createOscillator(), g = ac.createGain();
    o.type = 'sawtooth'; o.frequency.setValueAtTime(220, t); o.frequency.linearRampToValueAtTime(330, t + 0.15);
    g.gain.setValueAtTime(0.2, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.22);
    o.connect(g); g.connect(ac.destination); o.start(t); o.stop(t + 0.25);
  } catch(e) {}
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COZY JAPANESE MUSIC ENGINE
// Procedural pentatonic koto/shakuhachi-inspired ambient music
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let musicCtx = null, musicPlaying = false, musicEnabled = true;
let musicNodes = []; // track active nodes for cleanup

// Japanese pentatonic scale (A minor pentatonic) in Hz
// éŸ³éš: A3, C4, D4, E4, G4, A4, C5, D5, E5, G5
const PENTATONIC = [220.0, 261.6, 293.7, 329.6, 392.0, 440.0, 523.3, 587.3, 659.3, 784.0];

// Melodic phrases â€” indices into PENTATONIC
const PHRASES = [
  [5,4,3,2,1,0,2,3],       // falling
  [0,2,3,5,4,3,2,0],       // arch
  [5,5,4,3,5,4,2,0],       // ornamental
  [3,4,5,4,3,2,3,2],       // winding
  [0,3,2,0,2,3,5,4],       // rising
  [5,4,3,5,3,2,0,2],       // meditative
];

function getMusicCtx() {
  if (!musicCtx) {
    musicCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (musicCtx.state === 'suspended') musicCtx.resume();
  return musicCtx;
}

// Master gain for music (separate from SFX)
let masterGain = null;
function getMasterGain() {
  if (!masterGain) {
    const ac = getMusicCtx();
    masterGain = ac.createGain();
    masterGain.gain.value = 0.0;
    masterGain.connect(ac.destination);
  }
  return masterGain;
}

// Reverb convolver for lush room sound
let reverbNode = null;
async function getReverb() {
  if (reverbNode) return reverbNode;
  const ac = getMusicCtx();
  reverbNode = ac.createConvolver();
  // Generate synthetic impulse response (room reverb)
  const len = ac.sampleRate * 2.8;
  const buf = ac.createBuffer(2, len, ac.sampleRate);
  for (let ch = 0; ch < 2; ch++) {
    const d = buf.getChannelData(ch);
    for (let i = 0; i < len; i++) {
      const decay = Math.pow(1 - i/len, 2.2);
      d[i] = (Math.random()*2-1) * decay * (i < ac.sampleRate*0.01 ? 0 : 1);
    }
  }
  reverbNode.buffer = buf;
  reverbNode.connect(getMasterGain());
  return reverbNode;
}

// Koto-like pluck: sine + triangle blend, fast attack, long decay
function playKotoNote(freq, startTime, duration, gain=0.22, reverb=null) {
  try {
    const ac = getMusicCtx();
    const osc1 = ac.createOscillator();
    const osc2 = ac.createOscillator();
    const g = ac.createGain();
    const filter = ac.createBiquadFilter();

    osc1.type = 'triangle'; osc1.frequency.value = freq;
    osc2.type = 'sine';     osc2.frequency.value = freq * 2.003; // slight detune for shimmer
    filter.type = 'lowpass'; filter.frequency.setValueAtTime(3000, startTime);
    filter.frequency.exponentialRampToValueAtTime(800, startTime + duration*0.4);

    // Pluck envelope: very fast attack, exponential decay (koto character)
    g.gain.setValueAtTime(0, startTime);
    g.gain.linearRampToValueAtTime(gain, startTime + 0.008);
    g.gain.exponentialRampToValueAtTime(gain * 0.3, startTime + duration * 0.25);
    g.gain.exponentialRampToValueAtTime(0.0001, startTime + duration);

    osc1.connect(filter); osc2.connect(filter); filter.connect(g);
    if (reverb) g.connect(reverb);
    g.connect(getMasterGain());

    osc1.start(startTime); osc1.stop(startTime + duration + 0.1);
    osc2.start(startTime); osc2.stop(startTime + duration + 0.1);
    musicNodes.push(osc1, osc2);
  } catch(e) {}
}

// Shakuhachi-like breathy tone: sine + slight noise + vibrato
function playFluteNote(freq, startTime, duration, gain=0.12) {
  try {
    const ac = getMusicCtx();
    const osc = ac.createOscillator();
    const vibLfo = ac.createOscillator();
    const vibGain = ac.createGain();
    const noiseNode = ac.createOscillator(); // second osc for breath texture
    const g = ac.createGain();
    const filter = ac.createBiquadFilter();

    osc.type = 'sine'; osc.frequency.value = freq;
    vibLfo.type = 'sine'; vibLfo.frequency.value = 5.2; // natural vibrato rate
    vibGain.gain.value = freq * 0.012; // subtle vibrato depth
    vibLfo.connect(vibGain); vibGain.connect(osc.frequency);

    noiseNode.type = 'sawtooth'; noiseNode.frequency.value = freq * 1.01;
    filter.type = 'bandpass'; filter.frequency.value = freq * 1.5; filter.Q.value = 8;

    // Breath envelope: slow attack, long sustain
    g.gain.setValueAtTime(0, startTime);
    g.gain.linearRampToValueAtTime(gain, startTime + duration*0.18);
    g.gain.setValueAtTime(gain, startTime + duration*0.7);
    g.gain.exponentialRampToValueAtTime(0.0001, startTime + duration);

    const ng = ac.createGain(); ng.gain.value = gain * 0.18;
    noiseNode.connect(filter); filter.connect(ng); ng.connect(g);
    osc.connect(g); g.connect(getMasterGain());

    osc.start(startTime); osc.stop(startTime + duration + 0.05);
    noiseNode.start(startTime); noiseNode.stop(startTime + duration + 0.05);
    vibLfo.start(startTime); vibLfo.stop(startTime + duration + 0.05);
    musicNodes.push(osc, vibLfo, noiseNode);
  } catch(e) {}
}

// Low drum (taiko-ish): noise burst + low sine thud
function playDrum(startTime, gain=0.14) {
  try {
    const ac = getMusicCtx();
    const buf = ac.createBuffer(1, ac.sampleRate * 0.25, ac.sampleRate);
    const d = buf.getChannelData(0);
    for (let i=0; i<d.length; i++) d[i] = (Math.random()*2-1)*Math.pow(1-i/d.length,1.6);
    const src = ac.createBufferSource();
    const osc = ac.createOscillator(); // thud body
    const g1 = ac.createGain(), g2 = ac.createGain();
    const f = ac.createBiquadFilter(); f.type='lowpass'; f.frequency.value=180;

    src.buffer = buf;
    osc.type='sine'; osc.frequency.setValueAtTime(80,startTime); osc.frequency.exponentialRampToValueAtTime(40,startTime+0.12);
    g1.gain.setValueAtTime(gain*0.7,startTime); g1.gain.exponentialRampToValueAtTime(0.0001,startTime+0.22);
    g2.gain.setValueAtTime(gain,startTime); g2.gain.exponentialRampToValueAtTime(0.0001,startTime+0.14);

    src.connect(f); f.connect(g1); g1.connect(getMasterGain());
    osc.connect(g2); g2.connect(getMasterGain());

    src.start(startTime); osc.start(startTime); osc.stop(startTime+0.28);
    musicNodes.push(osc);
  } catch(e){}
}

// Schedule one "bar" of music
let musicScheduleId = null;
let nextBarTime = 0;
const BAR_DURATION = 3.2; // seconds per bar â€” slow, meditative tempo
let currentPhraseIdx = 0;
let phrasePosition = 0;

function scheduleMusicBar() {
  if (!musicPlaying || !musicEnabled) return;
  try {
    const ac = getMusicCtx();
    const barStart = nextBarTime;
    const phrase = PHRASES[currentPhraseIdx % PHRASES.length];
    const noteDur = BAR_DURATION / phrase.length;

    // Schedule koto melody
    phrase.forEach((noteIdx, i) => {
      const freq = PENTATONIC[noteIdx];
      const noteStart = barStart + i * noteDur;
      // Vary velocity for humanised feel
      const vel = 0.14 + Math.random()*0.12;
      playKotoNote(freq, noteStart, noteDur*0.85, vel);
      // Occasionally double the note an octave down for depth
      if (Math.random() < 0.25) {
        playKotoNote(freq * 0.5, noteStart + 0.015, noteDur*0.7, vel*0.4);
      }
    });

    // Flute line â€” plays a slower counter-melody every 2 bars
    if (currentPhraseIdx % 2 === 0) {
      const flutePhrase = [phrase[0], phrase[2], phrase[4]||phrase[3], phrase[6]||phrase[5]];
      flutePhrase.forEach((noteIdx, i) => {
        const freq = PENTATONIC[Math.min(noteIdx+2, PENTATONIC.length-1)] * 0.5; // lower octave flute
        const noteStart = barStart + i * (BAR_DURATION/flutePhrase.length);
        if (Math.random() < 0.7) playFluteNote(freq, noteStart, BAR_DURATION/flutePhrase.length * 0.9, 0.08);
      });
    }

    // Sparse taiko drums â€” 1-2 per bar on random beats
    const drumBeats = [0, 1, 3].filter(()=>Math.random()<0.45);
    drumBeats.forEach(beat => {
      playDrum(barStart + beat * (BAR_DURATION/4), 0.10+Math.random()*0.06);
    });

    // Ambient bass drone (root note) â€” very soft
    playKotoNote(PENTATONIC[0] * 0.25, barStart, BAR_DURATION * 0.95, 0.06);

    // Advance phrase every 2 bars
    phrasePosition++;
    if (phrasePosition >= 2) {
      phrasePosition = 0;
      currentPhraseIdx = (currentPhraseIdx + 1) % PHRASES.length;
    }

    nextBarTime += BAR_DURATION;

    // Schedule next bar slightly before this one ends
    const msUntilNext = (nextBarTime - ac.currentTime - 0.3) * 1000;
    musicScheduleId = setTimeout(scheduleMusicBar, Math.max(0, msUntilNext));
  } catch(e) {}
}

function startMusic() {
  if (musicPlaying) return;
  musicPlaying = true;
  try {
    const ac = getMusicCtx();
    nextBarTime = ac.currentTime + 0.2;
    getMasterGain().gain.cancelScheduledValues(ac.currentTime);
    getMasterGain().gain.setValueAtTime(getMasterGain().gain.value, ac.currentTime);
    getMasterGain().gain.linearRampToValueAtTime(0.72, ac.currentTime + 1.5);
    // Kick off reverb (async, but music starts without it)
    getReverb().catch(()=>{});
    scheduleMusicBar();
  } catch(e){}
}

function stopMusic(fade=true) {
  musicPlaying = false;
  if (musicScheduleId) { clearTimeout(musicScheduleId); musicScheduleId=null; }
  try {
    const ac = getMusicCtx();
    const mg = getMasterGain();
    if (fade) {
      mg.gain.cancelScheduledValues(ac.currentTime);
      mg.gain.setValueAtTime(mg.gain.value, ac.currentTime);
      mg.gain.linearRampToValueAtTime(0.0, ac.currentTime + 1.2);
    } else {
      mg.gain.value = 0;
    }
  } catch(e){}
}

function toggleMusic() {
  musicEnabled = !musicEnabled;
  const btn = document.getElementById('music-toggle-btn');
  if (musicEnabled) {
    startMusic();
    if (btn) btn.textContent = 'ğŸµ';
    if (btn) btn.title = 'Music: On';
  } else {
    stopMusic(true);
    if (btn) btn.textContent = 'ğŸ”‡';
    if (btn) btn.title = 'Music: Off';
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONSTANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const CW = 420, CH = 700;
const TILE = 42;
const COLS = 10;
const C = COLS; // global alias used throughout
const CAT_SPEED = 2.1;
const SCRATCH_RANGE = 92;
const DASH_SPEED = 8.5;
const DASH_FRAMES = 18;
const DASH_COOLDOWN = 90;   // 1.5s at 60fps
const HAPPY_DURATION = 480; // 8s
const HAPPY_SPEED_MULT = 1.18;

const SCRATCH_ARC = Math.PI * 1.1;
const SCRATCH_COOLDOWN = 24;

const DIFF = {
  easy:   {dogSpeed:0.5,  treatBonus:1},  // wrong treat still works
  normal: {dogSpeed:0.8,  treatBonus:0},  // must use right treat
  hard:   {dogSpeed:1.25, treatBonus:-1}, // needs +1 extra treat
  paws:   {dogSpeed:1.85, treatBonus:-2}, // needs +2 extra treats
};

const CAT_COLORS = [
  {body:'#fff9f0',dark:'#ffe0cc',stroke:'#ffb3a0'},
  {body:'#ffb74d',dark:'#e65100',stroke:'#bf360c'},
  {body:'#bdbdbd',dark:'#757575',stroke:'#616161'},
  {body:'#424242',dark:'#212121',stroke:'#1a1a1a'},
  {body:'#ffcc80',dark:'#ffa000',stroke:'#ff8f00'},
  {body:'#bcaaa4',dark:'#795548',stroke:'#6d4c41'},
  {body:'#f8bbd0',dark:'#f48fb1',stroke:'#e91e63'},
];
const EYE_COLORS = ['#43a047','#1e88e5','#fb8c00','#8e24aa','het'];

let catCfg = {colorIdx:0, pattern:'solid', eyeIdx:0, accessory:'none'};
let catName = 'Mochi';
let difficulty = 'easy';
let currentLevel = 0;
let unlockedLevels = 1;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CAT DRAWING (top-down)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drawCatTopDown(ctx, x, y, cfg, t=0, facingAngle=0, moving=false, scratchAnim=0) {
  const col = CAT_COLORS[cfg.colorIdx];
  const eyeCol = cfg.eyeIdx === 4 ? null : EYE_COLORS[cfg.eyeIdx];
  const bobY = moving ? Math.sin(t * 0.28) * 1.5 : 0;
  ctx.save();
  ctx.translate(x, y + bobY);
  ctx.rotate(facingAngle);

  // Tail wag
  const tailWag = Math.sin(t * 0.12) * 18;
  ctx.strokeStyle = col.body; ctx.lineWidth = 7; ctx.lineCap = 'round';
  ctx.beginPath(); ctx.moveTo(0, 10);
  ctx.quadraticCurveTo(16 + tailWag, 24, 10 + tailWag, 36); ctx.stroke();
  ctx.strokeStyle = col.stroke; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(0, 10);
  ctx.quadraticCurveTo(16 + tailWag, 24, 10 + tailWag, 36); ctx.stroke();

  // Body
  ctx.fillStyle = col.body; ctx.strokeStyle = col.stroke; ctx.lineWidth = 2.5;
  ctx.beginPath(); ctx.ellipse(0, 4, 13, 16, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke();

  // Patterns
  if (cfg.pattern === 'tabby') {
    ctx.save(); ctx.globalAlpha = 0.35; ctx.fillStyle = col.dark;
    ctx.fillRect(-5, 0, 4, 10); ctx.fillRect(1, -4, 4, 8); ctx.fillRect(-3, 8, 6, 5); ctx.restore();
  } else if (cfg.pattern === 'spots') {
    ctx.save(); ctx.globalAlpha = 0.4; ctx.fillStyle = col.dark;
    ctx.beginPath(); ctx.arc(-5, 2, 4, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(4, 10, 3, 0, Math.PI * 2); ctx.fill(); ctx.restore();
  } else if (cfg.pattern === 'tuxedo') {
    ctx.save(); ctx.fillStyle = 'white';
    ctx.beginPath(); ctx.ellipse(0, 7, 6, 9, 0, 0, Math.PI * 2); ctx.fill(); ctx.restore();
  } else if (cfg.pattern === 'calico') {
    ctx.save(); ctx.globalAlpha = 0.5;
    ctx.fillStyle = '#e65100'; ctx.beginPath(); ctx.arc(-5, 0, 5, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#212121'; ctx.beginPath(); ctx.arc(4, 8, 4, 0, Math.PI * 2); ctx.fill(); ctx.restore();
  }

  // Head
  ctx.fillStyle = col.body; ctx.strokeStyle = col.stroke; ctx.lineWidth = 2.5;
  ctx.beginPath(); ctx.arc(0, -12, 13, 0, Math.PI * 2); ctx.fill(); ctx.stroke();

  // Ears
  ctx.fillStyle = col.body; ctx.strokeStyle = col.stroke; ctx.lineWidth = 2;
  [[-8, -22], [8, -22]].forEach(([ex, ey]) => {
    ctx.beginPath(); ctx.moveTo(ex - 6, ey + 2); ctx.lineTo(ex + 6, ey + 2); ctx.lineTo(ex, ey - 11); ctx.closePath(); ctx.fill(); ctx.stroke();
  });
  ctx.fillStyle = '#f8bbd0';
  [[-8, -22], [8, -22]].forEach(([ex, ey]) => {
    ctx.beginPath(); ctx.moveTo(ex - 3.5, ey + 1); ctx.lineTo(ex + 3.5, ey + 1); ctx.lineTo(ex, ey - 7); ctx.closePath(); ctx.fill();
  });

  // Eyes
  const blink = (Math.floor(t * 0.025) % 45 === 0);
  const eyeH = blink ? 1 : 4.5;
  [[-5, -13], [5, -13]].forEach(([ex, ey], i) => {
    ctx.fillStyle = cfg.eyeIdx === 4 ? (i === 0 ? '#1e88e5' : '#fb8c00') : eyeCol;
    ctx.beginPath(); ctx.ellipse(ex, ey, 3.5, eyeH, 0, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(ex + 1, ey - 1, 1.2, 0, Math.PI * 2); ctx.fill();
  });

  // Nose + mouth
  ctx.fillStyle = '#f48fb1'; ctx.beginPath(); ctx.arc(0, -9, 2.5, 0, Math.PI * 2); ctx.fill();
  ctx.strokeStyle = '#f48fb1'; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.moveTo(0, -7); ctx.lineTo(-3, -5); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(0, -7); ctx.lineTo(3, -5); ctx.stroke();

  // Whiskers
  ctx.strokeStyle = 'rgba(150,120,110,0.5)'; ctx.lineWidth = 1;
  [[-14, -10], [-18, -9], [-14, -8]].forEach(([wx, wy]) => { ctx.beginPath(); ctx.moveTo(-2, -9); ctx.lineTo(wx, wy); ctx.stroke(); });
  [[14, -10], [18, -9], [14, -8]].forEach(([wx, wy]) => { ctx.beginPath(); ctx.moveTo(2, -9); ctx.lineTo(wx, wy); ctx.stroke(); });

  // Blush
  ctx.fillStyle = 'rgba(255,140,140,0.2)';
  ctx.beginPath(); ctx.ellipse(-7, -11, 4, 2.5, 0, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(7, -11, 4, 2.5, 0, 0, Math.PI * 2); ctx.fill();

  // Scratch animation â€” claw arc in front
  if (scratchAnim > 0) {
    const progress = 1 - scratchAnim / SCRATCH_COOLDOWN;
    ctx.save();
    ctx.globalAlpha = (1 - progress) * 0.85;
    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2.5; ctx.lineCap = 'round';
    const sweepAngle = SCRATCH_ARC * progress;
    for (let ci = 0; ci < 3; ci++) {
      const off = (ci - 1) * 0.28;
      ctx.beginPath();
      ctx.arc(0, -12, 28 + ci * 7, -Math.PI / 2 - SCRATCH_ARC / 2 + off,
              -Math.PI / 2 - SCRATCH_ARC / 2 + sweepAngle + off);
      ctx.stroke();
    }
    // Claw sparks
    ctx.fillStyle = '#ffe082';
    for (let ci = 0; ci < 4; ci++) {
      const sa = -Math.PI / 2 - SCRATCH_ARC / 2 + sweepAngle + (ci - 1.5) * 0.2;
      const r = 34 + ci * 4;
      ctx.beginPath(); ctx.arc(Math.cos(sa) * r, -12 + Math.sin(sa) * r, 2.5, 0, Math.PI * 2); ctx.fill();
    }
    ctx.restore();
  }

  drawAccessory(ctx, cfg.accessory, t);
  ctx.restore();
}

function drawAccessory(ctx, acc, t) {
  if (acc === 'none') return;
  if (acc === 'bow') {
    ctx.fillStyle = '#f44336'; ctx.strokeStyle = '#b71c1c'; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(0, -24); ctx.bezierCurveTo(-8, -30, -12, -22, -6, -20); ctx.bezierCurveTo(-2, -18, 0, -22, 0, -24); ctx.fill(); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0, -24); ctx.bezierCurveTo(8, -30, 12, -22, 6, -20); ctx.bezierCurveTo(2, -18, 0, -22, 0, -24); ctx.fill(); ctx.stroke();
    ctx.fillStyle = '#ffcdd2'; ctx.beginPath(); ctx.arc(0, -24, 3, 0, Math.PI * 2); ctx.fill();
  } else if (acc === 'flower') {
    for (let i = 0; i < 6; i++) {
      const a = i / 6 * Math.PI * 2;
      ctx.fillStyle = i % 2 === 0 ? '#f48fb1' : '#fff';
      ctx.beginPath(); ctx.ellipse(Math.cos(a) * 6, Math.sin(a) * 6 - 24, 3.5, 3.5, a, 0, Math.PI * 2); ctx.fill();
    }
    ctx.fillStyle = '#ffe082'; ctx.beginPath(); ctx.arc(0, -24, 3.5, 0, Math.PI * 2); ctx.fill();
  } else if (acc === 'hat') {
    ctx.fillStyle = '#212121'; ctx.strokeStyle = '#424242'; ctx.lineWidth = 1.5;
    ctx.fillRect(-9, -34, 18, 10); ctx.stroke();
    ctx.fillRect(-12, -35, 24, 4); ctx.stroke();
    ctx.fillStyle = '#f48fb1'; ctx.fillRect(-9, -33, 18, 3);
  } else if (acc === 'stars') {
    const st = t * 0.05;
    [[-10, -24], [10, -24], [0, -28]].forEach(([sx, sy], i) => {
      const p = 0.8 + Math.sin(st + i) * 0.3;
      ctx.save(); ctx.translate(sx, sy); ctx.scale(p, p);
      ctx.fillStyle = ['#ffd700', '#ff6b9d', '#64dfdf'][i];
      drawStar(ctx, 0, 0, 4, 2); ctx.restore();
    });
  } else if (acc === 'crown') {
    ctx.fillStyle = '#ffd700'; ctx.strokeStyle = '#ff8f00'; ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(-10, -26); ctx.lineTo(-10, -34); ctx.lineTo(-6, -30);
    ctx.lineTo(0, -36); ctx.lineTo(6, -30); ctx.lineTo(10, -34); ctx.lineTo(10, -26); ctx.closePath();
    ctx.fill(); ctx.stroke();
    ['#e53935', '#1e88e5', '#43a047'].forEach((c, i) => {
      ctx.fillStyle = c; ctx.beginPath(); ctx.arc(-5 + i * 5, -28, 1.8, 0, Math.PI * 2); ctx.fill();
    });
  }
}

function drawStar(ctx, cx, cy, r1, r2) {
  ctx.beginPath();
  for (let i = 0; i < 10; i++) {
    const a = i / 10 * Math.PI * 2 - Math.PI / 2;
    const r = i % 2 === 0 ? r1 : r2;
    i === 0 ? ctx.moveTo(cx + Math.cos(a) * r, cy + Math.sin(a) * r)
            : ctx.lineTo(cx + Math.cos(a) * r, cy + Math.sin(a) * r);
  }
  ctx.closePath(); ctx.fill();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UI
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let previewAnimId = null;

function updatePreview() {
  clearTimeout(updatePreview._t);
  updatePreview._t = setTimeout(() => {
    renderCatPreview('previewCanvas', 90, 90);
    renderCatPreview('titleCatCanvas', 130, 130);
  }, 16);
}

function renderCatPreview(id, w, h) {
  const c = document.getElementById(id); if (!c) return;
  const cx = c.getContext('2d');
  cx.clearRect(0, 0, w, h);
  drawCatTopDown(cx, w / 2, h / 2 + 8, catCfg, Date.now() * 0.016, 0, false, 0);
}

function setCatProp(prop, val) {
  catCfg[prop] = val;
  if (prop === 'colorIdx') document.querySelectorAll('#color-swatches .swatch').forEach(s => s.classList.toggle('selected', +s.dataset.idx === val));
  else if (prop === 'eyeIdx') document.querySelectorAll('#eye-swatches .swatch').forEach(s => s.classList.toggle('selected', +s.dataset.idx === val));
  else if (prop === 'pattern') document.querySelectorAll('#pattern-opts .opt-btn').forEach(s => s.classList.toggle('selected', s.dataset.val === val));
  else if (prop === 'accessory') document.querySelectorAll('#acc-opts .opt-btn').forEach(s => s.classList.toggle('selected', s.dataset.val === val));
  updatePreview();
}

function selectDiff(d) {
  difficulty = d;
  document.querySelectorAll('.diff-card').forEach(c => c.classList.toggle('selected', c.dataset.diff === d));
}

function showScreen(id) {
  document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
  const el = document.getElementById(id); if (el) el.classList.remove('hidden');
  document.getElementById('hud').style.display = 'none';
  document.getElementById('game-canvas-wrap').style.display = 'none';
  if (id === 'custom-screen') { updatePreview(); startPreviewAnim(); }
  else if (id === 'title-screen') startPreviewAnim();
  else stopPreviewAnim();
}

function startPreviewAnim() {
  stopPreviewAnim();
  if (musicEnabled && !musicPlaying) startMusic();
  function frame() {
    renderCatPreview('previewCanvas', 90, 90);
    renderCatPreview('titleCatCanvas', 130, 130);
    previewAnimId = requestAnimationFrame(frame);
  }
  previewAnimId = requestAnimationFrame(frame);
}
function stopPreviewAnim() { if (previewAnimId) { cancelAnimationFrame(previewAnimId); previewAnimId = null; } }

function goLevelSelect() {
  catName = document.getElementById('cat-name-input').value.trim() || 'Mochi';
  updateLevelCards(); showScreen('level-screen');
}
function updateLevelCards() {
  for (let i = 0; i < 4; i++) {
    const el = document.getElementById('lc-' + i); if (!el) continue;
    const unlocked = i < unlockedLevels;
    el.classList.toggle('locked', !unlocked); el.classList.toggle('unlocked', unlocked);
    el.onclick = unlocked ? () => beginLevel(i) : null;
  }
  const el0 = document.getElementById('lc-0');
  if (el0) { el0.classList.remove('locked'); el0.classList.add('unlocked'); el0.onclick = () => beginLevel(0); }
}
function quickPlay() { catName = document.getElementById('cat-name-input')?.value.trim() || 'Mochi'; updateLevelCards(); showScreen('level-screen'); }
function retryLevel() { beginLevel(currentLevel); }
function nextLevel() { if (currentLevel + 1 < 4) beginLevel(currentLevel + 1); else goLevelSelect(); }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LEVEL DATA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const LEVEL_DEFS = [
  { name:'Home Sweet Home', icon:'ğŸ ', theme:'home', rows:32,
    floorTile:{fill:'#efebe9', alt:'#e8ddd8', line:'#d7ccc8'},
    wallFill:'#bcaaa4', elevFill:'#fff9f0', elevStroke:'#ffb3a0',
    completeTxt:'You found the cat door! ğŸ±ğŸ ', dogCount:3,
    collectEmojis:['ğŸŸ','ğŸ¥›','ğŸ£','ğŸ§¶','ğŸª†'],
    secretEmojis:['ğŸ ','ğŸ§¸','ğŸ’'],
    doorStyle:'home',
  },
  { name:'Neighbourhood Park', icon:'ğŸŒ³', theme:'park', rows:36,
    floorTile:{fill:'#c8e6c9', alt:'#b2dfdb', line:'#a5d6a7'},
    wallFill:'#388e3c', elevFill:'#e8f5e9', elevStroke:'#66bb6a',
    completeTxt:'You reached the park gate! ğŸŒ³ğŸŒ¸', dogCount:4,
    collectEmojis:['ğŸ','ğŸŸ','ğŸŒ¸','ğŸ¾','ğŸ‚'],
    secretEmojis:['ğŸ¦‹','ğŸ„','ğŸªº'],
    doorStyle:'park',
  },
  { name:'The Big Building', icon:'ğŸ¢', theme:'building', rows:40,
    floorTile:{fill:'#cfd8dc', alt:'#b0bec5', line:'#90a4ae'},
    wallFill:'#607d8b', elevFill:'#eceff1', elevStroke:'#78909c',
    completeTxt:'Rooftop reached! ğŸ¢âœ¨', dogCount:5,
    collectEmojis:['ğŸ±','ğŸ¥«','â­','ğŸ”®','ğŸ’'],
    secretEmojis:['ğŸ“€','ğŸ','ğŸ”®'],
    doorStyle:'building',
  },
  { name:'Train Station', icon:'ğŸš‰', theme:'station', rows:44,
    floorTile:{fill:'#d1c4e9', alt:'#b39ddb', line:'#9575cd'},
    wallFill:'#5e35b1', elevFill:'#ede7f6', elevStroke:'#9575cd',
    completeTxt:'All aboard! ğŸš‰ğŸŠ', dogCount:5,
    collectEmojis:['ğŸ™','ğŸœ','ğŸ«','ğŸ§¸','ğŸš„'],
    secretEmojis:['ğŸŸï¸','ğŸ“¿','ğŸ—ï¸'],
    doorStyle:'station',
  },
];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WORLD GENERATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Tile types: 0=floor, 1=wall, 2=elevated(impassable without interaction), 3=void/water
function seededRng(seed) { let s = seed | 0; return () => { s = (s * 9301 + 49297) % 233280; return s / 233280; }; }

function generateWorld(levelIdx) {
  const def = LEVEL_DEFS[levelIdx];
  const R = def.rows;
  const grid = Array.from({length:R}, () => Array(C).fill(0));
  // Borders
  for (let r = 0; r < R; r++) { grid[r][0] = 1; grid[r][C-1] = 1; }
  for (let c = 0; c < C; c++) { grid[0][c] = 1; grid[R-1][c] = 1; }
  // Door gap
  grid[0][4] = 0; grid[0][5] = 0;

  const rng = seededRng(levelIdx * 7919 + Math.floor(Date.now() / 1000) % 9999);
  const themes = {
    home:     [{type:1,count:10,w:2,h:1},{type:1,count:6,w:1,h:2},{type:2,count:4,w:2,h:1}],
    park:     [{type:1,count:12,w:1,h:1},{type:3,count:2,w:3,h:3},{type:2,count:5,w:2,h:1}],
    building: [{type:1,count:14,w:3,h:1},{type:1,count:6,w:1,h:2},{type:2,count:6,w:2,h:1}],
    station:  [{type:1,count:12,w:2,h:1},{type:3,count:3,w:2,h:2},{type:2,count:6,w:2,h:1}],
  };
  for (const spec of (themes[def.theme] || themes.home)) {
    for (let i = 0; i < spec.count; i++) {
      const r = Math.floor(rng() * (R-6)) + 3;
      const c = Math.floor(rng() * (C-2-spec.w)) + 1;
      if (r <= 2 && c >= 3 && c <= 5) continue;
      if (r >= R - 4) continue;
      for (let dr = 0; dr < spec.h && r+dr < R-1; dr++)
        for (let dc = 0; dc < spec.w && c+dc < C-1; dc++)
          if (grid[r+dr][c+dc] === 0) grid[r+dr][c+dc] = spec.type;
    }
  }
  // Ensure navigable rows
  for (let r = 3; r < R-3; r += 3) {
    let hasGap = false;
    for (let c = 1; c < C-1; c++) if (grid[r][c] === 0) { hasGap = true; break; }
    if (!hasGap) { grid[r][4] = 0; grid[r][5] = 0; }
  }
  return grid;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INTERACTABLE GENERATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Types: 'box'(scratchable/breakable), 'lever'(toggles platform), 
//        'vending'(drops food), 'switch'(opens elev), 'plant'(decorative break),
//        'luggage'(knockable), 'feeder'(scatter birds)
function generateInteractables(levelIdx, grid, R, rng) {
  const def = LEVEL_DEFS[levelIdx];
  const items = [];
  const used = new Set();

  // Collect valid floor positions
  const floors = [];
  for (let r = 2; r < R-2; r++)
    for (let c = 1; c < C-1; c++)
      if (grid[r][c] === 0) floors.push({r,c});

  function place(type, emoji, brokenEmoji, pts, en, extra={}) {
    for (let a = 0; a < 40; a++) {
      const cell = floors[Math.floor(rng() * floors.length)];
      if (!cell) continue;
      const k = `${cell.r},${cell.c}`;
      if (used.has(k)) continue;
      // Don't crowd start/end
      if (cell.r >= R-4 || cell.r <= 2) continue;
      used.add(k);
      items.push({
        type, emoji, brokenEmoji, pts, en,
        wx: cell.c*TILE + TILE/2, wy: cell.r*TILE + TILE/2,
        active: true, activated: false, animTick: 0,
        ...extra
      });
      return true;
    }
    return false;
  }

  // Theme-specific interactables
  if (def.theme === 'home') {
    for (let i = 0; i < 5; i++) place('box','ğŸ“¦','ğŸ—ƒï¸', 8, 0);
    for (let i = 0; i < 3; i++) place('plant','ğŸª´','ğŸŒ¿', 4, 0);
    place('lamp','ğŸ’¡','ğŸ’¡', 0, 0, {toggled:false});
    // 2 lever+platform pairs
    for (let i = 0; i < 2; i++) placeLeverPlatformPair(items, floors, grid, R, rng, used, i, def);
  } else if (def.theme === 'park') {
    for (let i = 0; i < 4; i++) place('plant','ğŸŒ¸','ğŸŒ¸', 5, 0, {scatter:true});
    for (let i = 0; i < 3; i++) place('box','ğŸª¨','ğŸ’¨', 6, 0);
    place('feeder','ğŸ¦â€â¬›','ğŸ¦', 0, 0);
    for (let i = 0; i < 2; i++) placeLeverPlatformPair(items, floors, grid, R, rng, used, i, def);
  } else if (def.theme === 'building') {
    for (let i = 0; i < 4; i++) place('box','ğŸ“„','ğŸ“ƒ', 5, 0);
    place('vending','ğŸ°','ğŸ¥¤', 0, 0);
    for (let i = 0; i < 2; i++) place('plant','ğŸª´','ğŸŒ±', 3, 0);
    for (let i = 0; i < 2; i++) placeLeverPlatformPair(items, floors, grid, R, rng, used, i, def);
  } else {
    for (let i = 0; i < 5; i++) place('luggage','ğŸ§³','ğŸ‘œ', 7, 0);
    place('feeder','ğŸ“°','ğŸ“°', 0, 0);
    for (let i = 0; i < 2; i++) placeLeverPlatformPair(items, floors, grid, R, rng, used, i, def);
  }
  return items;
}

function placeLeverPlatformPair(items, floors, grid, R, rng, used, idx, def) {
  // Lever on one side, platform path across void/elevated area
  const leverFloors = floors.filter(p => p.r > 4 && p.r < R-5 && !used.has(`${p.r},${p.c}`));
  if (leverFloors.length < 2) return;
  const leverCell = leverFloors[Math.floor(rng() * leverFloors.length)];
  used.add(`${leverCell.r},${leverCell.c}`);
  const leverWx = leverCell.c*TILE + TILE/2;
  const leverWy = leverCell.r*TILE + TILE/2;
  const platformId = `plat_${idx}`;
  items.push({
    type:'lever', emoji:'ğŸ”§', brokenEmoji:'ğŸ”§', pts:0, en:0,
    wx:leverWx, wy:leverWy,
    active:true, activated:false, animTick:0,
    platformId,
  });
  // Moving platform â€” travels horizontally between two x positions
  const startX = (2 + Math.floor(rng() * 3)) * TILE + TILE/2;
  const endX   = (5 + Math.floor(rng() * 3)) * TILE + TILE/2;
  const platY  = leverCell.r * TILE - TILE * (2 + Math.floor(rng() * 3));
  items.push({
    type:'movingPlatform', platformId,
    wx: startX, wy: Math.max(TILE*2, platY),
    startX, endX, speed: 0.8 + rng()*0.5,
    dir: 1, running: false,
    w: TILE*2, h: TILE*0.6,
    catRiding: false,
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DOG DATA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Human definitions â€” 2-3 per level, slow wanderers, gift givers
const HUMAN_OUTFITS = {
  home:     [{top:'#ef9a9a',bottom:'#b0bec5',skin:'#ffcc80'},{top:'#80cbc4',bottom:'#ce93d8',skin:'#ffab91'},{top:'#fff9c4',bottom:'#a5d6a7',skin:'#ffe0b2'}],
  park:     [{top:'#a5d6a7',bottom:'#ffe082',skin:'#ffcc80'},{top:'#81d4fa',bottom:'#ef9a9a',skin:'#ffab91'},{top:'#f8bbd0',bottom:'#b0bec5',skin:'#ffe0b2'}],
  building: [{top:'#b0bec5',bottom:'#546e7a',skin:'#ffcc80'},{top:'#90a4ae',bottom:'#455a64',skin:'#ffab91'},{top:'#cfd8dc',bottom:'#607d8b',skin:'#ffe0b2'}],
  station:  [{top:'#ce93d8',bottom:'#7e57c2',skin:'#ffcc80'},{top:'#80deea',bottom:'#00838f',skin:'#ffab91'},{top:'#ef9a9a',bottom:'#c62828',skin:'#ffe0b2'}],
};
const HUMAN_GIFTS = ['treat','treat','pet','pet','treat','pet']; // shuffled each level

// Treat types: bone, meat, drumstick, cookie
const TREATS = {
  bone:     {emoji:'ğŸ¦´', label:'Bone'},
  meat:     {emoji:'ğŸ¥©', label:'Meat'},
  drumstick:{emoji:'ğŸ–', label:'Drumstick'},
  cookie:   {emoji:'ğŸ¾', label:'Paw Cookie'},
};
// Dog treat preferences and required counts
const DOG_PREFS = {
  mutt:     {fav:'bone',      needs:1, accepts:'any'},
  terrier:  {fav:'bone',      needs:1, accepts:'any'},
  dachshund:{fav:'meat',      needs:2, accepts:'bone'},
  bulldog:  {fav:'drumstick', needs:3, accepts:'meat'},
  greyhound:{fav:'bone',      needs:2, accepts:'cookie'},
};

const DOG_BREEDS = {
  mutt:     {baseSpeed:0.62,chaseRange:110,scale:1.0, bodyColor:'#d7a87a',strokeColor:'#8d6e63'},
  terrier:  {baseSpeed:0.85,chaseRange:130,scale:0.85,bodyColor:'#f5f0e8',strokeColor:'#9e9e9e'},
  dachshund:{baseSpeed:0.68,chaseRange:100,scale:0.85,bodyColor:'#bf8040',strokeColor:'#6d3a00'},
  bulldog:  {baseSpeed:0.42,chaseRange:80, scale:1.35,bodyColor:'#a1887f',strokeColor:'#5d4037'},
  greyhound:{baseSpeed:1.05,chaseRange:150,scale:0.9, bodyColor:'#b0bec5',strokeColor:'#607d8b'},
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BEGIN LEVEL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€ Spawn secrets â”€â”€
function spawnSecrets(def, floorCells, usedC, R, rng) {
  const secrets = [];
  const emojis = def.secretEmojis || ['ğŸ’','â­','ğŸŒŸ'];
  // Place in varied areas of the level
  const zones = [
    floorCells.filter(p => p.r > Math.floor(R*0.15) && p.r < Math.floor(R*0.4)),
    floorCells.filter(p => p.r > Math.floor(R*0.4)  && p.r < Math.floor(R*0.65)),
    floorCells.filter(p => p.r > Math.floor(R*0.65) && p.r < Math.floor(R*0.88)),
  ];
  for (let i = 0; i < 3; i++) {
    const zone = zones[i];
    if (!zone || zone.length === 0) continue;
    let cell;
    for (let a = 0; a < 30; a++) {
      cell = zone[Math.floor(rng() * zone.length)];
      if (cell && !usedC.has(`${cell.r},${cell.c}`)) break;
    }
    if (!cell) continue;
    usedC.add(`${cell.r},${cell.c}`);
    secrets.push({
      emoji: emojis[i % emojis.length],
      wx: cell.c*TILE + TILE/2,
      wy: cell.r*TILE + TILE/2,
      collected: false,
      revealed: false,
      bob: rng()*Math.PI*2,
      pts: 100,
    });
  }
  return secrets;
}

function spawnHumans(def, floorCells, R, rng) {
  const count = 2 + (R > 36 ? 1 : 0); // 2-3 depending on level size
  const humans = [];
  const outfits = HUMAN_OUTFITS[def.theme] || HUMAN_OUTFITS.home;
  const usedCells = new Set();
  // Spread across top 2/3 of level
  const zone = floorCells.filter(p => p.r > 3 && p.r < Math.floor(R * 0.82));
  for (let i = 0; i < count; i++) {
    let cell;
    for (let a = 0; a < 40; a++) {
      cell = zone[Math.floor(rng() * zone.length)];
      if (cell && !usedCells.has(`${cell.r},${cell.c}`)) break;
    }
    if (!cell) continue;
    usedCells.add(`${cell.r},${cell.c}`);
    const gift = rng() > 0.5 ? 'treat' : 'pet';
    const treatTypes = ['bone','meat','drumstick','cookie'];
    humans.push({
      wx: cell.c*TILE + TILE/2,
      wy: cell.r*TILE + TILE/2,
      outfit: outfits[i % outfits.length],
      gift,
      treatType: treatTypes[Math.floor(rng()*treatTypes.length)],
      state: 'wander',      // wander | offering | cooldown
      wanderAngle: rng()*Math.PI*2,
      wanderTimer: 80 + Math.floor(rng()*100),
      offerCooldown: 0,
      giftAnim: 0,
      facingAngle: 0,
      moving: false,
    });
  }
  return humans;
}

function beginLevel(idx) {
  stopPreviewAnim();
  currentLevel = idx;
  const def = LEVEL_DEFS[idx];
  const R = def.rows;
  const rng = seededRng(idx * 7919 + Math.floor(Date.now() / 500) % 10000);
  const grid = generateWorld(idx);

  // Floor cells for spawning
  const floorCells = [];
  for (let r = 2; r < R-2; r++)
    for (let c = 1; c < C-1; c++)
      if (grid[r][c] === 0) floorCells.push({r,c});

  // Key in middle third
  const keyZone = floorCells.filter(p => p.r > R*0.25 && p.r < R*0.75);
  const keyCell = keyZone[Math.floor(rng() * keyZone.length)] || {r:Math.floor(R/2),c:5};

  // Collectibles
  const collectibles = [];
  const usedC = new Set([`${keyCell.r},${keyCell.c}`]);
  const count = 26 + idx*4;
  for (let i = 0; i < count; i++) {
    let cell;
    for (let a = 0; a < 20; a++) {
      cell = floorCells[Math.floor(rng() * floorCells.length)];
      if (cell && !usedC.has(`${cell.r},${cell.c}`) && cell.r < R-3) break;
    }
    if (!cell) continue;
    usedC.add(`${cell.r},${cell.c}`);
    const roll = rng();
    let type,emoji,pts,en;
    if (roll < 0.3)       { type='food';  emoji=def.collectEmojis[0]; pts=8;  en=22; }
    else if (roll < 0.48) { type='food';  emoji=def.collectEmojis[1]||'ğŸŸ'; pts=6; en=18; }
    else if (roll < 0.62) { type='toy';   emoji=def.collectEmojis[2]||'ğŸ§¶'; pts=12; en=0; }
    else if (roll < 0.74) { type='toy';   emoji=def.collectEmojis[3]||'ğŸ¾'; pts=15; en=0; }
    else if (roll < 0.82) { type='mouse'; emoji='ğŸ­'; pts=50; en=10; }
    else if (roll < 0.86) { type='goldenmouse'; emoji='ğŸ­'; pts=200; en=0; }
    else if (roll < 0.93) {
      type='treat'; pts=0; en=0;
    }
    else                  { type='flower'; emoji=['ğŸŒ¸','ğŸŒ¼','ğŸ’'][Math.floor(rng()*3)]; pts=3; en=0; }
    const isMouse = type==='mouse'||type==='goldenmouse';
    const spd = isMouse ? (type==='goldenmouse' ? 1.1:0.7) : 0;
    // Determine treat subtype before push
    let treatType = null;
    if (type==='treat') {
      const tts=['bone','meat','drumstick','cookie'];
      treatType = tts[Math.floor(rng()*tts.length)];
      emoji = TREATS[treatType].emoji;
    }
    collectibles.push({
      type,emoji,pts,en:0,collected:false,
      wx:cell.c*TILE+TILE/2, wy:cell.r*TILE+TILE/2,
      moveSpeed:spd, moveDir:rng()>0.5?1:-1,
      moveMin:(cell.c-1)*TILE+TILE/2, moveMax:(cell.c+1)*TILE+TILE/2,
      bob:rng()*Math.PI*2, golden:type==='goldenmouse',
      treatType,
    });
  }

  // Dogs
  const dogs = [];
  const dogZone = floorCells.filter(p => p.r > 4 && p.r < R-4);
  const dc = DIFF[difficulty];
  for (let i = 0; i < def.dogCount; i++) {
    let cell;
    for (let a = 0; a < 30; a++) {
      cell = dogZone[Math.floor(rng() * dogZone.length)];
      if (cell && cell.r*TILE < R*TILE - TILE*5) break;
    }
    if (!cell) continue;
    const breeds = ['mutt','terrier','dachshund','bulldog','greyhound'];
    const breed = breeds[Math.floor(rng() * breeds.length)];
    const bi = DOG_BREEDS[breed];
    dogs.push({
      breed, ...bi,
      wx:cell.c*TILE+TILE/2, wy:cell.r*TILE+TILE/2,
      state:'wander', wanderTimer:60+Math.floor(rng()*100), wanderAngle:rng()*Math.PI*2,
      treatProgress:0, treatCooldown:0, stunTick:0, fleeTick:0, happyTick:0,
      speed:bi.baseSpeed * dc.dogSpeed * (0.85+rng()*0.3),
    });
  }

  // Interactables
  const interactables = generateInteractables(idx, grid, R, rng);

  const humans = spawnHumans(def, floorCells, R, rng);

  // â”€â”€ Secret collectibles (3 per level, hidden) â”€â”€
  const secrets = spawnSecrets(def, floorCells, usedC, R, rng);

  gs = {
    running:true, time:0, score:0,
    hasKey:false, doorShake:0,
    treats:{bone:0, meat:0, drumstick:0, cookie:0}, maxTreats:8,
    camY:0, grid, R, def,
    cat:{
      wx:CW/2, wy:R*TILE - TILE*1.5,
      facingAngle:Math.PI, moving:false,
      scratchCooldown:0, scratchActive:false,
      onPlatform:null,
      dashFrames:0, dashCooldown:0, dashDx:0, dashDy:0,
      happyFrames:0,
    },
    key:{wx:keyCell.c*TILE+TILE/2, wy:keyCell.r*TILE+TILE/2, collected:false},
    door:{wx:(4.5)*TILE + TILE/2, wy:TILE*1.4},
    collectibles, dogs, interactables, secrets, humans,
    particles:[],
    joystick:{active:false,dx:0,dy:0},
    scratchPressed:false,
  };

  document.getElementById('hud').style.display = 'block';
  document.getElementById('game-canvas-wrap').style.display = 'block';
  document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
  updateDiffBadge();
  if (raf) cancelAnimationFrame(raf);
  if (musicEnabled) startMusic();
  gameLoop();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GAME STATE & LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let gs = null, raf = null;
// Double-tap tracking for dash (PC)
const lastKeyTap = {}; // code -> timestamp of last tap
const DOUBLE_TAP_MS = 200;

// Swipe tracking for dash (mobile)
let swipeStart = null;
const SWIPE_MIN_DIST = 40;
const SWIPE_MAX_MS = 220;

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const keys = {};

window.addEventListener('keydown', e => {
  const wasDown = keys[e.code];
  keys[e.code] = true;
  if ((e.code==='KeyX'||e.code==='KeyZ') && gs?.running) { doScratch(); }
  if (e.code==='Space') e.preventDefault();
  // Double-tap dash detection
  if (!wasDown && gs?.running) {
    const DASH_KEYS = ['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','KeyA','KeyD','KeyW','KeyS'];
    if (DASH_KEYS.includes(e.code)) {
      const now = Date.now();
      if (lastKeyTap[e.code] && now - lastKeyTap[e.code] < DOUBLE_TAP_MS) {
        triggerDash(e.code);
        lastKeyTap[e.code] = 0;
      } else {
        lastKeyTap[e.code] = now;
      }
    }
  }
});
window.addEventListener('keyup', e => keys[e.code] = false);

// Joystick
const jZone = document.getElementById('joystick-zone');
const jKnob = document.getElementById('joystick-knob');
let jTouch = null;
const JR = 52;
jZone.addEventListener('touchstart', e => {
  e.preventDefault(); const t = e.changedTouches[0];
  const rect = jZone.getBoundingClientRect();
  jTouch = {id:t.identifier, cx:rect.left+rect.width/2, cy:rect.top+rect.height/2};
  swipeStart = {x:t.clientX, y:t.clientY, time:Date.now()};
  updateJoystick(t.clientX, t.clientY);
}, {passive:false});
jZone.addEventListener('touchmove', e => {
  e.preventDefault();
  for (const t of e.changedTouches) if (jTouch && t.identifier===jTouch.id) updateJoystick(t.clientX, t.clientY);
}, {passive:false});
['touchend','touchcancel'].forEach(ev => jZone.addEventListener(ev, e => {
  for (const t of e.changedTouches) if (jTouch && t.identifier===jTouch.id) {
    jTouch = null; if (gs) gs.joystick = {active:false,dx:0,dy:0};
    jKnob.style.transform = 'translate(-50%,-50%)';
    // Swipe-to-dash detection
    if (swipeStart && gs?.running) {
      const elapsed = Date.now() - swipeStart.time;
      const sdx = t.clientX - swipeStart.x, sdy = t.clientY - swipeStart.y;
      const sdist = Math.hypot(sdx, sdy);
      if (elapsed < SWIPE_MAX_MS && sdist > SWIPE_MIN_DIST) {
        triggerDash(null, sdx/sdist, sdy/sdist);
      }
    }
    swipeStart = null;
  }
}));
function updateJoystick(cx, cy) {
  if (!jTouch) return;
  let dx=cx-jTouch.cx, dy=cy-jTouch.cy;
  const d = Math.hypot(dx,dy); if (d>JR) {dx=dx/d*JR; dy=dy/d*JR;}
  jKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
  if (gs) gs.joystick = {active:true, dx:dx/JR, dy:dy/JR};
}
function onScratchDown(e) { e.preventDefault(); if (gs?.running) doScratch(); document.getElementById('scratch-btn').classList.add('pressed'); }
function onScratchUp(e)   { e.preventDefault(); document.getElementById('scratch-btn').classList.remove('pressed'); }

function triggerDash(keyCode, nx, ny) {
  if (!gs || gs.cat.dashFrames > 0 || gs.cat.dashCooldown > 0) return;
  let dx = nx||0, dy = ny||0;
  if (keyCode) {
    if (keyCode==='ArrowLeft'||keyCode==='KeyA')  { dx=-1; dy=0; }
    if (keyCode==='ArrowRight'||keyCode==='KeyD') { dx=1;  dy=0; }
    if (keyCode==='ArrowUp'||keyCode==='KeyW')    { dx=0;  dy=-1; }
    if (keyCode==='ArrowDown'||keyCode==='KeyS')  { dx=0;  dy=1; }
  }
  const dl = Math.hypot(dx,dy)||1; dx/=dl; dy/=dl;
  gs.cat.dashDx = dx; gs.cat.dashDy = dy;
  gs.cat.dashFrames = DASH_FRAMES;
  gs.cat.dashCooldown = DASH_COOLDOWN;
  playDash();
  // Spawn trail ghosts
  for (let i=0; i<5; i++) {
    gs.particles.push({
      wx:gs.cat.wx - dx*i*8, wy:gs.cat.wy - dy*i*8,
      vx:0, vy:0, life:0.7-i*0.12, size:24-i*2,
      emoji:null, isDashTrail:true,
      col:CAT_COLORS[catCfg.colorIdx].body,
      alpha:0.55-i*0.1,
    });
  }
}

function doScratch() {
  if (!gs || gs.cat.scratchCooldown > 0) return;
  gs.cat.scratchCooldown = SCRATCH_COOLDOWN;
  gs.cat.scratchActive = true;
  gs.energy = Math.max(0, gs.energy - DIFF[difficulty].scratchCost);
  playMeow();
  checkScratchHits();
}

function offerTreat(dog) {
  const pref = DOG_PREFS[dog.breed] || DOG_PREFS.mutt;
  const dc = DIFF[difficulty];

  // Find best available treat for this dog
  let treatToUse = null;
  const totalTreats = Object.values(gs.treats).reduce((a,b)=>a+b,0);
  if (totalTreats === 0) {
    spawnPop(dog.wx, dog.wy, 'No treats! ğŸ˜¿', '#ef9a9a');
    return;
  }
  // Prefer favourite, then accepted, then any (on easy)
  if (gs.treats[pref.fav] > 0) {
    treatToUse = pref.fav;
  } else if (pref.accepts !== 'any' && gs.treats[pref.accepts] > 0) {
    treatToUse = pref.accepts;
  } else if (dc.treatBonus >= 1) {
    // Easy mode: any treat works
    treatToUse = Object.keys(gs.treats).find(t => gs.treats[t] > 0);
  }

  if (!treatToUse) {
    const wantEmoji = TREATS[pref.fav].emoji;
    spawnPop(dog.wx, dog.wy, `Wants ${wantEmoji}!`, '#ffb74d');
    playWoof();
    return;
  }

  // Consume treat
  gs.treats[treatToUse]--;

  // Is this the preferred treat?
  const isPreferred = treatToUse === pref.fav;
  // How many treats needed (difficulty affects this)
  const baseNeeds = pref.needs + (isPreferred ? 0 : 1) - dc.treatBonus;
  const needed = Math.max(1, baseNeeds);

  dog.treatProgress = (dog.treatProgress || 0) + 1;
  dog.treatCooldown = 60;

  const treatEmoji = TREATS[treatToUse].emoji;
  const remaining = needed - dog.treatProgress;

  playCollect();
  if (dog.treatProgress >= needed) {
    // Dog is befriended!
    dog.state = 'happy';
    dog.happyTick = 0;
    const pts = dog.breed==='bulldog'?80: dog.breed==='greyhound'||dog.breed==='dachshund'?50:30;
    gs.score += pts;
    spawnPop(dog.wx, dog.wy, `ğŸ¾ Friends! +${pts}`, '#f48fb1');
    spawnParticles(dog.wx, dog.wy, 'ğŸ’•');
    spawnParticles(dog.wx, dog.wy, treatEmoji);
    playDoorOpen(); // happy jingle
  } else {
    const hearts = ['','â¤ï¸','â¤ï¸â¤ï¸','â¤ï¸â¤ï¸â¤ï¸'][Math.min(dog.treatProgress,3)];
    spawnPop(dog.wx, dog.wy, `${treatEmoji}${hearts} ${remaining} more!`, '#ce93d8');
    playHit();
  }
}

function checkScratchHits() {
  const cat = gs.cat;
  const fa = cat.facingAngle - Math.PI/2; // actual world direction

  // Offer treat to nearby dog
  for (const dog of gs.dogs) {
    if (dog.state==='gone'||dog.state==='happy') continue;
    const dx=dog.wx-cat.wx, dy=dog.wy-cat.wy;
    const dist = Math.hypot(dx,dy);
    if (dist > SCRATCH_RANGE) continue;
    const angle = Math.atan2(dy,dx);
    const diff = Math.abs(normaliseAngle(angle - fa));
    if (diff > SCRATCH_ARC/2) continue;
    if (dog.treatCooldown > 0) continue;
    offerTreat(dog);
    break; // one dog per scratch
  }


  // Check interactables
  for (const obj of gs.interactables) {
    if (!obj.active || obj.type==='movingPlatform') continue;
    const dx=obj.wx-cat.wx, dy=obj.wy-cat.wy;
    const dist = Math.hypot(dx,dy);
    if (dist > SCRATCH_RANGE) continue;
    const angle = Math.atan2(dy,dx);
    const diff = Math.abs(normaliseAngle(angle - fa));
    if (diff > SCRATCH_ARC/2) continue;
    activateInteractable(obj);
  }
}

function normaliseAngle(a) {
  while (a > Math.PI) a -= Math.PI*2;
  while (a < -Math.PI) a += Math.PI*2;
  return a;
}

function activateInteractable(obj) {
  obj.animTick = 20;
  if (obj.type==='box'||obj.type==='luggage') {
    obj.active = false; obj.broken = true;
    gs.score += obj.pts||8;
    spawnPop(obj.wx, obj.wy, `ğŸ’¥ +${obj.pts||8}!`, '#f48fb1');
    spawnParticles(obj.wx, obj.wy, obj.brokenEmoji||'âœ¨');
    playBreak();
  } else if (obj.type==='plant') {
    obj.active = false; obj.broken = true;
    gs.score += obj.pts||4;
    spawnPop(obj.wx, obj.wy, `ğŸŒ¿ +${obj.pts}!`, '#a5d6a7');
    spawnParticles(obj.wx, obj.wy, 'ğŸŒ¸');
    playBreak();
  } else if (obj.type==='feeder') {
    obj.active = false; obj.broken = true;
    spawnPop(obj.wx, obj.wy, 'ğŸ¦ Fly away!', '#81d4fa');
    spawnParticles(obj.wx, obj.wy, 'ğŸ¦');
    playBreak();
  } else if (obj.type==='lamp') {
    obj.toggled = !obj.toggled; obj.animTick = 15;
    spawnPop(obj.wx, obj.wy, obj.toggled?'ğŸ’¡ On!':'ğŸŒ‘ Off!', '#ffe082');
    playLeverClick();
  } else if (obj.type==='vending') {
    if (!obj.used) {
      obj.used = true; obj.animTick = 30;
      playCollect();
      // Drop food collectible nearby
      gs.collectibles.push({
        type:'food', emoji:'ğŸ¥¤', pts:15, en:35, collected:false,
        wx:obj.wx+20, wy:obj.wy+20,
        moveSpeed:0, moveDir:1, moveMin:obj.wx, moveMax:obj.wx+TILE, bob:0, golden:false,
      });
      spawnPop(obj.wx, obj.wy, 'ğŸ¥¤ Snack!', '#66bb6a');
      spawnParticles(obj.wx, obj.wy, 'ğŸ¥¤');
    } else {
      spawnPop(obj.wx, obj.wy, 'Empty!', '#bdbdbd');
    }
  } else if (obj.type==='lever') {
    obj.activated = !obj.activated; obj.animTick = 20;
    playLeverClick();
    // Find linked platform and toggle it
    const plat = gs.interactables.find(p => p.type==='movingPlatform' && p.platformId===obj.platformId);
    if (plat) {
      plat.running = obj.activated;
      if (plat.running) playPlatformStart();
      spawnPop(obj.wx, obj.wy, obj.activated?'âš™ï¸ Platform ON!':'âš™ï¸ Platform OFF!', '#ce93d8');
    }
  }
}

function gameLoop() {
  if (!gs || !gs.running) return;
  raf = requestAnimationFrame(gameLoop);
  gs.time++;
  update();
  render();
}

function update() {
  const cat = gs.cat;
  const d = DIFF[difficulty];
  const t = gs.time;

  // Movement
  let ix=0, iy=0;
  if (keys['ArrowLeft']||keys['KeyA']) ix -= 1;
  if (keys['ArrowRight']||keys['KeyD']) ix += 1;
  if (keys['ArrowUp']||keys['KeyW']) iy -= 1;
  if (keys['ArrowDown']||keys['KeyS']) iy += 1;
  if (gs.joystick.active) { ix += gs.joystick.dx; iy += gs.joystick.dy; }
  const len = Math.hypot(ix,iy); if (len>1) {ix/=len; iy/=len;}
  cat.moving = len > 0.1;
  if (cat.moving) cat.facingAngle = Math.atan2(iy,ix) + Math.PI/2;

  // Moving platform riding
  cat.onPlatform = null;
  for (const obj of gs.interactables) {
    if (obj.type!=='movingPlatform'||!obj.running) continue;
    // Move platform
    obj.wx += obj.dir * obj.speed;
    if (obj.wx >= obj.endX||obj.wx <= obj.startX) obj.dir *= -1;
    // Check if cat is standing on it
    if (Math.abs(cat.wx-obj.wx)<obj.w/2 && Math.abs(cat.wy-obj.wy)<22) {
      cat.onPlatform = obj;
      cat.wx += obj.dir * obj.speed;
    }
  }

  // Dash movement
  if (cat.dashCooldown > 0) cat.dashCooldown--;
  if (cat.dashFrames > 0) {
    cat.dashFrames--;
    const dashSpd = DASH_SPEED * (cat.happyFrames>0?HAPPY_SPEED_MULT:1);
    cat.wx += cat.dashDx * dashSpd;
    cat.wy += cat.dashDy * dashSpd;
    cat.wx = Math.max(TILE*1.1, Math.min(COLS*TILE-TILE*1.1, cat.wx));
    cat.wy = Math.max(TILE*1.1, Math.min(gs.R*TILE-TILE*1.1, cat.wy));
    if (catHitsWall(cat.wx, cat.wy)) { cat.wx -= cat.dashDx*dashSpd; cat.wy -= cat.dashDy*dashSpd; cat.dashFrames=0; }
    // Spawn trail particle each dash frame
    if (cat.dashFrames % 3 === 0) {
      gs.particles.push({wx:cat.wx, wy:cat.wy, vx:0, vy:0, life:0.5, size:20, emoji:null,
        isDashTrail:true, col:CAT_COLORS[catCfg.colorIdx].body, alpha:0.4});
    }
    resolveCollisions(cat);
  } else {
    // Happy speed boost
    const spd = CAT_SPEED * (cat.happyFrames>0?HAPPY_SPEED_MULT:1);
    // Apply movement one axis at a time â€” stops cleanly, no bounce
    cat.wx += ix * spd;
    cat.wx = Math.max(TILE*1.1, Math.min(COLS*TILE - TILE*1.1, cat.wx));
    if (catHitsWall(cat.wx, cat.wy)) cat.wx -= ix * spd;

    cat.wy += iy * spd;
    cat.wy = Math.max(TILE*1.1, Math.min(gs.R*TILE - TILE*1.1, cat.wy));
    if (catHitsWall(cat.wx, cat.wy)) cat.wy -= iy * spd;

    resolveCollisions(cat);
  }
  // Tick happy
  if (cat.happyFrames > 0) cat.happyFrames--;

  // Scratch cooldown
  if (cat.scratchCooldown > 0) cat.scratchCooldown--;

  // Camera
  const targetCamY = cat.wy - CH * 0.62;
  gs.camY += (targetCamY - gs.camY) * 0.09;
  gs.camY = Math.max(0, Math.min(gs.R * TILE - CH, gs.camY));

  // Key pickup
  if (!gs.key.collected) {
    if (Math.hypot(cat.wx-gs.key.wx, cat.wy-gs.key.wy) < 24) {
      gs.key.collected=true; gs.hasKey=true; gs.score+=50;
      playKeyPickup();
      spawnPop(gs.key.wx, gs.key.wy, 'ğŸ—ï¸ +50!', '#ffd700');
      spawnParticles(gs.key.wx, gs.key.wy, 'âœ¨');
      document.getElementById('key-indicator').textContent='ğŸ—ï¸ âœ“';
    }
  }

  // Door
  const dd = Math.hypot(cat.wx-gs.door.wx, cat.wy-gs.door.wy);
  if (dd < 38) {
    if (gs.hasKey) {
      playDoorOpen(); gs.running=false; showLevelComplete(); return;
    } else if (!gs.doorShake) {
      gs.doorShake=30;
      spawnPop(gs.door.wx, gs.door.wy, 'ğŸ”‘ Need the key!', '#ff7043');
    }
  }
  if (gs.doorShake>0) gs.doorShake--;

  // Collectibles
  for (const c of gs.collectibles) {
    if (c.collected) continue;
    if (c.moveSpeed>0) {
      // Flee from cat when nearby
      const mouseDist = Math.hypot(cat.wx-c.wx, cat.wy-c.wy);
      const fleeing = mouseDist < 100;
      const spd = c.moveSpeed * (fleeing ? 1.3 : 1);

      // Try moving in current direction; also drift vertically for 2D roaming
      if (!c.vy) c.vy = (Math.random()-0.5)*0.8;
      if (fleeing) {
        // Run directly away from cat
        const fx = c.wx-cat.wx, fy = c.wy-cat.wy;
        const fl = Math.hypot(fx,fy)||1;
        c.wx += fx/fl * spd;
        c.wy += fy/fl * spd;
        c.moveDir = fx > 0 ? 1 : -1;
      } else {
        c.wx += c.moveDir * spd;
        c.wy += c.vy;
        // Occasionally change vertical drift
        if (Math.random() < 0.01) c.vy = (Math.random()-0.5)*1.2;
      }

      // Check if mouse is now inside a solid tile â€” teleport to a random floor cell ("mouse hole")
      const mgr = Math.floor(c.wy/TILE), mgc = Math.floor(c.wx/TILE);
      const inWall = mgr<0||mgr>=gs.R||mgc<0||mgc>=COLS ||
                     gs.grid[mgr][mgc]===1||gs.grid[mgr][mgc]===2||gs.grid[mgr][mgc]===3;
      const outOfBounds = c.wx<TILE||c.wx>(COLS-1)*TILE||c.wy<TILE||c.wy>(gs.R-1)*TILE;
      if (inWall||outOfBounds) {
        // Mouse pops out of a random floor tile (mouse hole!)
        const floorCells=[];
        for(let r=2;r<gs.R-2;r++) for(let cc=1;cc<COLS-1;cc++) if(gs.grid[r][cc]===0) floorCells.push({r,cc});
        if(floorCells.length>0){
          const pick=floorCells[Math.floor(Math.random()*floorCells.length)];
          c.wx=pick.cc*TILE+TILE/2; c.wy=pick.r*TILE+TILE/2;
        }
        c.moveDir*=-1; c.vy=(Math.random()-0.5)*0.8;
      }
    }
    if (Math.hypot(cat.wx-c.wx, cat.wy-c.wy)<20) {
      c.collected=true;
      if (c.type==='treat' && c.treatType) {
        const total = Object.values(gs.treats).reduce((a,b)=>a+b,0);
        if (total < gs.maxTreats) {
          gs.treats[c.treatType] = (gs.treats[c.treatType]||0)+1;
          playCollect();
          spawnPop(c.wx, c.wy, `${TREATS[c.treatType].emoji} Got treat!`, '#f48fb1');
          spawnParticles(c.wx, c.wy, TREATS[c.treatType].emoji);
        } else {
          spawnPop(c.wx, c.wy, 'Bag full! ğŸ’', '#bdbdbd');
        }
      } else {
        gs.score+=c.pts;
        playCollect();
        spawnPop(c.wx, c.wy, c.golden?`âœ¨+${c.pts}!`:`+${c.pts}â­`, c.golden?'#ffd700':'#ce93d8');
        spawnParticles(c.wx, c.wy, c.golden?'âœ¨':'ğŸŒ¸');
      }
    }
  }

  updateDogs();
  updateSecrets();
  updateHumans();
  updateHUD();
}

function updateHumans() {
  if (!gs.humans) return;
  const cat = gs.cat;
  for (const h of gs.humans) {
    if (h.offerCooldown > 0) h.offerCooldown--;
    if (h.giftAnim > 0) h.giftAnim--;

    const dist = Math.hypot(cat.wx - h.wx, cat.wy - h.wy);

    if (dist < 48 && h.offerCooldown === 0) {
      // Give gift to cat
      h.state = 'offering';
      h.giftAnim = 40;
      h.offerCooldown = 300; // 5s cooldown before offering again
      h.facingAngle = Math.atan2(cat.wy - h.wy, cat.wx - h.wx) + Math.PI/2;
      h.moving = false;

      if (h.gift === 'treat') {
        const total = Object.values(gs.treats).reduce((a,b)=>a+b,0);
        if (total < gs.maxTreats) {
          gs.treats[h.treatType] = (gs.treats[h.treatType]||0) + 1;
          playCollect();
          spawnPop(h.wx, h.wy, `${TREATS[h.treatType].emoji} Here you go!`, '#f48fb1');
          spawnParticles(h.wx, h.wy, TREATS[h.treatType].emoji);
          spawnParticles(h.wx, h.wy, 'ğŸ’•');
        } else {
          spawnPop(h.wx, h.wy, 'Bag full! ğŸ˜…', '#bdbdbd');
        }
      } else {
        // Pet â€” give happiness boost
        cat.happyFrames = HAPPY_DURATION;
        playPurr();
        spawnPop(h.wx, h.wy, 'ğŸŒˆ Good kitty!', '#ce93d8');
        spawnParticles(h.wx, h.wy, 'ğŸŒˆ');
        spawnParticles(cat.wx, cat.wy, 'âœ¨');
      }
    } else if (dist >= 48) {
      h.state = 'wander';
    }

    if (h.state === 'wander') {
      h.wanderTimer--;
      if (h.wanderTimer <= 0) {
        h.wanderAngle += (Math.random()-0.5)*1.1;
        h.wanderTimer = 80 + Math.floor(Math.random()*120);
      }
      const spd = 0.4;
      const nx = Math.cos(h.wanderAngle)*spd, ny = Math.sin(h.wanderAngle)*spd;
      h.wx += nx; h.wy += ny;
      h.moving = Math.abs(nx)+Math.abs(ny) > 0.05;
      if (h.moving) h.facingAngle = Math.atan2(ny, nx) + Math.PI/2;
      // Clamp to world
      h.wx = Math.max(TILE*1.5, Math.min((COLS-1)*TILE-TILE*1.5, h.wx));
      h.wy = Math.max(TILE*1.5, Math.min((gs.R-1)*TILE-TILE*1.5, h.wy));
      // Bounce off walls
      const hgr = Math.floor(h.wy/TILE), hgc = Math.floor(h.wx/TILE);
      if (hgr>=0&&hgr<gs.R&&hgc>=0&&hgc<COLS && (gs.grid[hgr][hgc]===1||gs.grid[hgr][hgc]===2||gs.grid[hgr][hgc]===3)) {
        h.wx -= nx; h.wy -= ny;
        h.wanderAngle += Math.PI * (0.5 + Math.random()*0.5);
      }
    }
  }
}


function updateSecrets() {
  if (!gs.secrets) return;
  const cat = gs.cat;
  for (const s of gs.secrets) {
    if (s.collected) continue;
    const dist = Math.hypot(cat.wx-s.wx, cat.wy-s.wy);
    if (dist < 30) s.revealed = true;
    if (dist < 20 && s.revealed) {
      s.collected = true;
      gs.score += s.pts;
      playKeyPickup(); // nice chime for secret find
      spawnPop(s.wx, s.wy, `ğŸ” SECRET! +${s.pts}`, '#ffd700');
      spawnParticles(s.wx, s.wy, 'âœ¨');
      spawnParticles(s.wx, s.wy, s.emoji);
    }
  }
}

// Returns true if the cat circle at (wx,wy) overlaps any solid tile
function catHitsWall(wx, wy) {
  const R2 = 13;
  const probes = [[R2,0],[-R2,0],[0,R2],[0,-R2],[R2,R2*.7],[-R2,R2*.7],[R2,-R2*.7],[-R2,-R2*.7]];
  for (const [dx,dy] of probes) {
    const gr = Math.floor((wy+dy)/TILE);
    const gc = Math.floor((wx+dx)/TILE);
    if (gr<0||gr>=gs.R||gc<0||gc>=COLS) return true;
    const t = gs.grid[gr][gc];
    if (t===1||t===2||t===3) return true;
  }
  return false;
}

function resolveCollisions(cat) {
  const R2 = 13;
  // Fine-grain snap: push cat out of any overlapping solid tile
  const probes = [[R2,0],[-R2,0],[0,R2],[0,-R2],[R2,R2*.7],[-R2,R2*.7],[R2,-R2*.7],[-R2,-R2*.7]];
  for (let pass=0; pass<3; pass++) {
    for (const [dx,dy] of probes) {
      const gr = Math.floor((cat.wy+dy)/TILE);
      const gc = Math.floor((cat.wx+dx)/TILE);
      if (gr<0||gr>=gs.R||gc<0||gc>=COLS) continue;
      const tile = gs.grid[gr][gc];
      if (tile!==1&&tile!==2&&tile!==3) continue;
      // Compute overlap and push out along minimum axis
      const tileX = gc*TILE + TILE/2, tileY = gr*TILE + TILE/2;
      const overlapX = (R2 + TILE/2) - Math.abs(cat.wx - tileX);
      const overlapY = (R2 + TILE/2) - Math.abs(cat.wy - tileY);
      if (overlapX > 0 && overlapY > 0) {
        if (overlapX < overlapY) {
          cat.wx += cat.wx < tileX ? -overlapX : overlapX;
        } else {
          cat.wy += cat.wy < tileY ? -overlapY : overlapY;
        }
      }
    }
  }
  // Solid interactables (unbroken boxes/luggage)
  for (const obj of gs.interactables) {
    if (obj.type==='movingPlatform'||!obj.active||obj.broken) continue;
    if (obj.type!=='box'&&obj.type!=='luggage') continue;
    const dx2=cat.wx-obj.wx, dy2=cat.wy-obj.wy;
    const half = TILE*0.55;
    if (Math.abs(dx2)<half && Math.abs(dy2)<half) {
      if (Math.abs(dx2) >= Math.abs(dy2)) cat.wx = obj.wx + (dx2>0?half:-half);
      else cat.wy = obj.wy + (dy2>0?half:-half);
    }
  }
  cat.wx = Math.max(TILE+R2, Math.min((COLS-1)*TILE-R2, cat.wx));
  cat.wy = Math.max(TILE+R2, Math.min((gs.R-1)*TILE-R2, cat.wy));
}

function updateDogs() {
  const cat = gs.cat; const dc = DIFF[difficulty];
  for (const dog of gs.dogs) {
    if (dog.state==='gone') continue;
    if (dog.stunTick>0) { dog.stunTick--; continue; }
    if (dog.treatCooldown>0) dog.treatCooldown--;
    if (dog.state==='fleeing') {
      const fx=dog.wx-cat.wx, fy=dog.wy-cat.wy, fl=Math.hypot(fx,fy)||1;
      dog.wx+=fx/fl*dog.speed*2.0; dog.wy+=fy/fl*dog.speed*2.0;
      dog.fleeTick++;
      if (dog.fleeTick>140||dog.wx<TILE||dog.wx>(COLS-1)*TILE||dog.wy<TILE||dog.wy>(gs.R-1)*TILE) dog.state='gone';
      continue;
    }
    if (dog.state==='happy') continue; // sits still once befriended
    const dist = Math.hypot(cat.wx-dog.wx, cat.wy-dog.wy);
    if (dist < dog.chaseRange*(dc.dogSpeed>1?1.2:1)) {
      const dx=cat.wx-dog.wx, dy=cat.wy-dog.wy, dl=Math.hypot(dx,dy)||1;
      dog.wx+=dx/dl*dog.speed*0.45; dog.wy+=dy/dl*dog.speed*0.45;
    } else {
      dog.wanderTimer--;
      if (dog.wanderTimer<=0) { dog.wanderAngle+=(Math.random()-0.5)*Math.PI; dog.wanderTimer=90+Math.floor(Math.random()*120); }
      dog.wx+=Math.cos(dog.wanderAngle)*dog.speed*0.28;
      dog.wy+=Math.sin(dog.wanderAngle)*dog.speed*0.28;
    }
    dog.wx=Math.max(TILE+10,Math.min((COLS-1)*TILE-10,dog.wx));
    dog.wy=Math.max(TILE+10,Math.min((gs.R-1)*TILE-10,dog.wy));
    // Gentle nudge on contact (no damage)
    if (dist < 28) {
      const nx=(cat.wx-dog.wx)/(dist||1), ny=(cat.wy-dog.wy)/(dist||1);
      cat.wx += nx*1.2; cat.wy += ny*1.2;
    }
  }
  // Tick happy dogs away after celebration
  for (const dog of gs.dogs) {
    if (dog.state==='happy') {
      dog.happyTick = (dog.happyTick||0)+1;
      if (dog.happyTick>180) dog.state='gone';
    }
  }
  gs.dogs = gs.dogs.filter(d=>d.state!=='gone');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RENDER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function render() {
  ctx.clearRect(0,0,CW,CH);
  ctx.save(); ctx.translate(0, -gs.camY);
  const camY=gs.camY, def=gs.def;
  const startR=Math.max(0,Math.floor(camY/TILE)-1);
  const endR=Math.min(gs.R,startR+Math.ceil(CH/TILE)+2);

  // Tiles
  for (let r=startR; r<endR; r++)
    for (let c=0; c<COLS; c++)
      drawTile(c*TILE, r*TILE, gs.grid[r][c], def, r, c);

  // Moving platforms (draw under everything)
  for (const obj of gs.interactables) {
    if (obj.type!=='movingPlatform') continue;
    drawMovingPlatform(obj, def);
  }

  // Door
  drawDoor(gs.door.wx, gs.door.wy, def, gs.hasKey, gs.doorShake, gs.time);

  // Key
  if (!gs.key.collected) drawKey(gs.key.wx, gs.key.wy, gs.time);

  // Collectibles
  for (const c of gs.collectibles) if (!c.collected) drawCollectible(c, gs.time);

  // Interactables
  for (const obj of gs.interactables) {
    if (obj.type!=='movingPlatform') drawInteractable(obj, gs.time);
  }

  // Dogs
  for (const dog of gs.dogs) if (dog.state!=='gone') drawDogTopDown(dog, gs.time, gs.cat);

  // Humans
  if (gs.humans) for (const h of gs.humans) drawHuman(h, gs.time);

  // Secrets (hidden until near)
  if (gs.secrets) for (const s of gs.secrets) if (!s.collected) drawSecret(s, gs.time, gs.cat);

  // Dash trail (behind cat)
  drawDashTrail();

  // Rainbow glow (under cat, above trail)
  if (gs.cat.happyFrames > 0) drawRainbowGlow(gs.cat.wx, gs.cat.wy, gs.time, gs.cat.happyFrames);

  // Cat
  drawCatTopDown(ctx, gs.cat.wx, gs.cat.wy, catCfg, gs.time, gs.cat.facingAngle, gs.cat.moving, gs.cat.scratchCooldown);

  // Particles
  drawParticles();
  ctx.restore();

  // Progress bar (screen-space)
  drawProgress();
}

function drawTile(tx,ty,tile,def,r,c) {
  const alt=(r+c)%2===1;
  if (tile===0) {
    ctx.fillStyle=alt?def.floorTile.alt:def.floorTile.fill;
    ctx.fillRect(tx,ty,TILE,TILE);
    ctx.strokeStyle=def.floorTile.line; ctx.lineWidth=0.4;
    ctx.strokeRect(tx,ty,TILE,TILE);
  } else if (tile===1) {
    ctx.fillStyle=def.wallFill; ctx.fillRect(tx,ty,TILE,TILE);
    ctx.fillStyle='rgba(255,255,255,0.15)'; ctx.fillRect(tx,ty,TILE,3);
    const iconSets={home:['ğŸ›‹ï¸','ğŸ“¦','ğŸª‘','ğŸšª'],park:['ğŸŒ³','ğŸª¨','ğŸŒ¿','ğŸŒ²'],building:['ğŸ–¥ï¸','ğŸ“','ğŸª‘','ğŸ—„ï¸'],station:['ğŸ§³','ğŸ—‘ï¸','ğŸ“¦','ğŸª‘']};
    const icons=iconSets[def.theme]||['â¬œ'];
    ctx.font='18px serif'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.globalAlpha=0.65;
    ctx.fillText(icons[((r*COLS+c)*31)%icons.length],tx+TILE/2,ty+TILE/2); ctx.globalAlpha=1;
  } else if (tile===2) {
    ctx.fillStyle=def.elevFill; ctx.fillRect(tx,ty,TILE,TILE);
    ctx.strokeStyle=def.elevStroke; ctx.lineWidth=2.5; ctx.strokeRect(tx+1,ty+1,TILE-2,TILE-2);
    ctx.fillStyle='rgba(0,0,0,0.1)'; ctx.fillRect(tx+3,ty+TILE-4,TILE-3,4); ctx.fillRect(tx+TILE-4,ty+3,4,TILE-4);
    ctx.fillStyle='rgba(255,255,255,0.28)'; ctx.fillRect(tx,ty,TILE,3); ctx.fillRect(tx,ty,3,TILE);
  } else if (tile===3) {
    const wt=gs.time*0.025;
    const wc={home:'#b0bec5',park:'#81d4fa',building:'#263238',station:'#1a237e'};
    ctx.fillStyle=wc[def.theme]||'#90caf9'; ctx.fillRect(tx,ty,TILE,TILE);
    ctx.globalAlpha=0.25+Math.sin(wt+r+c)*0.1;
    ctx.fillStyle='rgba(255,255,255,0.4)';
    ctx.beginPath(); ctx.ellipse(tx+TILE*0.3,ty+TILE*0.45,7,3.5,wt,0,Math.PI*2); ctx.fill();
    ctx.globalAlpha=1;
  }
}

function drawMovingPlatform(obj, def) {
  const pw=obj.w, ph=obj.h+8;
  ctx.save(); ctx.translate(obj.wx-pw/2, obj.wy-ph/2);
  // Platform shadow
  ctx.fillStyle='rgba(0,0,0,0.12)'; ctx.fillRect(4,6,pw,ph);
  // Platform body
  const pColors={home:'#8d6e63',park:'#388e3c',building:'#455a64',station:'#4527a0'};
  ctx.fillStyle=pColors[def.theme]||'#795548';
  ctx.beginPath(); ctx.roundRect(0,0,pw,ph,6); ctx.fill();
  ctx.fillStyle='rgba(255,255,255,0.25)'; ctx.fillRect(0,0,pw,4);
  // Arrow showing direction
  ctx.fillStyle='rgba(255,255,255,0.5)'; ctx.font='12px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(obj.running?(obj.dir>0?'â†’':'â†'):'â¸', pw/2, ph/2);
  ctx.restore();
}

function drawInteractable(obj, t) {
  if (obj.type==='movingPlatform') return;
  ctx.save(); ctx.translate(obj.wx, obj.wy);
  const pulse = obj.animTick>0 ? (obj.animTick/20)*0.4 : 0;
  ctx.scale(1+pulse*0.3, 1+pulse*0.3);
  if (obj.animTick>0) obj.animTick--;

  if (obj.broken) {
    ctx.globalAlpha=0.5;
    ctx.font='18px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(obj.brokenEmoji||'ğŸ’¨',0,0);
  } else {
    ctx.font='22px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
    if (obj.type==='lamp') {
      ctx.fillText(obj.toggled?'ğŸ’¡':'ğŸ•¯ï¸',0,0);
      if (obj.toggled) {
        ctx.globalAlpha=0.15+Math.sin(t*0.1)*0.05;
        ctx.fillStyle='#ffe082'; ctx.beginPath(); ctx.arc(0,0,30,0,Math.PI*2); ctx.fill();
        ctx.globalAlpha=1;
      }
    } else if (obj.type==='lever') {
      ctx.fillText(obj.activated?'ğŸ”›':'ğŸ”§',0,0);
      // glow if activated
      if (obj.activated) {
        ctx.globalAlpha=0.2+Math.sin(t*0.12)*0.1;
        ctx.fillStyle='#ce93d8'; ctx.beginPath(); ctx.arc(0,0,24,0,Math.PI*2); ctx.fill();
        ctx.globalAlpha=1;
      }
    } else {
      ctx.fillText(obj.emoji,0,0);
    }
    // Interaction hint when nearby (handled below in render-hint pass)
  }
  ctx.restore();
}

function drawInteractableHints() {
  if (!gs) return;
  const cat = gs.cat;
  for (const obj of gs.interactables) {
    if (obj.type==='movingPlatform'||!obj.active||obj.broken) continue;
    const dist=Math.hypot(cat.wx-obj.wx, cat.wy-obj.wy);
    if (dist<70) {
      ctx.save(); ctx.translate(obj.wx, obj.wy-22);
      ctx.globalAlpha=0.7+Math.sin(gs.time*0.15)*0.3;
      ctx.font='bold 10px Nunito,sans-serif'; ctx.fillStyle='white';
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.beginPath(); ctx.roundRect(-16,-8,32,16,6); ctx.fill();
      ctx.fillStyle='white'; ctx.fillText('[!]',0,0);
      ctx.restore();
    }
  }
}

function drawDoor(wx,wy,def,hasKey,shake,t) {
  const x=wx+(shake>0?Math.sin(t*0.8)*(shake/5):0), y=wy;
  const dc={home:{frame:'#795548',panel:'#8d6e63'},park:{frame:'#388e3c',panel:'#4caf50'},building:{frame:'#455a64',panel:'#607d8b'},station:{frame:'#4527a0',panel:'#5e35b1'}};
  const c=dc[def.theme]||dc.home;
  ctx.save(); ctx.translate(x,y);
  ctx.fillStyle=c.frame; ctx.fillRect(-22,-30,44,54);
  ctx.fillStyle=hasKey?'#66bb6a':c.panel; ctx.fillRect(-17,-25,34,47);
  ctx.fillStyle='rgba(255,255,255,0.15)';
  ctx.fillRect(-13,-21,13,18); ctx.fillRect(2,-21,13,18);
  ctx.fillRect(-13,-1,13,18); ctx.fillRect(2,-1,13,18);
  ctx.fillStyle=hasKey?'#ffd700':'rgba(255,255,255,0.6)'; ctx.beginPath(); ctx.arc(10,4,4,0,Math.PI*2); ctx.fill();
  if (hasKey) {
    ctx.save(); ctx.globalAlpha=0.3+Math.sin(t*0.1)*0.12;
    ctx.fillStyle='#a5d6a7'; ctx.beginPath(); ctx.arc(0,0,30,0,Math.PI*2); ctx.fill(); ctx.restore();
  }
  ctx.font='bold 8px Nunito,sans-serif'; ctx.fillStyle=hasKey?'#2e7d32':'rgba(255,255,255,0.85)';
  ctx.textAlign='center'; ctx.textBaseline='bottom';
  ctx.fillText(hasKey?'OPEN':'ğŸ”’ LOCKED',0,-32);
  ctx.fillStyle=c.frame; ctx.beginPath(); ctx.arc(0,-30,22,Math.PI,2*Math.PI); ctx.fill();
  ctx.fillStyle=hasKey?'#a5d6a7':c.panel; ctx.beginPath(); ctx.arc(0,-30,17,Math.PI,2*Math.PI); ctx.fill();
  ctx.restore();
}

function drawKey(wx,wy,t) {
  ctx.save(); ctx.translate(wx,wy);

  // Large outer beacon glow â€” visible from far away
  const outerR = 34 + Math.sin(t*0.07)*6;
  const grd = ctx.createRadialGradient(0,0,4,0,0,outerR);
  grd.addColorStop(0,'rgba(255,220,0,0.45)');
  grd.addColorStop(0.5,'rgba(255,180,0,0.22)');
  grd.addColorStop(1,'rgba(255,160,0,0)');
  ctx.fillStyle=grd;
  ctx.beginPath(); ctx.arc(0,0,outerR,0,Math.PI*2); ctx.fill();

  // Pulsing solid ring
  ctx.strokeStyle=`rgba(255,215,0,${0.55+Math.sin(t*0.12)*0.35})`;
  ctx.lineWidth=2.5;
  ctx.beginPath(); ctx.arc(0,0,22+Math.sin(t*0.09)*4,0,Math.PI*2); ctx.stroke();

  // Second smaller ring, offset phase
  ctx.strokeStyle=`rgba(255,255,150,${0.4+Math.sin(t*0.12+2)*0.3})`;
  ctx.lineWidth=1.5;
  ctx.beginPath(); ctx.arc(0,0,15+Math.sin(t*0.11+1)*3,0,Math.PI*2); ctx.stroke();

  // Key emoji â€” larger, strong shadow
  ctx.shadowColor='#ffd700'; ctx.shadowBlur=18+Math.sin(t*0.1)*8;
  const s = 1.0+Math.sin(t*0.08)*0.1; ctx.scale(s,s);
  ctx.font='28px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText('ğŸ—ï¸',0,1);
  ctx.shadowBlur=0;

  // 4 orbiting sparkles
  ctx.globalAlpha=0.85;
  ctx.font='11px serif';
  for(let i=0;i<4;i++){
    const a = t*0.06 + i*Math.PI/2;
    const r = 28+Math.sin(t*0.1+i)*4;
    ctx.fillText(['âœ¨','â­','âœ¨','ğŸ’›'][i], Math.cos(a)*r, Math.sin(a)*r);
  }
  ctx.restore();
}

function drawCollectible(c,t) {
  const bob = Math.sin(t*0.07+c.bob)*3;
  ctx.save();
  ctx.translate(c.wx, c.wy+bob);

  // Glow ring underneath
  const isFood = c.type==='food';
  const isToy  = c.type==='toy'||c.type==='flower';
  const isMouse= c.type==='mouse'||c.type==='goldenmouse'||c.golden;
  const ringColor = isMouse?'#ffd700': isFood?'#f48fb1':'#ce93d8';
  const ringR = isMouse ? 18 : 14;
  const ringAlpha = 0.35 + Math.sin(t*0.1+c.bob)*0.18;
  ctx.globalAlpha = ringAlpha;
  ctx.fillStyle = ringColor;
  ctx.beginPath(); ctx.arc(0, 0, ringR, 0, Math.PI*2); ctx.fill();
  // Outer pulse ring
  const pulseR = ringR + 4 + Math.sin(t*0.08+c.bob)*4;
  ctx.globalAlpha = ringAlpha*0.4;
  ctx.beginPath(); ctx.arc(0, 0, pulseR, 0, Math.PI*2); ctx.fill();
  ctx.globalAlpha = 1;

  // Drop shadow for depth
  ctx.shadowColor = 'rgba(0,0,0,0.35)';
  ctx.shadowBlur = 6;
  ctx.shadowOffsetY = 3;

  // Golden glow
  if (isMouse) { ctx.shadowColor='#ffd700'; ctx.shadowBlur=14+Math.sin(t*0.1)*6; ctx.shadowOffsetY=0; }

  ctx.font = isMouse?'26px serif':'22px serif';
  ctx.textAlign='center'; ctx.textBaseline='middle';
  if (c.moveSpeed>0&&c.moveDir<0) ctx.scale(-1,1);
  ctx.fillText(c.emoji, 0, 0);
  ctx.restore();
}

function drawDogTopDown(dog,t,cat) {
  const col=dog.bodyColor, stroke=dog.strokeColor, s=dog.scale||1;
  const dx=cat.wx-dog.wx, dy=cat.wy-dog.wy;
  const angle=Math.atan2(dy,dx)+Math.PI/2;
  const dist=Math.hypot(dx,dy);
  const fleeing=dog.state==='fleeing';
  const stunned=dog.stunTick>0;
  const legS=Math.sin(t*0.22)*9*(fleeing?1.8:1);
  ctx.save(); ctx.translate(dog.wx,dog.wy); ctx.rotate(angle); ctx.scale(s,s);
  if (stunned&&Math.floor(t/4)%2===0) ctx.globalAlpha=0.4;
  ctx.fillStyle='rgba(0,0,0,0.07)'; ctx.beginPath(); ctx.ellipse(0,2,16,7,0,0,Math.PI*2); ctx.fill();
  const tw=Math.sin(t*0.18)*20;
  ctx.strokeStyle=col; ctx.lineWidth=5; ctx.lineCap='round';
  ctx.beginPath(); ctx.moveTo(0,12); ctx.quadraticCurveTo(12+tw,22,7+tw,30); ctx.stroke();
  ctx.fillStyle=col; ctx.strokeStyle=stroke; ctx.lineWidth=2;
  if (dog.breed==='bulldog') { ctx.beginPath(); ctx.ellipse(0,2,16,12,0,0,Math.PI*2); ctx.fill(); ctx.stroke(); }
  else if (dog.breed==='dachshund') { ctx.beginPath(); ctx.ellipse(0,2,9,18,0,0,Math.PI*2); ctx.fill(); ctx.stroke(); }
  else { ctx.beginPath(); ctx.ellipse(0,2,13,13,0,0,Math.PI*2); ctx.fill(); ctx.stroke(); }
  ctx.strokeStyle=stroke; ctx.lineWidth=5; ctx.lineCap='round';
  const ld=dog.breed==='bulldog'?14:10;
  [[-ld,-4+legS],[ld,-4-legS],[-ld,8-legS],[ld,8+legS]].forEach(([lx,ly])=>{ctx.beginPath();ctx.moveTo(lx*0.6,ly*0.5);ctx.lineTo(lx,ly);ctx.stroke();});
  ctx.fillStyle=col; ctx.strokeStyle=stroke; ctx.lineWidth=2;
  ctx.beginPath(); ctx.arc(0,-13,dog.breed==='bulldog'?11:8,0,Math.PI*2); ctx.fill(); ctx.stroke();
  ctx.fillStyle=stroke;
  if (dog.breed==='terrier') [[-6,-19],[6,-19]].forEach(([ex,ey])=>{ctx.beginPath();ctx.moveTo(ex,ey);ctx.lineTo(ex-3,ey-7);ctx.lineTo(ex+3,ey-7);ctx.closePath();ctx.fill();});
  else [[-7,-14],[7,-14]].forEach(([ex,ey])=>{ctx.beginPath();ctx.ellipse(ex,ey,4,6,0,0,Math.PI*2);ctx.fill();});
  ctx.fillStyle='#4e342e'; [[-4,-14],[4,-14]].forEach(([ex,ey])=>{ctx.beginPath();ctx.arc(ex,ey,2.5,0,Math.PI*2);ctx.fill();});
  ctx.fillStyle='white'; [[-4,-14],[4,-14]].forEach(([ex,ey])=>{ctx.beginPath();ctx.arc(ex-0.5,ey-0.5,1,0,Math.PI*2);ctx.fill();});
  ctx.fillStyle='#5d4037'; ctx.beginPath(); ctx.arc(0,-10,2.5,0,Math.PI*2); ctx.fill();
  if (dist<dog.chaseRange||fleeing) { ctx.fillStyle='#ef9a9a'; ctx.beginPath(); ctx.ellipse(0,-6,3,5,0,0,Math.PI*2); ctx.fill(); }
  if (!fleeing&&!stunned&&dist<dog.chaseRange) { ctx.globalAlpha=0.9; ctx.font='12px serif'; ctx.textAlign='center'; ctx.fillText('â—',0,-28/s); }
  if (stunned) { ctx.globalAlpha=0.9; ctx.font='12px serif'; ctx.textAlign='center'; ctx.fillText('ğŸ’«',Math.sin(t*0.3)*5,-30/s); }
  if (dog.breed==='bulldog'&&dog.hitsLeft>0&&!fleeing) { ctx.globalAlpha=0.9; ctx.font='10px serif'; for(let h=0;h<dog.hitsLeft;h++) ctx.fillText('â¤ï¸',-5+h*12,-34/s); }
  ctx.restore();
}



function drawSecret(s, t, cat) {
  const dist = Math.hypot(cat.wx-s.wx, cat.wy-s.wy);
  const nearbyFactor = Math.max(0, 1-(dist/80)); // shimmer builds as you approach

  ctx.save();
  ctx.translate(s.wx, s.wy);

  if (s.revealed) {
    // Fully revealed â€” pulse and glow
    const pulse = 0.85 + Math.sin(t*0.1+s.bob)*0.18;
    ctx.save(); ctx.scale(pulse, pulse);
    ctx.shadowColor='#ffd700'; ctx.shadowBlur=14+Math.sin(t*0.1)*6;
    ctx.globalAlpha=1;
    ctx.font='22px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(s.emoji, 0, 0);
    ctx.restore();
    // Gold ring
    ctx.globalAlpha=0.4+Math.sin(t*0.12)*0.2;
    ctx.strokeStyle='#ffd700'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc(0,0,18,0,Math.PI*2); ctx.stroke();
    ctx.globalAlpha=1;
    // "SECRET" label
    ctx.font='bold 8px Nunito,sans-serif';
    ctx.fillStyle='#ffd700'; ctx.textAlign='center'; ctx.textBaseline='bottom';
    ctx.fillText('SECRET',0,-22);
  } else if (nearbyFactor > 0) {
    // Subtle shimmer hint when nearby â€” just barely visible
    ctx.globalAlpha = nearbyFactor * 0.35;
    ctx.fillStyle='#ffd700';
    // Sparkle particles at item location
    ctx.font='10px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
    const sparkAngle = t*0.08 + s.bob;
    ctx.fillText('âœ¨', Math.cos(sparkAngle)*10, Math.sin(sparkAngle)*10);
    ctx.fillText('âœ¨', Math.cos(sparkAngle+Math.PI)*8, Math.sin(sparkAngle+Math.PI)*8);
    ctx.globalAlpha=1;
  }
  ctx.restore();
}

function drawHuman(h, t) {
  const o = h.outfit;
  const bob = h.moving ? Math.sin(t*0.22)*1.5 : 0;
  const isOffering = h.state==='offering';
  const armWave = isOffering ? Math.sin(t*0.25)*0.4 : Math.sin(t*0.1)*0.15;

  ctx.save();
  ctx.translate(h.wx, h.wy + bob);
  ctx.rotate(h.facingAngle);

  // Shadow
  ctx.fillStyle='rgba(0,0,0,0.08)';
  ctx.beginPath(); ctx.ellipse(0,6,14,5,0,0,Math.PI*2); ctx.fill();

  // Legs
  const legSwing = h.moving ? Math.sin(t*0.2)*8 : 0;
  ctx.fillStyle=o.bottom; ctx.strokeStyle='rgba(0,0,0,0.15)'; ctx.lineWidth=1;
  [[-5,14+legSwing],[5,14-legSwing]].forEach(([lx,ly])=>{
    ctx.beginPath(); ctx.roundRect(lx-4,8,8,ly-8,3); ctx.fill(); ctx.stroke();
  });
  // Feet
  ctx.fillStyle='#5d4037';
  [[-5,14+legSwing],[5,14-legSwing]].forEach(([lx,ly])=>{
    ctx.beginPath(); ctx.ellipse(lx,ly+2,5,3,0,0,Math.PI*2); ctx.fill();
  });

  // Body
  ctx.fillStyle=o.top; ctx.strokeStyle='rgba(0,0,0,0.1)'; ctx.lineWidth=1.5;
  ctx.beginPath(); ctx.roundRect(-9,-4,18,13,4); ctx.fill(); ctx.stroke();

  // Arms
  ctx.fillStyle=o.top; ctx.strokeStyle='rgba(0,0,0,0.1)'; ctx.lineWidth=1;
  const leftArm = h.moving ? armWave : armWave;
  const rightArm = -leftArm;
  // Left arm
  ctx.save(); ctx.translate(-9,0); ctx.rotate(leftArm);
  ctx.beginPath(); ctx.roundRect(-4,0,8,10,3); ctx.fill(); ctx.stroke(); ctx.restore();
  // Right arm â€” if offering, extends forward holding gift
  ctx.save(); ctx.translate(9,0); ctx.rotate(isOffering ? -0.6 : rightArm);
  ctx.beginPath(); ctx.roundRect(-4,0,8,10,3); ctx.fill(); ctx.stroke();
  if (isOffering) {
    // Hand holding gift
    ctx.fillStyle=o.skin; ctx.beginPath(); ctx.arc(0,12,4,0,Math.PI*2); ctx.fill();
    ctx.font='11px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(h.gift==='treat'?TREATS[h.treatType].emoji:'ğŸ¤š',0,12);
  }
  ctx.restore();

  // Head
  ctx.fillStyle=o.skin; ctx.strokeStyle='rgba(0,0,0,0.12)'; ctx.lineWidth=1.5;
  ctx.beginPath(); ctx.arc(0,-12,10,0,Math.PI*2); ctx.fill(); ctx.stroke();

  // Hair â€” simple arc
  const hairColors=['#5d4037','#212121','#ffd54f','#ef9a9a','#b0bec5'];
  ctx.fillStyle=hairColors[Math.abs(h.wx*3|0)%hairColors.length];
  ctx.beginPath(); ctx.arc(0,-14,10,Math.PI,2*Math.PI); ctx.fill();

  // Face
  ctx.fillStyle='#3e2723';
  ctx.beginPath(); ctx.arc(-3,-12,1.8,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(3,-12,1.8,0,Math.PI*2); ctx.fill();
  // Smile when offering
  ctx.strokeStyle='#3e2723'; ctx.lineWidth=1.5; ctx.lineCap='round';
  ctx.beginPath();
  if (isOffering) {
    ctx.arc(0,-10,4,0.2,Math.PI-0.2); // big smile
  } else {
    ctx.arc(0,-10,3,0.3,Math.PI-0.3); // small smile
  }
  ctx.stroke();

  // Gift bubble when nearby but not yet offering
  if (h.offerCooldown === 0 && h.state!=='offering') {
    const giftEmoji = h.gift==='treat'?TREATS[h.treatType].emoji:'ğŸ¤—';
    ctx.save();
    ctx.globalAlpha=0.7+Math.sin(t*0.12)*0.3;
    ctx.font='14px serif'; ctx.textAlign='center';
    // Small floating icon hint
    ctx.fillText(giftEmoji, 2, -26-Math.sin(t*0.08)*3);
    ctx.restore();
  }

  // Offering animation â€” sparkle burst
  if (h.giftAnim > 0) {
    const prog = h.giftAnim/40;
    ctx.save(); ctx.globalAlpha=prog;
    ctx.font='14px serif'; ctx.textAlign='center';
    ctx.fillText('âœ¨', -15*prog, -20-10*prog);
    ctx.fillText('âœ¨',  15*prog, -20-8*prog);
    ctx.restore();
  }

  ctx.restore();
}

function drawParticles() {
  gs.particles=gs.particles.filter(p=>p.life>0);
  for (const p of gs.particles) {
    if (p.isDashTrail) { p.life-=0.07; continue; } // drawn by drawDashTrail
    ctx.save(); ctx.globalAlpha=p.life;
    ctx.font=p.size+'px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(p.emoji,p.wx,p.wy); ctx.restore();
    p.wx+=p.vx; p.wy+=p.vy; p.vy-=0.08; p.life-=0.022;
  }
}

function drawDashTrail() {
  for (const p of gs.particles) {
    if (!p.isDashTrail) continue;
    ctx.save();
    ctx.globalAlpha = p.life * 0.7;
    ctx.fillStyle = p.col || '#f8bbd0';
    ctx.beginPath(); ctx.arc(p.wx, p.wy, p.size/2, 0, Math.PI*2); ctx.fill();
    ctx.restore();
    p.life -= 0.07;
  }
}

function drawRainbowGlow(wx, wy, t, frames) {
  const intensity = Math.min(1, frames / 60); // fade in/out
  const ringCount = 3;
  for (let i = 0; i < ringCount; i++) {
    const hue = ((t * 3 + i * (360/ringCount)) % 360);
    const r = 22 + i*5 + Math.sin(t*0.15+i)*3;
    ctx.save();
    ctx.globalAlpha = intensity * (0.35 - i*0.08) * (0.7 + Math.sin(t*0.1+i)*0.3);
    ctx.strokeStyle = `hsl(${hue},100%,65%)`;
    ctx.lineWidth = 4 - i;
    ctx.beginPath(); ctx.arc(wx, wy, r, 0, Math.PI*2); ctx.stroke();
    ctx.restore();
  }
  // Sparkles orbiting
  if (frames > 30) {
    for (let i = 0; i < 4; i++) {
      const a = t*0.08 + i*Math.PI/2;
      const hue = ((t*4 + i*90) % 360);
      ctx.save();
      ctx.globalAlpha = intensity * 0.8;
      ctx.fillStyle = `hsl(${hue},100%,70%)`;
      ctx.beginPath();
      ctx.arc(wx + Math.cos(a)*28, wy + Math.sin(a)*28, 3, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  }
}

function drawProgress() {
  const pct=Math.max(0,1-(gs.cat.wy/(gs.R*TILE)));
  const bx=CW-13,by=40,bh=CH-80;
  ctx.fillStyle='rgba(255,255,255,0.2)'; ctx.beginPath(); ctx.roundRect(bx-3,by,6,bh,3); ctx.fill();
  const fh=bh*pct;
  ctx.fillStyle='rgba(244,143,177,0.65)'; ctx.beginPath(); ctx.roundRect(bx-3,by+bh-fh,6,fh,3); ctx.fill();
  ctx.fillStyle='#f48fb1'; ctx.beginPath(); ctx.arc(bx,by+bh-fh,5,0,Math.PI*2); ctx.fill();
  ctx.font='12px serif'; ctx.textAlign='center'; ctx.fillText('ğŸ',bx,by+4);
  // Also draw interactable hints in world space
  ctx.save(); ctx.translate(0,-gs.camY); drawInteractableHints(); ctx.restore();
}

function spawnParticles(wx,wy,emoji='âœ¨') {
  const emojis=[emoji,'âœ¨','ğŸŒ¸','â­'];
  for (let i=0;i<5;i++) gs.particles.push({
    wx,wy,vx:(Math.random()-0.5)*3.5,vy:-2-Math.random()*2.5,
    life:1,size:12+Math.random()*6,emoji:emojis[Math.floor(Math.random()*emojis.length)]
  });
}

function spawnPop(wx,wy,text,color) {
  const layer=document.getElementById('popup-layer');
  const screenX=wx, screenY=wy-gs.camY-28;
  if (screenY<-20||screenY>CH+20) return;
  const el=document.createElement('div'); el.className='pop';
  el.style.left=Math.max(4,Math.min(CW-90,screenX-30))+'px';
  el.style.top=Math.max(4,screenY)+'px';
  el.style.color=color||'#5d4037';
  el.textContent=text; layer.appendChild(el);
  setTimeout(()=>el.remove(),1100);
}

function updateHUD() {
  document.getElementById('score-val').textContent=gs.score;
  document.getElementById('key-indicator').textContent=gs.hasKey?'ğŸ—ï¸ âœ“':'ğŸ—ï¸ âœ—';
  // Treat inventory
  const parts = Object.entries(gs.treats)
    .filter(([,v])=>v>0)
    .map(([k,v])=>`${TREATS[k].emoji}Ã—${v}`)
    .join(' ');
  document.getElementById('treat-display').textContent = parts || 'ğŸ’ Empty';
  // Happy indicator
  const happyEl = document.getElementById('happy-hud');
  if (gs.cat.happyFrames > 0) {
    happyEl.style.display='';
    const secs = Math.ceil(gs.cat.happyFrames/60);
    document.getElementById('happy-display').textContent=`ğŸŒˆ ${secs}s`;
  } else {
    happyEl.style.display='none';
  }
}

function updateDiffBadge() {
  const b=document.getElementById('diff-badge-hud'); b.className=difficulty;
  b.textContent={easy:'ğŸŒ¸',normal:'â­',hard:'ğŸ”¥',paws:'ğŸ¾'}[difficulty];
}

function showGameOver() {
  stopMusic();
  document.getElementById('go-name').textContent=`${catName} got lostâ€¦ ğŸ˜¿`;
  document.getElementById('go-score').textContent=`â­ Score: ${gs.score}`;
  document.getElementById('hud').style.display='none';
  document.getElementById('game-canvas-wrap').style.display='none';
  showScreen('gameover-screen');
}

function showLevelComplete() {
  stopMusic();
  if (currentLevel+1>unlockedLevels) unlockedLevels=currentLevel+1;
  const def=LEVEL_DEFS[currentLevel];
  document.getElementById('lc-emoji').textContent=def.icon;
  document.getElementById('lc-title').textContent=currentLevel===3?'ğŸŠ All Done!':'Level Complete!';
  document.getElementById('lc-desc').textContent=def.completeTxt;
  document.getElementById('lc-score').textContent=`â­ Score: ${gs.score}`;
  document.getElementById('lc-next-btn').style.display=currentLevel<3?'':'none';
  document.getElementById('hud').style.display='none';
  document.getElementById('game-canvas-wrap').style.display='none';
  showScreen('levelcomplete-screen');
  updateLevelCards();
}

// Init
startPreviewAnim();
renderCatPreview('titleCatCanvas',130,130);
</script>
</body>
</html>
