<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Neko Day ğŸ±</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Nunito:wght@400;700;900&family=Fredoka+One&display=swap');
:root{
  --pink:#f48fb1;--lavender:#ce93d8;--peach:#ffcc80;--mint:#b2dfdb;
  --text:#5d4037;--shadow:rgba(180,100,140,0.22);
  --W:420px;--H:700px;
}
*{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent;}
html,body{
  width:100%;height:100%;height:100dvh;
  font-family:'Nunito',sans-serif;
  background:#1a0a2e;
  display:flex;align-items:center;justify-content:center;
  overflow:hidden;user-select:none;overscroll-behavior:none;
}
#app{
  width:min(420px,100vw);
  height:min(700px,100dvh);
  position:relative;overflow:hidden;
  background:#fff9f0;
  border-radius:clamp(0px,3vw,24px);
  box-shadow:0 0 80px rgba(244,143,177,0.4),0 0 0 1px rgba(255,255,255,0.1);
}

/* â”€â”€ SCREENS â”€â”€ */
.screen{
  position:absolute;inset:0;
  display:flex;flex-direction:column;
  align-items:center;justify-content:center;
  gap:14px;padding:20px 18px;
  overflow-y:auto;
  transition:opacity 0.3s;
}
.screen.hidden{display:none;}

/* â”€â”€ TITLE â”€â”€ */
#title-screen{
  background:linear-gradient(170deg,#fde8f5 0%,#f3e5f5 40%,#e8f5e9 100%);
}
.title-logo{
  font-family:'Fredoka One',cursive;
  font-size:52px;color:var(--text);
  text-shadow:3px 3px 0 var(--pink),6px 6px 0 rgba(244,143,177,.25);
  letter-spacing:2px;text-align:center;
  animation:titleBounce 2.2s ease-in-out infinite;
}
.title-sub{font-size:14px;color:#a0887a;font-weight:700;text-align:center;line-height:1.7;}
#title-cat-preview{
  width:140px;height:140px;
  border-radius:50%;
  background:white;
  box-shadow:0 8px 32px var(--shadow),0 0 0 4px rgba(244,143,177,0.2);
  display:flex;align-items:center;justify-content:center;
  overflow:hidden;
}
#title-cat-preview canvas{display:block;}

/* â”€â”€ CUSTOM â”€â”€ */
#custom-screen{
  background:linear-gradient(170deg,#e8f5e9 0%,#f3e5f5 60%,#fde8f5 100%);
  justify-content:flex-start;padding-top:16px;
  gap:10px;
}
#custom-screen h2{
  font-family:'Fredoka One',cursive;
  font-size:28px;color:var(--text);
  text-shadow:2px 2px 0 var(--pink);
  margin-top:4px;
}
.custom-section{width:100%;max-width:360px;}
.custom-label{
  font-size:12px;font-weight:900;color:#b06090;
  text-transform:uppercase;letter-spacing:1px;
  margin-bottom:6px;display:block;
}
.swatch-row{display:flex;gap:7px;flex-wrap:wrap;}
.swatch{
  width:36px;height:36px;border-radius:50%;
  border:3px solid transparent;cursor:pointer;
  transition:transform .12s,border-color .12s;
  touch-action:manipulation;
  box-shadow:0 2px 6px rgba(0,0,0,.15);
}
.swatch.selected{border-color:#5d4037;transform:scale(1.2);}
.swatch:active{transform:scale(0.9);}
.option-row{display:flex;gap:7px;flex-wrap:wrap;}
.opt-btn{
  padding:6px 12px;border-radius:20px;
  border:2.5px solid transparent;
  background:white;cursor:pointer;
  font-family:'Nunito',sans-serif;font-size:12px;font-weight:900;
  color:var(--text);box-shadow:0 2px 8px var(--shadow);
  transition:all .12s;touch-action:manipulation;
}
.opt-btn.selected{border-color:var(--pink);background:#fce4ec;color:#ad1457;}
.opt-btn:active{transform:scale(0.93);}

/* cat preview card */
#custom-preview-wrap{
  display:flex;flex-direction:column;align-items:center;gap:6px;
}
#preview-canvas-wrap{
  width:100px;height:100px;border-radius:50%;
  background:white;box-shadow:0 4px 18px var(--shadow),0 0 0 3px rgba(244,143,177,0.3);
  display:flex;align-items:center;justify-content:center;overflow:hidden;
}
#cat-name-input{
  padding:8px 18px;border-radius:30px;
  border:2.5px solid #f8bbd0;
  font-family:'Nunito',sans-serif;font-size:15px;font-weight:700;
  color:var(--text);background:white;text-align:center;outline:none;
  width:180px;box-shadow:0 2px 8px var(--shadow);
}
#cat-name-input:focus{border-color:var(--pink);}


/* â”€â”€ LEVEL SELECT â”€â”€ */
#level-screen{
  background:linear-gradient(170deg,#fff9f0 0%,#fce4ec 60%,#f3e5f5 100%);
}
#level-screen h2{
  font-family:'Fredoka One',cursive;font-size:28px;
  color:var(--text);text-shadow:2px 2px 0 var(--peach);
}
.level-list{display:flex;flex-direction:column;gap:10px;width:100%;max-width:340px;}
.level-card{
  background:white;border-radius:18px;padding:14px 18px;
  border:3px solid transparent;cursor:pointer;
  display:flex;align-items:center;gap:14px;
  box-shadow:0 4px 14px var(--shadow);
  transition:all .15s;touch-action:manipulation;
}
.level-card.unlocked{border-color:var(--pink);}
.level-card.locked{opacity:.5;cursor:not-allowed;filter:grayscale(.5);}
.level-card:active:not(.locked){transform:scale(0.97);}
.level-icon{font-size:32px;flex-shrink:0;}
.level-card-text{}
.level-card-name{font-size:15px;font-weight:900;color:var(--text);}
.level-card-desc{font-size:11px;font-weight:700;color:#a0887a;margin-top:2px;}

/* â”€â”€ GAME OVER / COMPLETE â”€â”€ */
#gameover-screen{background:rgba(253,232,245,.97);}
#levelcomplete-screen{background:rgba(240,255,244,.97);}
#gameover-screen h2,#levelcomplete-screen h2{
  font-family:'Fredoka One',cursive;font-size:36px;
  color:var(--text);text-align:center;
}
.result-emoji{font-size:72px;animation:titleBounce 1.5s ease-in-out infinite;}
.result-score{font-size:22px;font-weight:900;color:var(--text);}

/* â”€â”€ BUTTONS â”€â”€ */
.btn{
  background:linear-gradient(135deg,var(--pink),var(--lavender));
  color:white;border:none;
  padding:12px 36px;border-radius:50px;
  font-family:'Fredoka One',cursive;font-size:18px;
  cursor:pointer;
  box-shadow:0 5px 0 #b06090,0 8px 18px rgba(200,100,150,.3);
  transition:transform .1s,box-shadow .1s;touch-action:manipulation;
}
.btn:active{transform:translateY(3px);box-shadow:0 2px 0 #b06090;}
.btn-green{background:linear-gradient(135deg,#66bb6a,#26a69a);box-shadow:0 5px 0 #2e7d32,0 8px 16px rgba(50,150,80,.3);}
.btn-green:active{box-shadow:0 2px 0 #2e7d32;}
.btn-sm{font-size:14px;padding:9px 24px;}
.btn-grey{background:linear-gradient(135deg,#ce93d8,#b0bec5);box-shadow:0 5px 0 #7b6080;}
.btn-grey:active{box-shadow:0 2px 0 #7b6080;}
.btn-row{display:flex;gap:10px;flex-wrap:wrap;justify-content:center;}

/* â”€â”€ HUD â”€â”€ */
#hud{
  position:absolute;top:0;left:0;right:0;
  display:none;
  padding:6px 10px 4px;
  background:linear-gradient(180deg,rgba(255,249,240,0.95),rgba(255,249,240,0));
  z-index:20;pointer-events:none;
}
.hud-row{display:flex;align-items:center;gap:6px;}
.hud-pill{
  background:rgba(255,255,255,0.88);
  backdrop-filter:blur(4px);
  border-radius:20px;padding:3px 10px;
  display:flex;align-items:center;gap:5px;
  box-shadow:0 2px 8px var(--shadow);
  font-size:11px;font-weight:700;color:var(--text);
}
#key-indicator{font-size:14px;}

/* â”€â”€ GAME CANVAS â”€â”€ */
#game-canvas-wrap{
  position:absolute;inset:0;
  display:none;
}
#gameCanvas{display:block;width:100%;height:100%;}

/* â”€â”€ TOUCH CONTROLS â”€â”€ */
#touch-controls{
  position:absolute;bottom:0;left:0;right:0;
  display:none;
  padding:12px 16px 20px;
  justify-content:space-between;align-items:flex-end;
  pointer-events:none;
  z-index:25;
}
#joystick-zone{
  width:110px;height:110px;
  border-radius:50%;
  background:rgba(255,255,255,0.25);
  backdrop-filter:blur(6px);
  border:2px solid rgba(255,255,255,0.4);
  position:relative;pointer-events:auto;
  touch-action:none;
}
#joystick-knob{
  position:absolute;
  width:46px;height:46px;border-radius:50%;
  background:rgba(255,255,255,0.75);
  border:2.5px solid rgba(244,143,177,0.8);
  box-shadow:0 3px 10px rgba(180,100,140,.3);
  top:50%;left:50%;
  transform:translate(-50%,-50%);
  transition:transform 0.05s;
  pointer-events:none;
}
.action-btns{display:flex;flex-direction:column;gap:10px;align-items:flex-end;pointer-events:auto;}
.touch-action-btn{
  width:64px;height:64px;border-radius:50%;
  background:rgba(255,255,255,0.65);
  backdrop-filter:blur(6px);
  border:2.5px solid rgba(244,143,177,0.6);
  box-shadow:0 3px 12px rgba(180,100,140,.25);
  display:flex;align-items:center;justify-content:center;
  font-size:22px;cursor:pointer;touch-action:manipulation;
  user-select:none;-webkit-user-select:none;
  transition:transform .08s,background .1s;
  pointer-events:auto;
}
.touch-action-btn.pressed{background:rgba(244,143,177,0.5);transform:scale(0.88);}
#scratch-btn{
  background:linear-gradient(135deg,rgba(244,143,177,0.7),rgba(206,147,216,0.7));
  border-color:rgba(244,143,177,0.9);width:72px;height:72px;font-size:26px;
}

/* â”€â”€ POPUP SCORES â”€â”€ */
.pop{
  position:absolute;pointer-events:none;z-index:30;
  font-size:16px;font-weight:900;
  font-family:'Nunito',sans-serif;color:var(--text);
  animation:popUp 1.1s ease-out forwards;
  white-space:nowrap;
}
@keyframes popUp{0%{transform:translateY(0) scale(.7);opacity:1;}100%{transform:translateY(-60px) scale(1.1);opacity:0;}}
@keyframes titleBounce{0%,100%{transform:translateY(0)}50%{transform:translateY(-8px)}}
@keyframes doorShake{0%,100%{transform:translateX(0)}20%{transform:translateX(-5px)}40%{transform:translateX(5px)}60%{transform:translateX(-4px)}80%{transform:translateX(4px)}}
@keyframes keyPulse{0%,100%{filter:drop-shadow(0 0 4px #ffd700)}50%{filter:drop-shadow(0 0 12px #ffd700) drop-shadow(0 0 4px #ff8c00)}}

@media(pointer:coarse){#touch-controls{display:flex;}}
@media(min-width:421px){
  #app{box-shadow:0 0 100px rgba(244,143,177,0.5),0 0 0 1px rgba(255,255,255,0.08);}
}
</style>
</head>
<body>
<div id="app">

<!-- TITLE -->
<div class="screen" id="title-screen">
  <div id="title-cat-preview"><canvas id="titleCatCanvas" width="130" height="130"></canvas></div>
  <div class="title-logo">Neko Day âœ¨</div>
  <div class="title-sub">A cozy top-down cat adventure!<br>Find the ğŸ—ï¸ key Â· meet friendly cats Â· explore every corner!</div>
      <div style="position:absolute;top:14px;right:14px;display:flex;gap:8px;"><button class="btn btn-grey" style="padding:6px 14px;font-size:13px;" onclick="toggleMusic()" title="Toggle music">ğŸµ Music</button></div>
  <button class="btn" onclick="showScreen('custom-screen')">Customize Your Cat ğŸ±</button>
  <button class="btn btn-grey btn-sm" style="margin-top:-4px" onclick="quickPlay()">Quick Play â†’</button>
</div>

<!-- CUSTOMISE -->
<div class="screen hidden" id="custom-screen">
  <h2>Your Cat âœ¨</h2>
  <div id="custom-preview-wrap">
    <div id="preview-canvas-wrap"><canvas id="previewCanvas" width="90" height="90"></canvas></div>
    <input class="name-box" id="cat-name-input" placeholder="Mochi" maxlength="14" value="Mochi" oninput="updatePreview()"/>
  </div>

  <div class="custom-section">
    <span class="custom-label">ğŸ¨ Fur Color</span>
    <div class="swatch-row" id="color-swatches">
      <div class="swatch selected" data-idx="0" style="background:#fff9f0;border:2px solid #ddd" onclick="setCatProp('colorIdx',0)"></div>
      <div class="swatch" data-idx="1" style="background:#ffb74d" onclick="setCatProp('colorIdx',1)"></div>
      <div class="swatch" data-idx="2" style="background:#9e9e9e" onclick="setCatProp('colorIdx',2)"></div>
      <div class="swatch" data-idx="3" style="background:#424242" onclick="setCatProp('colorIdx',3)"></div>
      <div class="swatch" data-idx="4" style="background:#ffcc80" onclick="setCatProp('colorIdx',4)"></div>
      <div class="swatch" data-idx="5" style="background:#a1887f" onclick="setCatProp('colorIdx',5)"></div>
      <div class="swatch" data-idx="6" style="background:#f8bbd0" onclick="setCatProp('colorIdx',6)"></div>
    </div>
  </div>

  <div class="custom-section">
    <span class="custom-label">ğŸ¾ Pattern</span>
    <div class="option-row" id="pattern-opts">
      <div class="opt-btn selected" data-val="solid" onclick="setCatProp('pattern','solid')">Solid</div>
      <div class="opt-btn" data-val="tabby" onclick="setCatProp('pattern','tabby')">Tabby</div>
      <div class="opt-btn" data-val="spots" onclick="setCatProp('pattern','spots')">Spotty</div>
      <div class="opt-btn" data-val="tuxedo" onclick="setCatProp('pattern','tuxedo')">Tuxedo</div>
      <div class="opt-btn" data-val="calico" onclick="setCatProp('pattern','calico')">Calico</div>
    </div>
  </div>

  <div class="custom-section">
    <span class="custom-label">ğŸ‘ï¸ Eye Color</span>
    <div class="swatch-row" id="eye-swatches">
      <div class="swatch selected" data-idx="0" style="background:#4caf50" onclick="setCatProp('eyeIdx',0)"></div>
      <div class="swatch" data-idx="1" style="background:#2196f3" onclick="setCatProp('eyeIdx',1)"></div>
      <div class="swatch" data-idx="2" style="background:#ff9800" onclick="setCatProp('eyeIdx',2)"></div>
      <div class="swatch" data-idx="3" style="background:#9c27b0" onclick="setCatProp('eyeIdx',3)"></div>
      <div class="swatch" data-idx="4" style="background:linear-gradient(135deg,#2196f3,#ff9800)" onclick="setCatProp('eyeIdx',4)"></div>
    </div>
  </div>

  <div class="custom-section">
    <span class="custom-label">ğŸ€ Accessory</span>
    <div class="option-row" id="acc-opts">
      <div class="opt-btn selected" data-val="none" onclick="setCatProp('accessory','none')">None</div>
      <div class="opt-btn" data-val="bow" onclick="setCatProp('accessory','bow')">ğŸ€ Bow</div>
      <div class="opt-btn" data-val="flower" onclick="setCatProp('accessory','flower')">ğŸŒ¸ Flower</div>
      <div class="opt-btn" data-val="hat" onclick="setCatProp('accessory','hat')">ğŸ© Hat</div>
      <div class="opt-btn" data-val="stars" onclick="setCatProp('accessory','stars')">â­ Stars</div>
      <div class="opt-btn" data-val="crown" onclick="setCatProp('accessory','crown')">ğŸ‘‘ Crown</div>
    </div>
  </div>

  <div class="btn-row">
    <button class="btn btn-grey btn-sm" onclick="showScreen('title-screen')">â† Back</button>
    <button class="btn btn-sm" onclick="goLevelSelect()">Play â†’</button>
  </div>
</div>

<!-- LEVEL SELECT -->
<div class="screen hidden" id="level-screen">
  <h2>Choose Adventure ğŸ—ºï¸</h2>
  <div class="level-list" id="level-list">
    <div class="level-card unlocked" id="lc-0" onclick="beginLevel(0)">
      <div class="level-icon">ğŸ </div>
      <div class="level-card-text">
        <div class="level-card-name">Home Sweet Home</div>
        <div class="level-card-desc">Cosy rooms Â· friendly cats Â· find the key!</div>
      </div>
    </div>
    <div class="level-card locked" id="lc-1">
      <div class="level-icon">ğŸŒ³</div>
      <div class="level-card-text">
        <div class="level-card-name">Neighbourhood Park</div>
        <div class="level-card-desc">Grassy paths Â· benches Â· pond to navigate</div>
      </div>
    </div>
    <div class="level-card locked" id="lc-2">
      <div class="level-icon">ğŸ¢</div>
      <div class="level-card-text">
        <div class="level-card-name">The Big Building</div>
        <div class="level-card-desc">Office floors Â· rooftop escape</div>
      </div>
    </div>
    <div class="level-card locked" id="lc-3">
      <div class="level-icon">ğŸš‰</div>
      <div class="level-card-text">
        <div class="level-card-name">Train Station</div>
        <div class="level-card-desc">Platform rush Â· dodge luggage Â· catch the train!</div>
      </div>
    </div>
    <div class="level-card unlocked" id="lc-4" onclick="beginLevel(4)">
      <div class="level-icon">âš½</div>
      <div class="level-card-text">
        <div class="level-card-name">Cat Soccer âš½</div>
        <div class="level-card-desc">Score 7 goals Â· dash to kick harder Â· vs 3 cats!</div>
      </div>
    </div>
  </div>
  <button class="btn btn-grey btn-sm" onclick="showScreen('custom-screen')">â† Back</button>
</div>

<!-- GAME OVER -->
<div class="screen hidden" id="gameover-screen">
  <div class="result-emoji">ğŸ˜¿</div>
  <h2>Nap Timeâ€¦</h2>
  <div id="go-name" style="font-size:15px;color:#8d6e63;font-weight:700;text-align:center"></div>
  <div class="btn-row">
    <button class="btn btn-sm" onclick="retryLevel()">Try Again ğŸŒ¸</button>
    <button class="btn btn-grey btn-sm" onclick="goLevelSelect()">Levels</button>
  </div>
</div>

<!-- LEVEL COMPLETE -->
<div class="screen hidden" id="levelcomplete-screen">
  <div class="result-emoji" id="lc-emoji">ğŸ‰</div>
  <h2 id="lc-title">Level Complete!</h2>
  <div id="lc-desc" style="font-size:14px;color:#5d4037;font-weight:700;text-align:center;max-width:280px"></div>
  <div class="btn-row">
    <button class="btn btn-green btn-sm" id="lc-next-btn" onclick="nextLevel()">Next Level â†’</button>
    <button class="btn btn-grey btn-sm" onclick="goLevelSelect()">Levels</button>
  </div>
</div>

<!-- HUD -->
<div id="hud">
  <div class="hud-row">
    <div class="hud-pill"><span id="key-indicator">ğŸ”‘ âœ—</span></div>
    <div class="hud-pill" id="happy-hud" style="display:none"><span id="happy-display">ğŸŒˆ</span></div>
    <div class="hud-pill" style="cursor:pointer;padding:4px 10px;" onclick="toggleMusic()" id="music-toggle-btn" title="Music: On">ğŸµ</div>
    <div class="hud-pill" style="cursor:pointer;padding:4px 10px;" onclick="takePhoto()" title="Take Photo (P)">ğŸ“·</div>
    <div class="hud-pill" style="cursor:pointer;padding:4px 10px;" onclick="toggleJournal()" title="Sticker Journal (J)">ğŸ“”</div>
    <div class="hud-pill" id="watering-hud" style="display:none">ğŸª£</div>
    <div class="hud-pill" id="daytime-hud" style="font-size:10px">â˜€ï¸</div>
    <div class="hud-pill" style="cursor:pointer;padding:4px 10px;" onclick="toggleHelp()" title="Help (H)">â“</div>
  </div>
</div>

<!-- CANVAS -->
<div id="game-canvas-wrap">
  <canvas id="gameCanvas" width="420" height="700"></canvas>
  <!-- TOUCH -->
  <div id="touch-controls">
    <div id="joystick-zone"><div id="joystick-knob"></div></div>
    <div class="action-btns">
      <div class="touch-action-btn" id="scratch-btn" ontouchstart="onScratchDown(event)" ontouchend="onScratchUp(event)">ğŸ¾</div>
    </div>
  </div>
</div>

<!-- POPUP CONTAINER -->
<div id="popup-layer" style="position:absolute;inset:0;pointer-events:none;z-index:30;overflow:hidden;"></div>

</div><!-- #app -->

</body>
</html>
<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AUDIO ENGINE (Web Audio API â€” no files needed)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let audioCtx = null;
function getAudio() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if (audioCtx.state === 'suspended') audioCtx.resume();
  return audioCtx;
}

function playMeow() {
  try {
    const ac = getAudio(), t = ac.currentTime;
    // Meow: two formants, pitch glide
    const osc1 = ac.createOscillator(), osc2 = ac.createOscillator();
    const gain = ac.createGain(), gain2 = ac.createGain();
    const filter = ac.createBiquadFilter();
    filter.type = 'bandpass'; filter.frequency.value = 1200; filter.Q.value = 3;
    osc1.type = 'sawtooth'; osc2.type = 'sine';
    osc1.frequency.setValueAtTime(340, t);
    osc1.frequency.exponentialRampToValueAtTime(520, t + 0.12);
    osc1.frequency.exponentialRampToValueAtTime(380, t + 0.28);
    osc2.frequency.setValueAtTime(680, t);
    osc2.frequency.exponentialRampToValueAtTime(1040, t + 0.12);
    osc2.frequency.exponentialRampToValueAtTime(760, t + 0.28);
    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(0.28, t + 0.04);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.32);
    gain2.gain.setValueAtTime(0.08, t);
    gain2.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
    osc1.connect(filter); filter.connect(gain); gain.connect(ac.destination);
    osc2.connect(gain2); gain2.connect(ac.destination);
    osc1.start(t); osc1.stop(t + 0.35);
    osc2.start(t); osc2.stop(t + 0.30);
  } catch(e) {}
}

function playHit() {
  try {
    const ac = getAudio(), t = ac.currentTime;
    const buf = ac.createBuffer(1, ac.sampleRate * 0.12, ac.sampleRate);
    const d = buf.getChannelData(0);
    for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / d.length, 2);
    const src = ac.createBufferSource(), g = ac.createGain();
    const f = ac.createBiquadFilter(); f.type = 'lowpass'; f.frequency.value = 800;
    src.buffer = buf; g.gain.setValueAtTime(0.35, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
    src.connect(f); f.connect(g); g.connect(ac.destination); src.start(t);
  } catch(e) {}
}

function playCollect() {
  try {
    const ac = getAudio(), t = ac.currentTime;
    [0, 0.07, 0.14].forEach((dt, i) => {
      const o = ac.createOscillator(), g = ac.createGain();
      o.type = 'sine'; o.frequency.value = [523, 659, 784][i];
      g.gain.setValueAtTime(0.18, t + dt); g.gain.exponentialRampToValueAtTime(0.001, t + dt + 0.18);
      o.connect(g); g.connect(ac.destination); o.start(t + dt); o.stop(t + dt + 0.2);
    });
  } catch(e) {}
}

function playKeyPickup() {
  try {
    const ac = getAudio(), t = ac.currentTime;
    [0, 0.08, 0.16, 0.24].forEach((dt, i) => {
      const o = ac.createOscillator(), g = ac.createGain();
      o.type = 'triangle'; o.frequency.value = [392, 523, 659, 1047][i];
      g.gain.setValueAtTime(0.22, t + dt); g.gain.exponentialRampToValueAtTime(0.001, t + dt + 0.25);
      o.connect(g); g.connect(ac.destination); o.start(t + dt); o.stop(t + dt + 0.3);
    });
  } catch(e) {}
}

function playDoorOpen() {
  try {
    const ac = getAudio(), t = ac.currentTime;
    [0, 0.1, 0.2, 0.3, 0.4].forEach((dt, i) => {
      const o = ac.createOscillator(), g = ac.createGain();
      o.type = 'sine'; o.frequency.value = [261, 329, 392, 523, 784][i];
      g.gain.setValueAtTime(0.2, t + dt); g.gain.exponentialRampToValueAtTime(0.001, t + dt + 0.35);
      o.connect(g); g.connect(ac.destination); o.start(t + dt); o.stop(t + dt + 0.4);
    });
  } catch(e) {}
}

function playLeverClick() {
  try {
    const ac = getAudio(), t = ac.currentTime;
    const o = ac.createOscillator(), g = ac.createGain();
    o.type = 'square'; o.frequency.setValueAtTime(180, t); o.frequency.exponentialRampToValueAtTime(90, t + 0.08);
    g.gain.setValueAtTime(0.25, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
    o.connect(g); g.connect(ac.destination); o.start(t); o.stop(t + 0.12);
  } catch(e) {}
}

function playBreak() {
  try {
    const ac = getAudio(), t = ac.currentTime;
    const buf = ac.createBuffer(1, ac.sampleRate * 0.18, ac.sampleRate);
    const d = buf.getChannelData(0);
    for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / d.length, 1.5) * 0.6;
    const src = ac.createBufferSource(), g = ac.createGain();
    const f = ac.createBiquadFilter(); f.type = 'highpass'; f.frequency.value = 400;
    src.buffer = buf; g.gain.setValueAtTime(0.4, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.18);
    src.connect(f); f.connect(g); g.connect(ac.destination); src.start(t);
  } catch(e) {}
}

function playWoof() {
  try {
    const ac = getAudio(), t = ac.currentTime;
    // Two-part woof: sharp attack bark + tail resonance
    const osc1 = ac.createOscillator(), osc2 = ac.createOscillator();
    const g1 = ac.createGain(), g2 = ac.createGain();
    const dist = ac.createWaveShaper();
    // Soft distortion for rough bark texture
    const curve = new Float32Array(256);
    for (let i = 0; i < 256; i++) { const x = (i * 2) / 256 - 1; curve[i] = (Math.PI + 200) * x / (Math.PI + 200 * Math.abs(x)); }
    dist.curve = curve;
    osc1.type = 'sawtooth';
    osc1.frequency.setValueAtTime(220, t);
    osc1.frequency.exponentialRampToValueAtTime(140, t + 0.08);
    osc1.frequency.exponentialRampToValueAtTime(100, t + 0.22);
    osc2.type = 'sine';
    osc2.frequency.setValueAtTime(180, t);
    osc2.frequency.exponentialRampToValueAtTime(80, t + 0.18);
    g1.gain.setValueAtTime(0, t);
    g1.gain.linearRampToValueAtTime(0.35, t + 0.02);
    g1.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
    g2.gain.setValueAtTime(0.15, t);
    g2.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
    osc1.connect(dist); dist.connect(g1); g1.connect(ac.destination);
    osc2.connect(g2); g2.connect(ac.destination);
    osc1.start(t); osc1.stop(t + 0.28);
    osc2.start(t); osc2.stop(t + 0.22);
  } catch(e) {}
}

function playDash() {
  try {
    const ac = getAudio(), t = ac.currentTime;
    const o = ac.createOscillator(), g = ac.createGain();
    const f = ac.createBiquadFilter(); f.type='highpass'; f.frequency.value=300;
    o.type='sawtooth';
    o.frequency.setValueAtTime(600,t); o.frequency.exponentialRampToValueAtTime(200,t+0.12);
    g.gain.setValueAtTime(0.18,t); g.gain.exponentialRampToValueAtTime(0.001,t+0.14);
    o.connect(f); f.connect(g); g.connect(ac.destination); o.start(t); o.stop(t+0.15);
  } catch(e){}
}

function playPurr() {
  try {
    const ac = getAudio(), t = ac.currentTime;
    // Low rumble oscillating â€” purring
    const o1 = ac.createOscillator(), o2 = ac.createOscillator();
    const lfo = ac.createOscillator(), lfoG = ac.createGain();
    const g = ac.createGain();
    o1.type='sine'; o1.frequency.value=55;
    o2.type='sine'; o2.frequency.value=60;
    lfo.type='sine'; lfo.frequency.value=28; // purr rate
    lfoG.gain.value=20;
    lfo.connect(lfoG); lfoG.connect(o1.frequency); lfoG.connect(o2.frequency);
    g.gain.setValueAtTime(0,t);
    g.gain.linearRampToValueAtTime(0.22,t+0.1);
    g.gain.setValueAtTime(0.22,t+0.55);
    g.gain.exponentialRampToValueAtTime(0.001,t+0.75);
    o1.connect(g); o2.connect(g); g.connect(ac.destination);
    o1.start(t); o1.stop(t+0.8);
    o2.start(t); o2.stop(t+0.8);
    lfo.start(t); lfo.stop(t+0.8);
  } catch(e){}
}

function playNapSound() {
  try {
    const ac = getAudio(), t = ac.currentTime;
    // Gentle lullaby-ish chime
    [523, 659, 784].forEach((freq, i) => {
      const o = ac.createOscillator(), g = ac.createGain();
      o.type = 'sine'; o.frequency.value = freq;
      g.gain.setValueAtTime(0, t+i*0.22);
      g.gain.linearRampToValueAtTime(0.12, t+i*0.22+0.06);
      g.gain.exponentialRampToValueAtTime(0.001, t+i*0.22+0.6);
      o.connect(g); g.connect(ac.destination); o.start(t+i*0.22); o.stop(t+i*0.22+0.7);
    });
  } catch(e){}
}

function playPlatformStart() {
  try {
    const ac = getAudio(), t = ac.currentTime;
    const o = ac.createOscillator(), g = ac.createGain();
    o.type = 'sawtooth'; o.frequency.setValueAtTime(220, t); o.frequency.linearRampToValueAtTime(330, t + 0.15);
    g.gain.setValueAtTime(0.2, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.22);
    o.connect(g); g.connect(ac.destination); o.start(t); o.stop(t + 0.25);
  } catch(e) {}
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COZY JAPANESE MUSIC ENGINE
// Procedural pentatonic koto/shakuhachi-inspired ambient music
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let musicCtx = null, musicPlaying = false, musicEnabled = true;
let musicNodes = []; // track active nodes for cleanup

// Japanese pentatonic scale (A minor pentatonic) in Hz
// éŸ³éš: A3, C4, D4, E4, G4, A4, C5, D5, E5, G5
const PENTATONIC = [220.0, 261.6, 293.7, 329.6, 392.0, 440.0, 523.3, 587.3, 659.3, 784.0];

// Melodic phrases â€” indices into PENTATONIC
const PHRASES = [
  [5,4,3,2,1,0,2,3],       // falling
  [0,2,3,5,4,3,2,0],       // arch
  [5,5,4,3,5,4,2,0],       // ornamental
  [3,4,5,4,3,2,3,2],       // winding
  [0,3,2,0,2,3,5,4],       // rising
  [5,4,3,5,3,2,0,2],       // meditative
];

function getMusicCtx() {
  if (!musicCtx) {
    musicCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (musicCtx.state === 'suspended') musicCtx.resume();
  return musicCtx;
}

// Master gain for music (separate from SFX)
let masterGain = null;
function getMasterGain() {
  if (!masterGain) {
    const ac = getMusicCtx();
    masterGain = ac.createGain();
    masterGain.gain.value = 0.0;
    masterGain.connect(ac.destination);
  }
  return masterGain;
}

// Reverb convolver for lush room sound
let reverbNode = null;
async function getReverb() {
  if (reverbNode) return reverbNode;
  const ac = getMusicCtx();
  reverbNode = ac.createConvolver();
  // Generate synthetic impulse response (room reverb)
  const len = ac.sampleRate * 2.8;
  const buf = ac.createBuffer(2, len, ac.sampleRate);
  for (let ch = 0; ch < 2; ch++) {
    const d = buf.getChannelData(ch);
    for (let i = 0; i < len; i++) {
      const decay = Math.pow(1 - i/len, 2.2);
      d[i] = (Math.random()*2-1) * decay * (i < ac.sampleRate*0.01 ? 0 : 1);
    }
  }
  reverbNode.buffer = buf;
  reverbNode.connect(getMasterGain());
  return reverbNode;
}

// Koto-like pluck: sine + triangle blend, fast attack, long decay
function playKotoNote(freq, startTime, duration, gain=0.22, reverb=null) {
  try {
    const ac = getMusicCtx();
    const osc1 = ac.createOscillator();
    const osc2 = ac.createOscillator();
    const g = ac.createGain();
    const filter = ac.createBiquadFilter();

    osc1.type = 'triangle'; osc1.frequency.value = freq;
    osc2.type = 'sine';     osc2.frequency.value = freq * 2.003; // slight detune for shimmer
    filter.type = 'lowpass'; filter.frequency.setValueAtTime(3000, startTime);
    filter.frequency.exponentialRampToValueAtTime(800, startTime + duration*0.4);

    // Pluck envelope: very fast attack, exponential decay (koto character)
    g.gain.setValueAtTime(0, startTime);
    g.gain.linearRampToValueAtTime(gain, startTime + 0.008);
    g.gain.exponentialRampToValueAtTime(gain * 0.3, startTime + duration * 0.25);
    g.gain.exponentialRampToValueAtTime(0.0001, startTime + duration);

    osc1.connect(filter); osc2.connect(filter); filter.connect(g);
    if (reverb) g.connect(reverb);
    g.connect(getMasterGain());

    osc1.start(startTime); osc1.stop(startTime + duration + 0.1);
    osc2.start(startTime); osc2.stop(startTime + duration + 0.1);
    musicNodes.push(osc1, osc2);
  } catch(e) {}
}

// Shakuhachi-like breathy tone: sine + slight noise + vibrato
function playFluteNote(freq, startTime, duration, gain=0.12) {
  try {
    const ac = getMusicCtx();
    const osc = ac.createOscillator();
    const vibLfo = ac.createOscillator();
    const vibGain = ac.createGain();
    const noiseNode = ac.createOscillator(); // second osc for breath texture
    const g = ac.createGain();
    const filter = ac.createBiquadFilter();

    osc.type = 'sine'; osc.frequency.value = freq;
    vibLfo.type = 'sine'; vibLfo.frequency.value = 5.2; // natural vibrato rate
    vibGain.gain.value = freq * 0.012; // subtle vibrato depth
    vibLfo.connect(vibGain); vibGain.connect(osc.frequency);

    noiseNode.type = 'sawtooth'; noiseNode.frequency.value = freq * 1.01;
    filter.type = 'bandpass'; filter.frequency.value = freq * 1.5; filter.Q.value = 8;

    // Breath envelope: slow attack, long sustain
    g.gain.setValueAtTime(0, startTime);
    g.gain.linearRampToValueAtTime(gain, startTime + duration*0.18);
    g.gain.setValueAtTime(gain, startTime + duration*0.7);
    g.gain.exponentialRampToValueAtTime(0.0001, startTime + duration);

    const ng = ac.createGain(); ng.gain.value = gain * 0.18;
    noiseNode.connect(filter); filter.connect(ng); ng.connect(g);
    osc.connect(g); g.connect(getMasterGain());

    osc.start(startTime); osc.stop(startTime + duration + 0.05);
    noiseNode.start(startTime); noiseNode.stop(startTime + duration + 0.05);
    vibLfo.start(startTime); vibLfo.stop(startTime + duration + 0.05);
    musicNodes.push(osc, vibLfo, noiseNode);
  } catch(e) {}
}

// Low drum (taiko-ish): noise burst + low sine thud
function playDrum(startTime, gain=0.14) {
  try {
    const ac = getMusicCtx();
    const buf = ac.createBuffer(1, ac.sampleRate * 0.25, ac.sampleRate);
    const d = buf.getChannelData(0);
    for (let i=0; i<d.length; i++) d[i] = (Math.random()*2-1)*Math.pow(1-i/d.length,1.6);
    const src = ac.createBufferSource();
    const osc = ac.createOscillator(); // thud body
    const g1 = ac.createGain(), g2 = ac.createGain();
    const f = ac.createBiquadFilter(); f.type='lowpass'; f.frequency.value=180;

    src.buffer = buf;
    osc.type='sine'; osc.frequency.setValueAtTime(80,startTime); osc.frequency.exponentialRampToValueAtTime(40,startTime+0.12);
    g1.gain.setValueAtTime(gain*0.7,startTime); g1.gain.exponentialRampToValueAtTime(0.0001,startTime+0.22);
    g2.gain.setValueAtTime(gain,startTime); g2.gain.exponentialRampToValueAtTime(0.0001,startTime+0.14);

    src.connect(f); f.connect(g1); g1.connect(getMasterGain());
    osc.connect(g2); g2.connect(getMasterGain());

    src.start(startTime); osc.start(startTime); osc.stop(startTime+0.28);
    musicNodes.push(osc);
  } catch(e){}
}

// Schedule one "bar" of music
let musicScheduleId = null;
let nextBarTime = 0;
const BAR_DURATION = 3.2; // seconds per bar â€” slow, meditative tempo
let currentPhraseIdx = 0;
let phrasePosition = 0;

function scheduleMusicBar() {
  if (!musicPlaying || !musicEnabled) return;
  try {
    const ac = getMusicCtx();
    const barStart = nextBarTime;
    const phrase = PHRASES[currentPhraseIdx % PHRASES.length];
    const noteDur = BAR_DURATION / phrase.length;

    // Schedule koto melody
    phrase.forEach((noteIdx, i) => {
      const freq = PENTATONIC[noteIdx];
      const noteStart = barStart + i * noteDur;
      // Vary velocity for humanised feel
      const vel = 0.14 + Math.random()*0.12;
      playKotoNote(freq, noteStart, noteDur*0.85, vel);
      // Occasionally double the note an octave down for depth
      if (Math.random() < 0.25) {
        playKotoNote(freq * 0.5, noteStart + 0.015, noteDur*0.7, vel*0.4);
      }
    });

    // Flute line â€” plays a slower counter-melody every 2 bars
    if (currentPhraseIdx % 2 === 0) {
      const flutePhrase = [phrase[0], phrase[2], phrase[4]||phrase[3], phrase[6]||phrase[5]];
      flutePhrase.forEach((noteIdx, i) => {
        const freq = PENTATONIC[Math.min(noteIdx+2, PENTATONIC.length-1)] * 0.5; // lower octave flute
        const noteStart = barStart + i * (BAR_DURATION/flutePhrase.length);
        if (Math.random() < 0.7) playFluteNote(freq, noteStart, BAR_DURATION/flutePhrase.length * 0.9, 0.08);
      });
    }

    // Sparse taiko drums â€” 1-2 per bar on random beats
    const drumBeats = [0, 1, 3].filter(()=>Math.random()<0.45);
    drumBeats.forEach(beat => {
      playDrum(barStart + beat * (BAR_DURATION/4), 0.10+Math.random()*0.06);
    });

    // Ambient bass drone (root note) â€” very soft
    playKotoNote(PENTATONIC[0] * 0.25, barStart, BAR_DURATION * 0.95, 0.06);

    // Advance phrase every 2 bars
    phrasePosition++;
    if (phrasePosition >= 2) {
      phrasePosition = 0;
      currentPhraseIdx = (currentPhraseIdx + 1) % PHRASES.length;
    }

    nextBarTime += BAR_DURATION;

    // Schedule next bar slightly before this one ends
    const msUntilNext = (nextBarTime - ac.currentTime - 0.3) * 1000;
    musicScheduleId = setTimeout(scheduleMusicBar, Math.max(0, msUntilNext));
  } catch(e) {}
}

function startMusic() {
  if (musicPlaying) return;
  musicPlaying = true;
  try {
    const ac = getMusicCtx();
    nextBarTime = ac.currentTime + 0.2;
    getMasterGain().gain.cancelScheduledValues(ac.currentTime);
    getMasterGain().gain.setValueAtTime(getMasterGain().gain.value, ac.currentTime);
    getMasterGain().gain.linearRampToValueAtTime(0.72, ac.currentTime + 1.5);
    // Kick off reverb (async, but music starts without it)
    getReverb().catch(()=>{});
    scheduleMusicBar();
  } catch(e){}
}

function stopMusic(fade=true) {
  musicPlaying = false;
  if (musicScheduleId) { clearTimeout(musicScheduleId); musicScheduleId=null; }
  try {
    const ac = getMusicCtx();
    const mg = getMasterGain();
    if (fade) {
      mg.gain.cancelScheduledValues(ac.currentTime);
      mg.gain.setValueAtTime(mg.gain.value, ac.currentTime);
      mg.gain.linearRampToValueAtTime(0.0, ac.currentTime + 1.2);
    } else {
      mg.gain.value = 0;
    }
  } catch(e){}
}

function toggleMusic() {
  musicEnabled = !musicEnabled;
  const btn = document.getElementById('music-toggle-btn');
  if (musicEnabled) {
    startMusic();
    if (btn) btn.textContent = 'ğŸµ';
    if (btn) btn.title = 'Music: On';
  } else {
    stopMusic(true);
    if (btn) btn.textContent = 'ğŸ”‡';
    if (btn) btn.title = 'Music: Off';
  }
}


// â”€â”€â”€ WEATHER SYSTEM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const LEVEL_WEATHER = ['rain', 'blossoms', 'dustmotes', 'snow'];

let weatherParticles = [];
function initWeather(levelIdx) {
  weatherParticles = [];
  const type = LEVEL_WEATHER[levelIdx] || 'none';
  const count = {rain:80, blossoms:40, dustmotes:50, snow:60}[type] || 0;
  for (let i = 0; i < count; i++) weatherParticles.push(makeWeatherParticle(type, true));
}

function makeWeatherParticle(type, init=false) {
  const p = { type };
  if (type === 'rain') {
    p.x = Math.random()*CW; p.y = init ? Math.random()*CH : -8;
    p.vy = 9 + Math.random()*5; p.vx = -1.5 + Math.random()*0.5;
    p.len = 8 + Math.random()*10; p.alpha = 0.2 + Math.random()*0.3;
  } else if (type === 'blossoms') {
    p.x = Math.random()*CW; p.y = init ? Math.random()*CH : -12;
    p.vx = -0.4 + Math.random()*0.8; p.vy = 0.5 + Math.random()*0.8;
    p.rot = Math.random()*Math.PI*2; p.rotV = (Math.random()-0.5)*0.04;
    p.size = 5 + Math.random()*5; p.hue = 340 + Math.random()*20;
    p.swing = Math.random()*Math.PI*2; p.swingS = 0.02+Math.random()*0.02;
  } else if (type === 'dustmotes') {
    p.x = Math.random()*CW; p.y = Math.random()*CH;
    p.vx = (Math.random()-0.5)*0.3; p.vy = (Math.random()-0.5)*0.2;
    p.r = 1 + Math.random()*2; p.alpha = 0.08 + Math.random()*0.15;
    p.pulsePhase = Math.random()*Math.PI*2;
  } else if (type === 'snow') {
    p.x = Math.random()*CW; p.y = init ? Math.random()*CH : -8;
    p.vx = (Math.random()-0.5)*0.6; p.vy = 0.6 + Math.random()*0.8;
    p.r = 2 + Math.random()*3; p.alpha = 0.5 + Math.random()*0.4;
    p.swing = Math.random()*Math.PI*2; p.swingS = 0.01+Math.random()*0.02;
    p.settled = false;
  }
  return p;
}

function updateWeather() {
  if (!gs || !weatherParticles.length) return;
  const t = gs.time;
  for (let i = weatherParticles.length - 1; i >= 0; i--) {
    const p = weatherParticles[i];
    if (p.type === 'rain') {
      p.x += p.vx; p.y += p.vy;
      if (p.y > CH + 10) weatherParticles[i] = makeWeatherParticle('rain');
    } else if (p.type === 'blossoms') {
      p.swing += p.swingS; p.rot += p.rotV;
      p.x += p.vx + Math.sin(p.swing)*0.4; p.y += p.vy;
      if (p.y > CH + 14) weatherParticles[i] = makeWeatherParticle('blossoms');
    } else if (p.type === 'dustmotes') {
      p.pulsePhase += 0.02;
      p.x += p.vx; p.y += p.vy;
      if (p.x < 0) p.x = CW; if (p.x > CW) p.x = 0;
      if (p.y < 0) p.y = CH; if (p.y > CH) p.y = 0;
    } else if (p.type === 'snow') {
      p.swing += p.swingS;
      p.x += p.vx + Math.sin(p.swing)*0.5; p.y += p.vy;
      if (p.y > CH + 8) weatherParticles[i] = makeWeatherParticle('snow');
    }
  }
}

function drawWeather() {
  if (!weatherParticles.length) return;
  ctx.save();
  for (const p of weatherParticles) {
    if (p.type === 'rain') {
      ctx.strokeStyle = `rgba(180,220,255,${p.alpha})`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(p.x, p.y);
      ctx.lineTo(p.x + p.vx * 1.5, p.y - p.len);
      ctx.stroke();
    } else if (p.type === 'blossoms') {
      ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(p.rot);
      ctx.globalAlpha = 0.75;
      // 5-petal flower shape
      ctx.fillStyle = `hsl(${p.hue},80%,80%)`;
      for (let k = 0; k < 5; k++) {
        ctx.save(); ctx.rotate(k * Math.PI * 2 / 5);
        ctx.beginPath(); ctx.ellipse(0, -p.size*0.55, p.size*0.3, p.size*0.5, 0, 0, Math.PI*2);
        ctx.fill(); ctx.restore();
      }
      ctx.fillStyle = `hsl(50,90%,85%)`; // center
      ctx.beginPath(); ctx.arc(0, 0, p.size*0.22, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    } else if (p.type === 'dustmotes') {
      const a = p.alpha * (0.7 + Math.sin(p.pulsePhase)*0.3);
      ctx.fillStyle = `rgba(255,245,220,${a})`;
      ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
    } else if (p.type === 'snow') {
      ctx.fillStyle = `rgba(255,255,255,${p.alpha})`;
      ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
    }
  }
  // Rain window overlay for home level
  if (weatherParticles[0]?.type === 'rain') {
    ctx.fillStyle = 'rgba(180,210,255,0.04)';
    ctx.fillRect(0, 0, CW, CH);
  }
  ctx.restore();
}

// â”€â”€â”€ NAP SPOTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnNapSpots(levelIdx, floorCells, usedC, rng) {
  const opts = [
    [['ğŸ›ï¸','bed'],['ğŸ›‹ï¸','couch'],['ğŸ§¸','cushion']],
    [['ğŸŒ¿','grass'],['ğŸªµ','log'],['ğŸŒ¸','petal-bed']],
    [['ğŸª‘','chair'],['ğŸ“‹','mat'],['ğŸ§º','basket']],
    [['ğŸ’','bench'],['ğŸ“°','paper-pile'],['ğŸ’º','seat']],
  ][levelIdx] || [['ğŸŒ¸','spot'],['âœ¨','nook'],['ğŸƒ','leaf-bed']];
  const spots = [];
  const zone = floorCells.filter(p => p.r > 4 && p.r < floorCells.reduce((m,p)=>Math.max(m,p.r),0)-4);
  for (let i = 0; i < 3; i++) {
    let cell;
    for (let a = 0; a < 40; a++) {
      cell = zone[Math.floor(rng()*zone.length)];
      if (cell && !usedC.has(`${cell.r},${cell.c}`)) break;
    }
    if (!cell) continue;
    usedC.add(`${cell.r},${cell.c}`);
    const [emoji, name] = opts[i % opts.length];
    spots.push({
      emoji, name, wx: cell.c*TILE+TILE/2, wy: cell.r*TILE+TILE/2,
      napTimer: 0, napping: false, napAnim: 0, zzzPhase: 0,
    });
  }
  return spots;
}

function updateNapSpots() {
  if (!gs.napSpots) return;
  const cat = gs.cat;
  for (const s of gs.napSpots) {
    const dist = Math.hypot(cat.wx-s.wx, cat.wy-s.wy);
    const moving = cat.moving || cat.dashFrames > 0;
    if (dist < 26 && !moving) {
      s.napTimer++;
      if (s.napTimer > 90 && !s.napping) {
        s.napping = true; s.napAnim = 0;
        playNapSound();
      }
    } else {
      if (s.napping && (moving || dist > 32)) {
        s.napping = false;
        cat.happyFrames = Math.max(cat.happyFrames, HAPPY_DURATION);
        spawnParticles(cat.wx, cat.wy, 'ğŸŒˆ');
        spawnParticles(cat.wx, cat.wy, 'âœ¨');
      }
      s.napTimer = 0;
    }
    if (s.napping) { s.napAnim++; s.zzzPhase += 0.06; }
  }
}

function drawNapSpots(t) {
  if (!gs.napSpots) return;
  const cat = gs.cat;
  for (const s of gs.napSpots) {
    ctx.save(); ctx.translate(s.wx, s.wy);
    // Glow under spot
    const dist = Math.hypot(cat.wx-s.wx, cat.wy-s.wy);
    if (dist < 55) {
      const nearAlpha = (55-dist)/55*0.18;
      ctx.fillStyle=`rgba(255,220,180,${nearAlpha})`;
      ctx.beginPath(); ctx.arc(0,0,22,0,Math.PI*2); ctx.fill();
    }
    ctx.font='20px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(s.emoji, 0, 0);
    // Name hint
    if (dist < 55 && !s.napping) {
      ctx.font='bold 8px Nunito,sans-serif'; ctx.fillStyle='rgba(120,80,60,0.7)';
      ctx.fillText('Nap here~', 0, -18);
    }
    // Zzz floating up when napping
    if (s.napping) {
      const zs = [0, 0.7, 1.4];
      for (let i=0; i<3; i++) {
        const phase = (s.zzzPhase + zs[i]) % (Math.PI*2);
        const progress = phase / (Math.PI*2);
        const zy = -20 - progress*28;
        const zx = Math.sin(phase*2)*8 + 10;
        const alpha = progress < 0.7 ? progress/0.7 : 1 - (progress-0.7)/0.3;
        const fsize = 9 + i*3;
        ctx.globalAlpha = alpha * 0.8;
        ctx.font = `${fsize}px serif`;
        ctx.fillText('z', zx, zy);
      }
      ctx.globalAlpha = 1;
    }
    ctx.restore();
  }
}

// â”€â”€â”€ WATERING + BLOOMING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnWaterFeature(levelIdx, floorCells, interactables, usedC, rng) {
  // One watering can per level + mark some plants as waterable
  const zone = floorCells.filter(p => p.r > 6);
  let cell;
  for (let a = 0; a < 40; a++) {
    cell = zone[Math.floor(rng()*zone.length)];
    if (cell && !usedC.has(`${cell.r},${cell.c}`)) break;
  }
  const can = cell ? {
    type:'wateringcan', emoji:'ğŸª£', wx:cell.c*TILE+TILE/2, wy:cell.r*TILE+TILE/2,
    collected:false, pts:0, en:0, bob:rng()*Math.PI*2,
    moveSpeed:0, moveDir:1, moveMin:0, moveMax:0, golden:false, treatType:null,
  } : null;
  if (can) { usedC.add(`${cell.r},${cell.c}`); }
  // Mark 2-3 random plants as wilted/waterable
  const plants = interactables.filter(o => o.type==='plant');
  const numWilt = Math.min(plants.length, 2+Math.floor(rng()*2));
  for (let i=0; i<numWilt; i++) {
    const idx = Math.floor(rng()*plants.length);
    plants[idx].wilted = true; plants[idx].emoji = 'ğŸ¥€'; plants[idx].bloomed = false;
  }
  return can;
}

function tryWaterPlant(cat) {
  if (!gs.hasWateringCan) return;
  // Water nearest wilted plant within scratch range
  for (const obj of gs.interactables) {
    if (!obj.wilted || obj.bloomed) continue;
    const dist = Math.hypot(cat.wx-obj.wx, cat.wy-obj.wy);
    if (dist < SCRATCH_RANGE + 10) {
      obj.bloomed = true; obj.emoji = 'ğŸŒ¸'; obj.wilted = false;
      obj.animTick = 30;
      spawnParticles(obj.wx, obj.wy, 'ğŸŒ¸');
      spawnParticles(obj.wx, obj.wy, 'ğŸ’§');
      spawnPop(obj.wx, obj.wy, 'Bloomed! ğŸŒ¸', '#f48fb1');
      playCollect();
      return;
    }
  }
}

// â”€â”€â”€ FISH TANK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let fishTapAnim = 0; // global anim timer for fish tap
function checkFishTank() {
  if (!gs.fishTank) return;
  const cat = gs.cat;
  const dist = Math.hypot(cat.wx-gs.fishTank.wx, cat.wy-gs.fishTank.wy);
  if (dist < 38 && fishTapAnim === 0) {
    fishTapAnim = 80;
    spawnParticles(gs.fishTank.wx, gs.fishTank.wy-8, 'ğŸ’§');
    spawnParticles(gs.fishTank.wx+8, gs.fishTank.wy, 'ğŸŸ');
    spawnPop(gs.fishTank.wx, gs.fishTank.wy, 'Tap tap! ğŸ¾', '#80deea');
    // Soft bloop sound
    try {
      const ac = getAudio(), t = ac.currentTime;
      const o = ac.createOscillator(), g = ac.createGain();
      o.type='sine'; o.frequency.setValueAtTime(520,t); o.frequency.exponentialRampToValueAtTime(200,t+0.18);
      g.gain.setValueAtTime(0.12,t); g.gain.exponentialRampToValueAtTime(0.001,t+0.22);
      o.connect(g); g.connect(ac.destination); o.start(t); o.stop(t+0.25);
    } catch(e){}
  }
  if (fishTapAnim > 0) fishTapAnim--;
}

function drawFishTank(t) {
  if (!gs.fishTank) return;
  const ft = gs.fishTank;
  ctx.save(); ctx.translate(ft.wx, ft.wy);
  // Tank body
  ctx.fillStyle='rgba(100,200,255,0.18)';
  ctx.strokeStyle='rgba(100,200,255,0.5)'; ctx.lineWidth=2;
  ctx.beginPath(); ctx.roundRect(-18,-14,36,28,4); ctx.fill(); ctx.stroke();
  // Water shimmer
  ctx.fillStyle='rgba(150,220,255,0.12)';
  ctx.beginPath(); ctx.roundRect(-18,-14,36,10,{upperLeft:4,upperRight:4}); ctx.fill();
  // Fish swimming
  const fx = Math.sin(t*0.06)*10;
  ctx.font='12px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.save(); if(fx<0) ctx.scale(-1,1);
  ctx.fillText('ğŸ ', fx, 2); ctx.restore();
  ctx.font='8px serif'; ctx.fillText('ğŸ¡', Math.sin(t*0.04+1)*8, -4);
  // Paw tap overlay
  if (fishTapAnim > 0) {
    const prog = fishTapAnim/80;
    ctx.globalAlpha = prog;
    ctx.font='14px serif';
    ctx.fillText('ğŸ¾', 16, -10-prog*6);
  }
  ctx.restore();
}

// â”€â”€â”€ PHOTO MODE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let photoFlash = 0;
let shutterSound = () => {
  try {
    const ac = getAudio(), t = ac.currentTime;
    // Click sound
    const buf = ac.createBuffer(1, ac.sampleRate*0.05, ac.sampleRate);
    const d = buf.getChannelData(0);
    for (let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*Math.pow(1-i/d.length,0.5);
    const src = ac.createBufferSource();
    const g = ac.createGain(); g.gain.value=0.3;
    src.buffer=buf; src.connect(g); g.connect(ac.destination); src.start(t);
    // Wind-down whir
    const o = ac.createOscillator(), og = ac.createGain();
    o.type='sine'; o.frequency.setValueAtTime(1800,t+0.05); o.frequency.exponentialRampToValueAtTime(400,t+0.25);
    og.gain.setValueAtTime(0.1,t+0.05); og.gain.exponentialRampToValueAtTime(0.001,t+0.28);
    o.connect(og); og.connect(ac.destination); o.start(t+0.05); o.stop(t+0.3);
  } catch(e){}
};

function takePhoto() {
  if (!gs?.running) return;
  shutterSound();
  photoFlash = 30;
  // Composite current game canvas into a polaroid
  setTimeout(() => {
    try {
      const tmp = document.createElement('canvas');
      tmp.width = CW + 20; tmp.height = CH + 60;
      const tx = tmp.getContext('2d');
      // Polaroid background
      tx.fillStyle='#fff9f0'; tx.fillRect(0,0,tmp.width,tmp.height);
      tx.fillStyle='#f0e0d0'; tx.fillRect(5,5,tmp.width-10,tmp.height-10);
      // Game screenshot
      tx.drawImage(canvas, 10, 10, CW, CH);
      // Polaroid border
      tx.strokeStyle='#d4b896'; tx.lineWidth=3;
      tx.strokeRect(10,10,CW,CH);
      // Label
      tx.font='bold 14px Georgia,serif'; tx.fillStyle='#8d6e63';
      tx.textAlign='center';
      tx.fillText('Neko Day âœ¨', tmp.width/2, CH+35);
      const levelName = ['Home','Park','Building','Station','Soccer'][currentLevel]||'';
      tx.font='10px Georgia,serif'; tx.fillStyle='#a08070';
      tx.fillText(levelName, tmp.width/2, CH+52);
      // Download
      const link = document.createElement('a');
      link.download = `neko-day-photo-${Date.now()}.png`;
      link.href = tmp.toDataURL('image/png');
      link.click();
    } catch(e){ console.log('Photo error:', e); }
  }, 80);
}

function drawPhotoFlash() {
  if (photoFlash <= 0) return;
  const alpha = photoFlash/30;
  ctx.fillStyle=`rgba(255,255,255,${alpha})`;
  ctx.fillRect(0,0,CW,CH);
  // Polaroid frame hint
  if (photoFlash > 18) {
    ctx.strokeStyle=`rgba(200,180,160,${alpha*0.8})`;
    ctx.lineWidth=12; ctx.strokeRect(6,6,CW-12,CH-12);
  }
  photoFlash--;
}
// â”€â”€â”€ END PHOTO MODE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// â”€â”€â”€ STICKER JOURNAL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Stickers are hidden in each level â€” collect them by walking near
const LEVEL_STICKERS = [
  ['ğŸ ','ğŸ›','ğŸª´','ğŸµ','ğŸ•¯ï¸'],   // Home
  ['ğŸŒ³','ğŸŒ¸','ğŸ¦','ğŸŒ¿','â˜€ï¸'],   // Park
  ['ğŸ’¼','ğŸ“','â˜•','ğŸ™ï¸','ğŸ–¥ï¸'],   // Building
  ['ğŸš†','ğŸ«','ğŸ§³','ğŸ—ºï¸','âŒš'],   // Station
];

let collectedStickers = {}; // levelIdx -> [emoji array]
let journalOpen = false;
let journalAnim = 0;

async function loadJournal() {
  try {
    const res = await window.storage.get('neko-journal');
    if (res) collectedStickers = JSON.parse(res.value);
  } catch(e) { collectedStickers = {}; }
}

async function saveJournal() {
  try { await window.storage.set('neko-journal', JSON.stringify(collectedStickers)); } catch(e){}
}

function spawnLevelStickers(levelIdx, floorCells, usedC, rng) {
  const stickers = LEVEL_STICKERS[levelIdx] || [];
  const items = [];
  const zone = floorCells.filter(p => p.r > 5 && p.r < floorCells.reduce((m,p)=>Math.max(m,p.r),0)-3);
  for (let i=0; i<Math.min(3, stickers.length); i++) {
    let cell;
    for (let a=0;a<40;a++) {
      cell = zone[Math.floor(rng()*zone.length)];
      if (cell && !usedC.has(`${cell.r},${cell.c}`)) break;
    }
    if (!cell) continue;
    usedC.add(`${cell.r},${cell.c}`);
    items.push({
      emoji: stickers[i], wx: cell.c*TILE+TILE/2, wy: cell.r*TILE+TILE/2,
      collected:false, revealed:false, bob:rng()*Math.PI*2,
    });
  }
  return items;
}

function updateStickerPickup() {
  if (!gs.stickers) return;
  const cat = gs.cat;
  for (const s of gs.stickers) {
    if (s.collected) continue;
    const dist = Math.hypot(cat.wx-s.wx, cat.wy-s.wy);
    if (dist < 50) s.revealed = true;
    if (dist < 22 && s.revealed) {
      s.collected = true;
      if (!collectedStickers[currentLevel]) collectedStickers[currentLevel] = [];
      if (!collectedStickers[currentLevel].includes(s.emoji))
        collectedStickers[currentLevel].push(s.emoji);
      saveJournal();
      playKeyPickup();
      spawnPop(s.wx, s.wy, `${s.emoji} Sticker!`, '#ffd700');
      spawnParticles(s.wx, s.wy, s.emoji);
      spawnParticles(s.wx, s.wy, 'âœ¨');
    }
  }
}

function drawStickerItems(t) {
  if (!gs.stickers) return;
  const cat = gs.cat;
  for (const s of gs.stickers) {
    if (s.collected) continue;
    const dist = Math.hypot(cat.wx-s.wx, cat.wy-s.wy);
    const nearFactor = Math.max(0, 1-dist/70);
    ctx.save(); ctx.translate(s.wx, s.wy);
    if (s.revealed) {
      const bob = Math.sin(t*0.1+s.bob)*3;
      ctx.translate(0, bob);
      ctx.shadowColor='#ffd700'; ctx.shadowBlur=10+Math.sin(t*0.12)*5;
      ctx.font='18px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(s.emoji, 0, 0);
      ctx.shadowBlur=0;
      ctx.font='bold 7px Nunito,sans-serif'; ctx.fillStyle='#ffd700';
      ctx.fillText('STICKER', 0, -16);
    } else if (nearFactor > 0) {
      ctx.globalAlpha = nearFactor*0.4;
      ctx.font='9px serif'; ctx.textAlign='center';
      ctx.fillText('âœ¨', Math.cos(t*0.1)*8, Math.sin(t*0.1)*8);
    }
    ctx.restore();
  }
}

function toggleJournal() {
  journalOpen = !journalOpen;
  journalAnim = 0;
}

function drawJournal(t) {
  if (!journalOpen) return;
  journalAnim++;
  const progress = Math.min(1, journalAnim/18);
  const ease = progress < 0.5 ? 2*progress*progress : -1+(4-2*progress)*progress;
  const w=260, h=200;
  const x=(CW-w)/2, y=(CH-h)/2;
  ctx.save();
  ctx.translate(CW/2, CH/2); ctx.scale(ease, ease); ctx.translate(-CW/2, -CH/2);
  // Page shadow
  ctx.fillStyle='rgba(0,0,0,0.18)'; ctx.beginPath();
  ctx.roundRect(x+6, y+6, w, h, 12); ctx.fill();
  // Page
  const pg = ctx.createLinearGradient(x,y,x+w,y+h);
  pg.addColorStop(0,'#fff9f0'); pg.addColorStop(1,'#ffeedd');
  ctx.fillStyle=pg; ctx.beginPath(); ctx.roundRect(x,y,w,h,12); ctx.fill();
  ctx.strokeStyle='#d4b896'; ctx.lineWidth=2;
  ctx.beginPath(); ctx.roundRect(x,y,w,h,12); ctx.stroke();
  // Binding
  ctx.fillStyle='#c4956a'; ctx.beginPath();
  ctx.roundRect(x+12,y,16,h,{upperLeft:12,bottomLeft:12}); ctx.fill();
  // Lines
  ctx.strokeStyle='rgba(180,150,120,0.25)'; ctx.lineWidth=1;
  for (let ly=y+35; ly<y+h-15; ly+=18) {
    ctx.beginPath(); ctx.moveTo(x+36,ly); ctx.lineTo(x+w-16,ly); ctx.stroke();
  }
  // Title
  ctx.font='bold 14px Georgia,serif'; ctx.fillStyle='#8d5524'; ctx.textAlign='center';
  ctx.fillText('âœ¨ Sticker Journal', x+w/2, y+22);
  // Stickers grid per level
  let sx=x+42, sy=y+42;
  const levelNames=['ğŸ ','ğŸŒ³','ğŸ¢','ğŸš‰'];
  for (let lv=0; lv<4; lv++) {
    const stks = collectedStickers[lv] || [];
    ctx.font='10px Nunito,sans-serif'; ctx.fillStyle='#a08070'; ctx.textAlign='left';
    ctx.fillText(levelNames[lv], sx, sy-4);
    for (let si=0; si<5; si++) {
      const stk = stks[si];
      // Slot
      ctx.fillStyle = stk ? 'rgba(255,220,160,0.4)' : 'rgba(200,180,150,0.15)';
      ctx.strokeStyle='rgba(180,150,100,0.3)'; ctx.lineWidth=1;
      ctx.beginPath(); ctx.roundRect(sx+si*33, sy+4, 28, 28, 4); ctx.fill(); ctx.stroke();
      if (stk) {
        ctx.font='16px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText(stk, sx+si*33+14, sy+18);
      } else {
        ctx.font='12px serif'; ctx.fillStyle='rgba(180,150,120,0.4)';
        ctx.fillText('?', sx+si*33+14, sy+18);
      }
    }
    sy += 44;
  }
  // Close hint
  ctx.font='10px Nunito,sans-serif'; ctx.fillStyle='#b09070'; ctx.textAlign='center';
  ctx.fillText('Press J or ğŸ“” to close', x+w/2, y+h-10);
  ctx.restore();
}
// â”€â”€â”€ END STICKER JOURNAL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


// â”€â”€â”€ HIDDEN ROOMS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnHiddenRoom(levelIdx, grid, R, floorCells, usedC, rng) {
  // Find a wall cluster near the middle and carve a small secret room
  const triggers = [
    {emoji:'ğŸ“š', name:'bookshelf'},
    {emoji:'ğŸª', name:'mirror'},
    {emoji:'ğŸ—„ï¸', name:'cabinet'},
    {emoji:'ğŸªŸ', name:'panel'},
  ];
  const t = triggers[levelIdx % triggers.length];
  // Find a floor cell adjacent to a wall to place trigger
  const candidates = floorCells.filter(p => {
    if (usedC.has(`${p.r},${p.c}`)) return false;
    // Must have a wall neighbor
    return [[p.r-1,p.c],[p.r+1,p.c],[p.r,p.c-1],[p.r,p.c+1]]
      .some(([nr,nc]) => nr>=0&&nr<R&&nc>=0&&nc<COLS && grid[nr][nc]===1);
  });
  if (!candidates.length) return null;
  const cell = candidates[Math.floor(rng()*Math.min(candidates.length,20))];
  usedC.add(`${cell.r},${cell.c}`);
  // Carve the secret room (3x3) beyond an adjacent wall
  const wallDirs = [[0,1],[0,-1],[1,0],[-1,0]];
  let carved = false, roomCenter = null;
  for (const [dr,dc] of wallDirs) {
    const wr=cell.r+dr, wc=cell.c+dc;
    if (wr<2||wr>R-3||wc<2||wc>COLS-3) continue;
    if (grid[wr][wc]!==1) continue;
    // Try to carve a 3x3 room beyond
    const ok = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,0],[0,1],[1,-1],[1,0],[1,1]]
      .every(([rrr,rcc])=>{
        const rr=wr+dr+rrr, rc=wc+dc+rcc;
        return rr>=1&&rr<R-1&&rc>=1&&rc<COLS-1;
      });
    if (!ok) continue;
    // Carve room
    for (const [rrr,rcc] of [[-1,-1],[-1,0],[-1,1],[0,-1],[0,0],[0,1],[1,-1],[1,0],[1,1]]) {
      grid[wr+dr+rrr][wc+dc+rcc] = 0;
    }
    grid[wr][wc] = 0; // open passage
    roomCenter = {r:wr+dr, c:wc+dc};
    carved = true;
    break;
  }
  if (!carved) return null;
  return {
    ...t,
    wx: cell.c*TILE+TILE/2, wy: cell.r*TILE+TILE/2,
    open: false, openAnim: 0, activated: false,
    roomCenter, roomX: roomCenter.c*TILE+TILE/2, roomY: roomCenter.r*TILE+TILE/2,
    // Decor inside the secret room
    decor: ['âœ¨','ğŸŒ¸','ğŸ’'].map((e,i)=>({
      emoji:e, wx:roomCenter.c*TILE+TILE/2+(i-1)*TILE*0.7, wy:roomCenter.r*TILE+TILE/2,
    })),
  };
}

function updateHiddenRoom() {
  if (!gs.hiddenRoom || gs.hiddenRoom.open) return;
  // Opened via scratch (handled in checkScratchHits via activateInteractable)
}

function drawHiddenRoom(t) {
  if (!gs.hiddenRoom) return;
  const r = gs.hiddenRoom;
  // Trigger object
  ctx.save(); ctx.translate(r.wx, r.wy);
  ctx.font='20px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
  if (!r.activated) {
    ctx.shadowColor='rgba(200,150,255,0.5)';
    ctx.shadowBlur=6+Math.sin(t*0.08)*4;
  }
  ctx.fillText(r.emoji, 0, 0);
  if (!r.activated) {
    ctx.shadowBlur=0;
    ctx.font='bold 7px Nunito,sans-serif'; ctx.fillStyle='rgba(150,100,200,0.7)';
    const cat = gs.cat;
    if (Math.hypot(cat.wx-r.wx,cat.wy-r.wy)<60)
      ctx.fillText('scratch me~', 0, -18);
  }
  ctx.restore();
  // Secret room decor
  if (r.open) {
    r.openAnim = Math.min(r.openAnim+1, 60);
    const prog = r.openAnim/60;
    for (const d of r.decor) {
      ctx.save(); ctx.translate(d.wx, d.wy);
      ctx.globalAlpha = prog;
      const bob = Math.sin(t*0.08+d.wx)*3;
      ctx.translate(0, bob - 20*(1-prog));
      ctx.shadowColor='#ffd700'; ctx.shadowBlur=8;
      ctx.font='18px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(d.emoji, 0, 0);
      ctx.restore();
    }
    // Sparkle aura around room
    if (r.openAnim < 50) {
      ctx.save();
      ctx.globalAlpha=(50-r.openAnim)/50*0.5;
      ctx.fillStyle='rgba(200,150,255,0.4)';
      ctx.beginPath(); ctx.arc(r.roomX, r.roomY, TILE*1.8, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }
  }
}
// â”€â”€â”€ END HIDDEN ROOMS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// â”€â”€â”€ END FISH TANK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// â”€â”€â”€ END WATERING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// â”€â”€â”€ END NAP SPOTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// â”€â”€â”€ END WEATHER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


// â”€â”€â”€ HELP MENU â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let helpOpen = false;
let helpAnim = 0;
let helpScroll = 0;

function toggleHelp() {
  helpOpen = !helpOpen;
  helpAnim = 0;
  helpScroll = 0;
}

const HELP_SECTIONS = [
  {
    icon: 'ğŸ®', title: 'Controls',
    items: [
      ['Move',       'Arrow keys / WASD  Â·  Joystick (mobile)'],
      ['Dash',       'Double-tap a direction  Â·  Quick flick joystick'],
      ['Scratch/Pet','X or Z  Â·  scratch button (mobile)'],
      ['Photo',      'P key  Â·  ğŸ“· button'],
      ['Journal',    'J key  Â·  ğŸ“” button'],
      ['Help',       'H key  Â·  â“ button'],
      ['Music',      'ğŸµ button to toggle on/off'],
    ]
  },
  {
    icon: 'ğŸ—ï¸', title: 'Your Goal',
    items: [
      ['Find the key', 'The ğŸ—ï¸ glows and sparkles â€” hidden in each level'],
      ['Reach the door','With the key, find the ğŸšª door to complete the level'],
    ]
  },
  {
    icon: 'ğŸ±', title: 'Friendly Cats',
    items: [
      ['Meet them',   'Named cats roam each level â€” walk close to see their name'],
      ['Touch them',  'Brush past a cat and it will purr, mew, chirp or trill ğŸ’•'],
      ['Scratch near','Use X/Z close to a cat for an extra heart reaction'],
    ]
  },
  {
    icon: 'ğŸ‘¤', title: 'Humans',
    items: [
      ['Treat givers', 'Walk up and they hand you a ğŸŸ fish snack'],
      ['Petters',      'Some humans pet your cat â€” activates the ğŸŒˆ rainbow boost!'],
      ['Rainbow boost','Speed boost + glowing aura for 8 seconds'],
    ]
  },
  {
    icon: 'ğŸ˜´', title: 'Napping',
    items: [
      ['Find a spot',  'Look for ğŸ›ï¸ ğŸ›‹ï¸ ğŸŒ¿ ğŸªµ nap spots on the floor'],
      ['Fall asleep',  'Stand still on one for ~1.5s â€” cat curls up with Zzz'],
      ['Wake up',      'Move to wake â€” you get the ğŸŒˆ rainbow boost as a reward!'],
    ]
  },
  {
    icon: 'ğŸª£', title: 'Watering Can',
    items: [
      ['Find it',     'One ğŸª£ watering can hidden per level'],
      ['Use it',      'Walk near a wilted ğŸ¥€ plant and press X/Z to water it'],
      ['Watch it grow','The plant blooms into ğŸŒ¸ with a petal burst!'],
    ]
  },
  {
    icon: 'ğŸŸ', title: 'Fish Tank',
    items: [
      ['Find it',     'One fish tank near the start of each level'],
      ['Tap the glass','Walk up and your cat automatically paw-taps the glass'],
      ['Watch the fish','ğŸ  ğŸ¡ swim back and forth inside!'],
    ]
  },
  {
    icon: 'ğŸ“š', title: 'Hidden Rooms',
    items: [
      ['Find the trigger','Look for glowing ğŸ“šğŸªğŸ—„ï¸ğŸªŸ objects on walls'],
      ['Open it',         'Scratch near it (X/Z) to reveal a secret room!'],
      ['Explore inside',  'Secret rooms hold glowing treasures âœ¨ğŸ’ğŸŒ¸'],
    ]
  },
  {
    icon: 'ğŸŒŸ', title: 'Secrets & Stickers',
    items: [
      ['Hidden secrets','Walk everywhere â€” items shimmer âœ¨ when close'],
      ['Stickers',      'Collect 3 stickers per level â€” glow gold when near'],
      ['Your journal',  'Press J or ğŸ“” to see all collected stickers'],
    ]
  },
  {
    icon: 'ğŸŒ…', title: 'World & Weather',
    items: [
      ['Day/Night',   'World cycles: Dawn ğŸŒ… Â· Day â˜€ï¸ Â· Dusk ğŸŒ‡ Â· Night ğŸŒ™'],
      ['Stars',       'Look up at night â€” stars appear and twinkle!'],
      ['Weather',     'Home: ğŸŒ§ï¸  Â·  Park: ğŸŒ¸  Â·  Building: âœ¨  Â·  Station: â„ï¸'],
    ]
  },
  {
    icon: 'ğŸ“·', title: 'Photo Mode',
    items: [
      ['Take a photo', 'Press P or ğŸ“· to capture the current scene'],
      ['Polaroid',     'Downloads as a PNG with a cozy polaroid border'],
      ['Best shots',   'Try capturing cats, blooming flowers, or night scenes!'],
    ]
  },
];
function drawHelp(t) {
  if (!helpOpen) return;
  if (!t && t !== 0) t = Date.now() * 0.016;
  helpAnim = Math.min(helpAnim + 1, 14);
  const ease = helpAnim / 14;
  const smooth = ease < 0.5 ? 2*ease*ease : -1+(4-2*ease)*ease;

  // Full-screen semi-transparent backdrop
  ctx.save();
  ctx.fillStyle = `rgba(30,20,50,${0.82 * smooth})`;
  ctx.fillRect(0, 0, CW, CH);

  const PW = Math.min(CW - 24, 340);
  const PH = CH - 32;
  const PX = (CW - PW) / 2;
  const PY = 16;

  // Panel
  ctx.save();
  ctx.translate(CW/2, CH/2);
  ctx.scale(0.85 + 0.15*smooth, 0.85 + 0.15*smooth);
  ctx.translate(-CW/2, -CH/2);

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.25)';
  ctx.beginPath(); ctx.roundRect(PX+4, PY+4, PW, PH, 16); ctx.fill();

  // Panel background â€” warm parchment
  const pg = ctx.createLinearGradient(PX, PY, PX+PW, PY+PH);
  pg.addColorStop(0, '#fff8f0');
  pg.addColorStop(1, '#ffeedd');
  ctx.fillStyle = pg;
  ctx.beginPath(); ctx.roundRect(PX, PY, PW, PH, 16); ctx.fill();

  // Decorative border
  ctx.strokeStyle = '#d4a574';
  ctx.lineWidth = 2.5;
  ctx.beginPath(); ctx.roundRect(PX+4, PY+4, PW-8, PH-8, 12); ctx.stroke();

  // Header
  ctx.fillStyle = '#5d3a1a';
  ctx.font = 'bold 17px Nunito, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('âœ¨ How to Play âœ¨', CW/2, PY + 28);

  // Divider
  ctx.strokeStyle = '#d4a574';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(PX + 20, PY + 38);
  ctx.lineTo(PX + PW - 20, PY + 38);
  ctx.stroke();

  // Scrollable content area â€” use clipping
  const contentY = PY + 46;
  const contentH = PH - 60;
  ctx.save();
  ctx.beginPath();
  ctx.rect(PX + 8, contentY, PW - 16, contentH);
  ctx.clip();

  const SECTION_GAP = 10;
  const ITEM_H = 28;
  const SECTION_TITLE_H = 22;
  let totalH = 0;
  for (const s of HELP_SECTIONS) {
    totalH += SECTION_TITLE_H + s.items.length * ITEM_H + SECTION_GAP;
  }
  const maxScroll = Math.max(0, totalH - contentH);

  // Scroll via mouse wheel / touch (handled separately)
  let yOff = contentY - helpScroll;

  for (const sec of HELP_SECTIONS) {
    if (yOff + SECTION_TITLE_H > contentY && yOff < contentY + contentH) {
      // Section header
      ctx.fillStyle = 'rgba(212,165,116,0.25)';
      ctx.beginPath();
      ctx.roundRect(PX+10, yOff, PW-20, SECTION_TITLE_H, 6);
      ctx.fill();

      ctx.font = 'bold 11px Nunito, sans-serif';
      ctx.textAlign = 'left';
      ctx.fillStyle = '#7b4c1e';
      ctx.fillText(`${sec.icon} ${sec.title}`, PX + 18, yOff + 15);
    }
    yOff += SECTION_TITLE_H;

    for (const [label, desc] of sec.items) {
      if (yOff + ITEM_H > contentY && yOff < contentY + contentH) {
        // Key chip
        ctx.fillStyle = '#f3e5d0';
        ctx.strokeStyle = '#d4a574';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.roundRect(PX + 14, yOff + 5, 62, 17, 4);
        ctx.fill(); ctx.stroke();

        ctx.font = 'bold 8.5px Nunito, sans-serif';
        ctx.fillStyle = '#8b5e3c';
        ctx.textAlign = 'center';
        ctx.fillText(label, PX + 45, yOff + 16);

        // Description
        ctx.font = '9px Nunito, sans-serif';
        ctx.fillStyle = '#5a3820';
        ctx.textAlign = 'left';
        ctx.fillText(desc, PX + 84, yOff + 16);
      }
      yOff += ITEM_H;
    }
    yOff += SECTION_GAP;
  }

  ctx.restore(); // unclip

  // Scroll indicator
  if (maxScroll > 0) {
    const trackH = contentH - 10;
    const thumbH = Math.max(30, trackH * (contentH / totalH));
    const thumbY = contentY + 5 + (helpScroll / maxScroll) * (trackH - thumbH);
    ctx.fillStyle = 'rgba(212,165,116,0.3)';
    ctx.beginPath(); ctx.roundRect(PX+PW-14, contentY+5, 6, trackH, 3); ctx.fill();
    ctx.fillStyle = '#d4a574';
    ctx.beginPath(); ctx.roundRect(PX+PW-14, thumbY, 6, thumbH, 3); ctx.fill();
  }

  // Footer
  ctx.font = '9px Nunito, sans-serif';
  ctx.fillStyle = '#a08060';
  ctx.textAlign = 'center';
  ctx.fillText('Scroll â†•  Â·  Press H or â“ to close', CW/2, PY + PH - 8);

  ctx.restore(); // unscale
  ctx.restore(); // main save

  // Store maxScroll for event handlers
  drawHelp._maxScroll = maxScroll;
}

// â”€â”€â”€ END HELP MENU â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// â”€â”€â”€ DAY/NIGHT CYCLE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Cycles over ~8 minutes (28800 frames at 60fps), or manually via HUD
// Phases: dawn(0-0.15) â†’ day(0.15-0.5) â†’ dusk(0.5-0.7) â†’ night(0.7-1)
const DAY_CYCLE_LEN = 3600; // ~1 min per full cycle â€” cozy but visible
const TIME_OVERLAYS = [
  // [phase_start, r,g,b, alpha, label]
  [0.00, 255,180,120, 0.10, 'Dawn ğŸŒ…'],
  [0.15, 255,255,220, 0.00, 'Day â˜€ï¸'],
  [0.50, 255,150, 80, 0.12, 'Dusk ğŸŒ‡'],
  [0.70,  30, 20, 80, 0.30, 'Night ğŸŒ™'],
  [0.90, 255,180,120, 0.08, 'Dawn ğŸŒ…'],
];

function getDayPhase() {
  if (!gs) return 0.2;
  return (gs.time % DAY_CYCLE_LEN) / DAY_CYCLE_LEN;
}

function getDayOverlay() {
  const ph = getDayPhase();
  // Find surrounding keyframes and lerp
  const kf = TIME_OVERLAYS;
  let a = kf[kf.length-1], b = kf[0];
  for (let i = 0; i < kf.length-1; i++) {
    if (ph >= kf[i][0] && ph < kf[i+1][0]) { a = kf[i]; b = kf[i+1]; break; }
  }
  const t = (ph - a[0]) / Math.max(0.001, b[0] - a[0]);
  const r = Math.round(a[1] + (b[1]-a[1])*t);
  const g = Math.round(a[2] + (b[2]-a[2])*t);
  const bv = Math.round(a[3] + (b[3]-a[3])*t);
  const al = a[4] + (b[4]-a[4])*t;
  return {r,g,b:bv,al, label: ph < 0.15||ph >= 0.9 ? 'Dawn ğŸŒ…' : ph < 0.5 ? 'Day â˜€ï¸' : ph < 0.7 ? 'Dusk ğŸŒ‡' : 'Night ğŸŒ™'};
}

function drawDayNightOverlay() {
  const ov = getDayOverlay();
  if (ov.al < 0.01) return;
  ctx.fillStyle = `rgba(${ov.r},${ov.g},${ov.b},${ov.al.toFixed(3)})`;
  ctx.fillRect(0, 0, CW, CH);
  // Stars at night
  if (getDayPhase() > 0.65) {
    const starAlpha = Math.min(1, (getDayPhase()-0.65)/0.1) * 0.6;
    ctx.fillStyle = `rgba(255,255,255,${starAlpha})`;
    // Fixed stars (seeded)
    for (let i = 0; i < 28; i++) {
      const sx = (i*137.5 % CW);
      const sy = (i*97.3 % (CH*0.6));
      const pulse = 0.5 + Math.sin(gs.time*0.05 + i)*0.5;
      ctx.globalAlpha = starAlpha * pulse;
      ctx.beginPath(); ctx.arc(sx, sy, 1.2, 0, Math.PI*2); ctx.fill();
    }
    ctx.globalAlpha = 1;
  }
}
// â”€â”€â”€ END DAY/NIGHT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// â”€â”€â”€ END HELP MENU â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONSTANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const CW = 420, CH = 700;
const TILE = 42;
const COLS = 10;
const C = COLS; // global alias used throughout
const CAT_SPEED = 2.1;
const SCRATCH_RANGE = 92;
const DASH_SPEED = 8.5;
const DASH_FRAMES = 18;
const DASH_COOLDOWN = 90;   // 1.5s at 60fps
const HAPPY_DURATION = 480; // 8s
const HAPPY_SPEED_MULT = 1.18;

const SCRATCH_ARC = Math.PI * 1.1;
const SCRATCH_COOLDOWN = 24;

const CAT_COUNT_MULT = 1.0; // no difficulty â€” always cozy

const CAT_COLORS = [
  {body:'#fff9f0',dark:'#ffe0cc',stroke:'#ffb3a0'},
  {body:'#ffb74d',dark:'#e65100',stroke:'#bf360c'},
  {body:'#bdbdbd',dark:'#757575',stroke:'#616161'},
  {body:'#424242',dark:'#212121',stroke:'#1a1a1a'},
  {body:'#ffcc80',dark:'#ffa000',stroke:'#ff8f00'},
  {body:'#bcaaa4',dark:'#795548',stroke:'#6d4c41'},
  {body:'#f8bbd0',dark:'#f48fb1',stroke:'#e91e63'},
];
const EYE_COLORS = ['#43a047','#1e88e5','#fb8c00','#8e24aa','het'];

let catCfg = {colorIdx:0, pattern:'solid', eyeIdx:0, accessory:'none'};
let catName = 'Mochi';
let currentLevel = 0;
let unlockedLevels = 1;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CAT DRAWING (top-down)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drawCatTopDown(ctx, x, y, cfg, t=0, facingAngle=0, moving=false, scratchAnim=0) {
  const col = CAT_COLORS[cfg.colorIdx];
  const eyeCol = cfg.eyeIdx === 4 ? null : EYE_COLORS[cfg.eyeIdx];
  const bobY = moving ? Math.sin(t * 0.28) * 1.5 : 0;
  ctx.save();
  ctx.translate(x, y + bobY);
  ctx.rotate(facingAngle);

  // Tail wag
  const tailWag = Math.sin(t * 0.12) * 18;
  ctx.strokeStyle = col.body; ctx.lineWidth = 7; ctx.lineCap = 'round';
  ctx.beginPath(); ctx.moveTo(0, 10);
  ctx.quadraticCurveTo(16 + tailWag, 24, 10 + tailWag, 36); ctx.stroke();
  ctx.strokeStyle = col.stroke; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(0, 10);
  ctx.quadraticCurveTo(16 + tailWag, 24, 10 + tailWag, 36); ctx.stroke();

  // Body
  ctx.fillStyle = col.body; ctx.strokeStyle = col.stroke; ctx.lineWidth = 2.5;
  ctx.beginPath(); ctx.ellipse(0, 4, 13, 16, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke();

  // Patterns
  if (cfg.pattern === 'tabby') {
    ctx.save(); ctx.globalAlpha = 0.35; ctx.fillStyle = col.dark;
    ctx.fillRect(-5, 0, 4, 10); ctx.fillRect(1, -4, 4, 8); ctx.fillRect(-3, 8, 6, 5); ctx.restore();
  } else if (cfg.pattern === 'spots') {
    ctx.save(); ctx.globalAlpha = 0.4; ctx.fillStyle = col.dark;
    ctx.beginPath(); ctx.arc(-5, 2, 4, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(4, 10, 3, 0, Math.PI * 2); ctx.fill(); ctx.restore();
  } else if (cfg.pattern === 'tuxedo') {
    ctx.save(); ctx.fillStyle = 'white';
    ctx.beginPath(); ctx.ellipse(0, 7, 6, 9, 0, 0, Math.PI * 2); ctx.fill(); ctx.restore();
  } else if (cfg.pattern === 'calico') {
    ctx.save(); ctx.globalAlpha = 0.5;
    ctx.fillStyle = '#e65100'; ctx.beginPath(); ctx.arc(-5, 0, 5, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#212121'; ctx.beginPath(); ctx.arc(4, 8, 4, 0, Math.PI * 2); ctx.fill(); ctx.restore();
  }

  // Head
  ctx.fillStyle = col.body; ctx.strokeStyle = col.stroke; ctx.lineWidth = 2.5;
  ctx.beginPath(); ctx.arc(0, -12, 13, 0, Math.PI * 2); ctx.fill(); ctx.stroke();

  // Ears
  ctx.fillStyle = col.body; ctx.strokeStyle = col.stroke; ctx.lineWidth = 2;
  [[-8, -22], [8, -22]].forEach(([ex, ey]) => {
    ctx.beginPath(); ctx.moveTo(ex - 6, ey + 2); ctx.lineTo(ex + 6, ey + 2); ctx.lineTo(ex, ey - 11); ctx.closePath(); ctx.fill(); ctx.stroke();
  });
  ctx.fillStyle = '#f8bbd0';
  [[-8, -22], [8, -22]].forEach(([ex, ey]) => {
    ctx.beginPath(); ctx.moveTo(ex - 3.5, ey + 1); ctx.lineTo(ex + 3.5, ey + 1); ctx.lineTo(ex, ey - 7); ctx.closePath(); ctx.fill();
  });

  // Eyes
  const blink = (Math.floor(t * 0.025) % 45 === 0);
  const eyeH = blink ? 1 : 4.5;
  [[-5, -13], [5, -13]].forEach(([ex, ey], i) => {
    ctx.fillStyle = cfg.eyeIdx === 4 ? (i === 0 ? '#1e88e5' : '#fb8c00') : eyeCol;
    ctx.beginPath(); ctx.ellipse(ex, ey, 3.5, eyeH, 0, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(ex + 1, ey - 1, 1.2, 0, Math.PI * 2); ctx.fill();
  });

  // Nose + mouth
  ctx.fillStyle = '#f48fb1'; ctx.beginPath(); ctx.arc(0, -9, 2.5, 0, Math.PI * 2); ctx.fill();
  ctx.strokeStyle = '#f48fb1'; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.moveTo(0, -7); ctx.lineTo(-3, -5); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(0, -7); ctx.lineTo(3, -5); ctx.stroke();

  // Whiskers
  ctx.strokeStyle = 'rgba(150,120,110,0.5)'; ctx.lineWidth = 1;
  [[-14, -10], [-18, -9], [-14, -8]].forEach(([wx, wy]) => { ctx.beginPath(); ctx.moveTo(-2, -9); ctx.lineTo(wx, wy); ctx.stroke(); });
  [[14, -10], [18, -9], [14, -8]].forEach(([wx, wy]) => { ctx.beginPath(); ctx.moveTo(2, -9); ctx.lineTo(wx, wy); ctx.stroke(); });

  // Blush
  ctx.fillStyle = 'rgba(255,140,140,0.2)';
  ctx.beginPath(); ctx.ellipse(-7, -11, 4, 2.5, 0, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(7, -11, 4, 2.5, 0, 0, Math.PI * 2); ctx.fill();

  // Scratch animation â€” claw arc in front
  if (scratchAnim > 0) {
    const progress = 1 - scratchAnim / SCRATCH_COOLDOWN;
    ctx.save();
    ctx.globalAlpha = (1 - progress) * 0.85;
    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2.5; ctx.lineCap = 'round';
    const sweepAngle = SCRATCH_ARC * progress;
    for (let ci = 0; ci < 3; ci++) {
      const off = (ci - 1) * 0.28;
      ctx.beginPath();
      ctx.arc(0, -12, 28 + ci * 7, -Math.PI / 2 - SCRATCH_ARC / 2 + off,
              -Math.PI / 2 - SCRATCH_ARC / 2 + sweepAngle + off);
      ctx.stroke();
    }
    // Claw sparks
    ctx.fillStyle = '#ffe082';
    for (let ci = 0; ci < 4; ci++) {
      const sa = -Math.PI / 2 - SCRATCH_ARC / 2 + sweepAngle + (ci - 1.5) * 0.2;
      const r = 34 + ci * 4;
      ctx.beginPath(); ctx.arc(Math.cos(sa) * r, -12 + Math.sin(sa) * r, 2.5, 0, Math.PI * 2); ctx.fill();
    }
    ctx.restore();
  }

  drawAccessory(ctx, cfg.accessory, t);
  ctx.restore();
}

function drawAccessory(ctx, acc, t) {
  if (acc === 'none') return;
  if (acc === 'bow') {
    ctx.fillStyle = '#f44336'; ctx.strokeStyle = '#b71c1c'; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(0, -24); ctx.bezierCurveTo(-8, -30, -12, -22, -6, -20); ctx.bezierCurveTo(-2, -18, 0, -22, 0, -24); ctx.fill(); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0, -24); ctx.bezierCurveTo(8, -30, 12, -22, 6, -20); ctx.bezierCurveTo(2, -18, 0, -22, 0, -24); ctx.fill(); ctx.stroke();
    ctx.fillStyle = '#ffcdd2'; ctx.beginPath(); ctx.arc(0, -24, 3, 0, Math.PI * 2); ctx.fill();
  } else if (acc === 'flower') {
    for (let i = 0; i < 6; i++) {
      const a = i / 6 * Math.PI * 2;
      ctx.fillStyle = i % 2 === 0 ? '#f48fb1' : '#fff';
      ctx.beginPath(); ctx.ellipse(Math.cos(a) * 6, Math.sin(a) * 6 - 24, 3.5, 3.5, a, 0, Math.PI * 2); ctx.fill();
    }
    ctx.fillStyle = '#ffe082'; ctx.beginPath(); ctx.arc(0, -24, 3.5, 0, Math.PI * 2); ctx.fill();
  } else if (acc === 'hat') {
    ctx.fillStyle = '#212121'; ctx.strokeStyle = '#424242'; ctx.lineWidth = 1.5;
    ctx.fillRect(-9, -34, 18, 10); ctx.stroke();
    ctx.fillRect(-12, -35, 24, 4); ctx.stroke();
    ctx.fillStyle = '#f48fb1'; ctx.fillRect(-9, -33, 18, 3);
  } else if (acc === 'stars') {
    const st = t * 0.05;
    [[-10, -24], [10, -24], [0, -28]].forEach(([sx, sy], i) => {
      const p = 0.8 + Math.sin(st + i) * 0.3;
      ctx.save(); ctx.translate(sx, sy); ctx.scale(p, p);
      ctx.fillStyle = ['#ffd700', '#ff6b9d', '#64dfdf'][i];
      drawStar(ctx, 0, 0, 4, 2); ctx.restore();
    });
  } else if (acc === 'crown') {
    ctx.fillStyle = '#ffd700'; ctx.strokeStyle = '#ff8f00'; ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(-10, -26); ctx.lineTo(-10, -34); ctx.lineTo(-6, -30);
    ctx.lineTo(0, -36); ctx.lineTo(6, -30); ctx.lineTo(10, -34); ctx.lineTo(10, -26); ctx.closePath();
    ctx.fill(); ctx.stroke();
    ['#e53935', '#1e88e5', '#43a047'].forEach((c, i) => {
      ctx.fillStyle = c; ctx.beginPath(); ctx.arc(-5 + i * 5, -28, 1.8, 0, Math.PI * 2); ctx.fill();
    });
  }
}

function drawStar(ctx, cx, cy, r1, r2) {
  ctx.beginPath();
  for (let i = 0; i < 10; i++) {
    const a = i / 10 * Math.PI * 2 - Math.PI / 2;
    const r = i % 2 === 0 ? r1 : r2;
    i === 0 ? ctx.moveTo(cx + Math.cos(a) * r, cy + Math.sin(a) * r)
            : ctx.lineTo(cx + Math.cos(a) * r, cy + Math.sin(a) * r);
  }
  ctx.closePath(); ctx.fill();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UI
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let previewAnimId = null;

function updatePreview() {
  clearTimeout(updatePreview._t);
  updatePreview._t = setTimeout(() => {
    renderCatPreview('previewCanvas', 90, 90);
    renderCatPreview('titleCatCanvas', 130, 130);
  }, 16);
}

function renderCatPreview(id, w, h) {
  const c = document.getElementById(id); if (!c) return;
  const cx = c.getContext('2d');
  cx.clearRect(0, 0, w, h);
  drawCatTopDown(cx, w / 2, h / 2 + 8, catCfg, Date.now() * 0.016, 0, false, 0);
}

function setCatProp(prop, val) {
  catCfg[prop] = val;
  if (prop === 'colorIdx') document.querySelectorAll('#color-swatches .swatch').forEach(s => s.classList.toggle('selected', +s.dataset.idx === val));
  else if (prop === 'eyeIdx') document.querySelectorAll('#eye-swatches .swatch').forEach(s => s.classList.toggle('selected', +s.dataset.idx === val));
  else if (prop === 'pattern') document.querySelectorAll('#pattern-opts .opt-btn').forEach(s => s.classList.toggle('selected', s.dataset.val === val));
  else if (prop === 'accessory') document.querySelectorAll('#acc-opts .opt-btn').forEach(s => s.classList.toggle('selected', s.dataset.val === val));
  updatePreview();
}


function showScreen(id) {
  document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
  const el = document.getElementById(id); if (el) el.classList.remove('hidden');
  document.getElementById('hud').style.display = 'none';
  document.getElementById('game-canvas-wrap').style.display = 'none';
  if (id === 'custom-screen') { updatePreview(); startPreviewAnim(); }
  else if (id === 'title-screen') startPreviewAnim();
  else stopPreviewAnim();
}

function startPreviewAnim() {
  stopPreviewAnim();
  if (musicEnabled && !musicPlaying) startMusic();
  function frame() {
    renderCatPreview('previewCanvas', 90, 90);
    renderCatPreview('titleCatCanvas', 130, 130);
    previewAnimId = requestAnimationFrame(frame);
  }
  previewAnimId = requestAnimationFrame(frame);
}
function stopPreviewAnim() { if (previewAnimId) { cancelAnimationFrame(previewAnimId); previewAnimId = null; } }

function quickPlay() { goLevelSelect(); }
function goLevelSelect() {
  if(soccerRaf){cancelAnimationFrame(soccerRaf);soccerRaf=null;} soccerState=null;
  catName = document.getElementById('cat-name-input').value.trim() || 'Mochi';
  updateLevelCards(); showScreen('level-screen');
}
function updateLevelCards() {
  for (let i = 0; i < 5; i++) {
    const el = document.getElementById('lc-' + i); if (!el) continue;
    const unlocked = i < unlockedLevels;
    el.classList.toggle('locked', !unlocked); el.classList.toggle('unlocked', unlocked);
    el.onclick = unlocked ? () => beginLevel(i) : null;
  }
  const el0 = document.getElementById('lc-0');
  if (el0) { el0.classList.remove('locked'); el0.classList.add('unlocked'); el0.onclick = () => beginLevel(0); }
  const el4 = document.getElementById('lc-4');
  if (el4) { el4.classList.remove('locked'); el4.classList.add('unlocked'); el4.onclick = () => beginLevel(4); }
}
function quickPlay() { catName = document.getElementById('cat-name-input')?.value.trim() || 'Mochi'; updateLevelCards(); showScreen('level-screen'); }
function retryLevel() { if(soccerRaf){cancelAnimationFrame(soccerRaf);soccerRaf=null;} beginLevel(currentLevel); }
function nextLevel() { if (currentLevel + 1 < 5) beginLevel(currentLevel + 1); else goLevelSelect(); }


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// âš½ CAT SOCCER â€” LEVEL 4
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Field dimensions (in pixels, no tile system â€” rendered directly)
const SF = {
  W: 420, H: 660,        // full canvas
  FX: 30, FY: 60,        // field left/top
  FW: 360, FH: 520,      // field width/height
  GW: 90, GD: 22,        // goal width, goal depth
  GOALS_TO_WIN: 7,
};
// Derived
SF.GX = SF.FX + SF.FW/2 - SF.GW/2; // goal X (centred)
SF.TOP_GY    = SF.FY - SF.GD;       // top goal Y
SF.BOTTOM_GY = SF.FY + SF.FH;       // bottom goal mouth Y

let soccerState = null; // null = not playing soccer

function beginSoccer() {
  stopMusic();
  currentLevel = 4;
  document.getElementById('hud').style.display = 'block';
  document.getElementById('game-canvas-wrap').style.display = 'block';
  document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));

  const catColors = [2, 1, 3, 6, 4]; // grey, orange, black, pink, cream
  soccerState = {
    running: false,  // starts paused until kickoff button
    kickedOff: false,
    time: 0,
    playerScore: 0,
    aiScore: 0,
    celebration: 0,       // countdown after a goal
    celebrationMsg: '',
    celebrationColor: '',
    winner: null,          // 'player' | 'ai' | null
    lastScorer: null,

    ball: {
      x: SF.FX + SF.FW/2,
      y: SF.FY + SF.FH/2,
      vx: 0, vy: 0,
      r: 11,
    },

    // Player cat
    player: {
      x: SF.FX + SF.FW/2,
      y: SF.FY + SF.FH * 0.78,
      vx: 0, vy: 0,
      r: 14,
      facingAngle: Math.PI,
      moving: false,
      dashFrames: 0, dashCooldown: 0, dashDx: 0, dashDy: 0,
      cfg: { colorIdx: catCfg.colorIdx, pattern: catCfg.pattern, eyeIdx: catCfg.eyeIdx, accessory: catCfg.accessory },
      isPlayer: true,
    },

    // Single opponent cat â€” roams whole field
    aiCats: [
      { x: SF.FX + SF.FW*0.5, y: SF.FY + SF.FH*0.22, vx:0, vy:0, r:14,
        facingAngle:0, moving:false, dashFrames:0, dashCooldown:0,
        cfg:{colorIdx:1,pattern:'tabby',eyeIdx:2,accessory:'none'},
        role:'roamer', thinkTimer:0, name:'Mikan', team:'enemy' },
    ],
    teammate: null,

    particles: [],
    joystick: {active:false, dx:0, dy:0},
    scratchPressed: false,
  };

  if (musicEnabled) startMusic();
  if (raf) cancelAnimationFrame(raf);
  soccerLoop();
}

function resetSoccerPositions(scoredTeam) {
  const ss = soccerState;
  ss.ball.x = SF.FX + SF.FW/2;
  ss.ball.y = SF.FY + SF.FH/2;
  ss.ball.vx = (Math.random()-0.5)*1.5;
  ss.ball.vy = scoredTeam === 'player' ? -1.5 : 1.5;

  ss.player.x = SF.FX + SF.FW/2;
  ss.player.y = SF.FY + SF.FH*0.78;
  ss.player.vx = ss.player.vy = 0;
  ss.player.dashFrames = 0;

  const ai0 = ss.aiCats[0];
  ai0.x = SF.FX+SF.FW*0.5; ai0.y = SF.FY+SF.FH*0.22;
  ai0.vx = ai0.vy = 0; ai0.dashFrames = 0;
  // Pause for kickoff button after each goal
  ss.running = false;
  ss.kickedOff = false;
}

// â”€â”€ Soccer physics update â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateSoccer() {
  const ss = soccerState;
  if (!ss || !ss.running) return;
  ss.time++;

  // Kickoff pause â€” wait for button press
  if (!ss.running) return;

  // Celebration pause after goal
  if (ss.celebration > 0) {
    ss.celebration--;
    if (ss.celebration === 0) {
      if (ss.winner) { endSoccer(); return; }
      resetSoccerPositions(ss.lastScorer);
    }
    updateSoccerParticles();
    return;
  }

  // â”€â”€ Player input â”€â”€
  const p = ss.player;
  let ix=0, iy=0;
  if (keys['ArrowLeft']||keys['KeyA']) ix-=1;
  if (keys['ArrowRight']||keys['KeyD']) ix+=1;
  if (keys['ArrowUp']||keys['KeyW']) iy-=1;
  if (keys['ArrowDown']||keys['KeyS']) iy+=1;
  if (ss.joystick.active) { ix+=ss.joystick.dx; iy+=ss.joystick.dy; }
  const ilen = Math.hypot(ix,iy); if (ilen>1){ix/=ilen;iy/=ilen;}
  p.moving = ilen>0.1;

  const PLAYER_SPEED = 3.2;
  if (p.dashFrames > 0) {
    p.dashFrames--;
    p.x += p.dashDx * 8.5;
    p.y += p.dashDy * 8.5;
  } else {
    p.x += ix * PLAYER_SPEED;
    p.y += iy * PLAYER_SPEED;
  }
  if (p.dashCooldown > 0) p.dashCooldown--;
  if (p.moving) p.facingAngle = Math.atan2(iy,ix)+Math.PI/2;

  // Clamp player to full field
  p.x = Math.max(SF.FX+p.r, Math.min(SF.FX+SF.FW-p.r, p.x));
  p.y = Math.max(SF.FY+p.r, Math.min(SF.FY+SF.FH-p.r, p.y));

  // â”€â”€ AI cats â”€â”€
  ss.aiCats.forEach(ai => updateSoccerAI(ai, ss));

  // â”€â”€ Ball physics â”€â”€
  const b = ss.ball;
  const FRICTION = 0.991;
  b.x += b.vx; b.y += b.vy;
  b.vx *= FRICTION; b.vy *= FRICTION;

  // Ball wall bounce (field edges, excluding goals)
  // Left/right walls
  if (b.x - b.r < SF.FX)  { b.x = SF.FX+b.r;         b.vx = Math.abs(b.vx)*0.92; playSoccerBounce(); }
  if (b.x + b.r > SF.FX+SF.FW) { b.x = SF.FX+SF.FW-b.r; b.vx = -Math.abs(b.vx)*0.92; playSoccerBounce(); }

  // Top wall â€” but allow through goal opening
  if (b.y - b.r < SF.FY) {
    const inGoal = b.x > SF.GX && b.x < SF.GX+SF.GW;
    if (inGoal) {
      // GOAL for player!
      if (b.y - b.r < SF.TOP_GY - b.r) {
        soccerGoal('player');
        return;
      }
    } else {
      b.y = SF.FY+b.r; b.vy = Math.abs(b.vy)*0.92; playSoccerBounce();
    }
  }
  // Bottom wall â€” allow through goal opening
  if (b.y + b.r > SF.FY+SF.FH) {
    const inGoal = b.x > SF.GX && b.x < SF.GX+SF.GW;
    if (inGoal) {
      if (b.y + b.r > SF.BOTTOM_GY + SF.GD + b.r) {
        soccerGoal('ai');
        return;
      }
    } else {
      b.y = SF.FY+SF.FH-b.r; b.vy = -Math.abs(b.vy)*0.92; playSoccerBounce();
    }
  }

  // â”€â”€ Ball-cat collisions â”€â”€
  [p, ...ss.aiCats].forEach(cat => {
    const dx = b.x-cat.x, dy = b.y-cat.y;
    const dist = Math.hypot(dx,dy);
    const minDist = b.r + cat.r;
    if (dist < minDist && dist > 0.1) {
      const nx = dx/dist, ny = dy/dist;
      b.x = cat.x + nx*minDist;
      b.y = cat.y + ny*minDist;
      const isDashing = cat.dashFrames > 0 || cat.justDashed;
      const catSpd = cat.isPlayer ? Math.hypot(ix,iy)*PLAYER_SPEED : Math.hypot(cat.vx,cat.vy);
      const kickPow = isDashing ? 15 : catSpd*0.8 + 2.5;
      const existingDot = b.vx*nx + b.vy*ny;
      if (existingDot < kickPow) {
        b.vx += (kickPow - existingDot) * nx;
        b.vy += (kickPow - existingDot) * ny;
      }
      playSoccerKick();
    }
    // Clear justDashed after collision check so it lasts exactly one frame
    cat.justDashed = false;
  });

  // Speed cap on ball
  const bspd = Math.hypot(b.vx,b.vy);
  if (bspd > 22) { b.vx = b.vx/bspd*22; b.vy = b.vy/bspd*22; }

  updateSoccerParticles();
}

function updateSoccerAI(ai, ss) {
  // Smart AI: positions BEHIND the ball relative to player goal, then kicks
  const b = ss.ball;
  const AI_SPEED = 2.5;

  // Player goal is at the BOTTOM â€” so AI wants to be north of the ball
  // to kick it southward into the goal.
  const GOAL_GX = SF.FX + SF.FW/2;   // goal centre x
  const GOAL_GY = SF.FY + SF.FH;     // goal mouth y (bottom)

  // Vector from ball toward player goal
  const toBallGoalDx = GOAL_GX - b.x;
  const toBallGoalDy = GOAL_GY - b.y;
  const toBallGoalLen = Math.hypot(toBallGoalDx, toBallGoalDy) || 1;
  const toBallGoalNx = toBallGoalDx / toBallGoalLen;
  const toBallGoalNy = toBallGoalDy / toBallGoalLen;

  // Ideal approach position: stand 32px BEHIND the ball (opposite to goal)
  const APPROACH_DIST = 34;
  const approachX = b.x - toBallGoalNx * APPROACH_DIST;
  const approachY = b.y - toBallGoalNy * APPROACH_DIST;

  const bdist = Math.hypot(b.x - ai.x, b.y - ai.y);
  const approachDist = Math.hypot(approachX - ai.x, approachY - ai.y);

  let targetX, targetY;

  if (approachDist > 20 && bdist > 40) {
    // Far from ball â€” move toward approach position
    targetX = approachX;
    targetY = approachY;
  } else if (approachDist > 12) {
    // Getting close â€” blend between approach pos and ball
    const t = 1 - approachDist / 20;
    targetX = approachX * (1-t) + b.x * t;
    targetY = approachY * (1-t) + b.y * t;
  } else {
    // In position â€” drive through the ball toward goal
    targetX = GOAL_GX;
    targetY = GOAL_GY;
  }

  moveSoccerCat(ai, targetX, targetY, AI_SPEED);

  // Dash kick: only when well-positioned behind ball (approach dist small)
  // and lined up toward goal
  if (bdist < 36 && approachDist < 28 && ai.dashCooldown === 0) {
    // Kick direction: from AI toward goal (not from AI toward ball centre)
    const kdx = GOAL_GX - ai.x;
    const kdy = GOAL_GY - ai.y;
    const klen = Math.hypot(kdx, kdy) || 1;
    ai.dashDx = kdx / klen;
    ai.dashDy = kdy / klen;
    ai.dashFrames = 10;
    ai.dashCooldown = 90;
    ai.justDashed = true;
  }
  applyDash(ai);

  // Clamp to full field
  ai.x = Math.max(SF.FX + ai.r, Math.min(SF.FX + SF.FW - ai.r, ai.x));
  ai.y = Math.max(SF.FY + ai.r, Math.min(SF.FY + SF.FH - ai.r, ai.y));
}


function moveSoccerCat(cat, targetX, targetY, speed) {
  const dx = targetX-cat.x, dy = targetY-cat.y;
  const dist = Math.hypot(dx,dy);
  if (dist > 5) {
    const nx=dx/dist, ny=dy/dist;
    cat.vx=nx*speed; cat.vy=ny*speed;
    cat.x+=cat.vx; cat.y+=cat.vy;
    cat.facingAngle=Math.atan2(ny,nx)+Math.PI/2;
    cat.moving=true;
  } else {
    cat.moving=false;
  }
}

function applyDash(cat) {
  if (cat.dashFrames > 0) {
    cat.dashFrames--;
    cat.x += cat.dashDx*7; cat.y += cat.dashDy*7;
  }
  if (cat.dashCooldown > 0) cat.dashCooldown--;
}

function soccerGoal(scorer) {
  const ss = soccerState;
  ss.ball.vx = ss.ball.vy = 0;

  if (scorer === 'player') {
    ss.playerScore++;
    ss.celebrationMsg = `âš½ GOAL! ${ss.playerScore}â€“${ss.aiScore}`;
    ss.celebrationColor = '#4caf50';
    spawnSoccerParticles(ss.ball.x, ss.ball.y, ['âš½','ğŸ‰','âœ¨','ğŸ’š','â­']);
    playSoccerGoal();
  } else {
    ss.aiScore++;
    ss.celebrationMsg = `ğŸ˜¿ They scored! ${ss.playerScore}â€“${ss.aiScore}`;
    ss.celebrationColor = '#ef5350';
    spawnSoccerParticles(ss.ball.x, ss.ball.y, ['ğŸ˜¹','âš½','ğŸ’¨']);
    playSoccerGoal(false);
  }
  ss.lastScorer = scorer;
  ss.celebration = 120;

  // Check win condition
  if (ss.playerScore >= SF.GOALS_TO_WIN) { ss.winner = 'player'; ss.celebration = 160; }
  else if (ss.aiScore >= SF.GOALS_TO_WIN) { ss.winner = 'ai';     ss.celebration = 160; }
}

function endSoccer() {
  const ss = soccerState;
  ss.running = false;
  stopMusic();
  if (ss.winner === 'player') {
    // Use level complete screen
    document.getElementById('lc-emoji').textContent = 'ğŸ†';
    document.getElementById('lc-title').textContent = 'You Win! ğŸ±âš½';
    document.getElementById('lc-desc').textContent = `${catName} beat Mikan ${ss.playerScore}â€“${ss.aiScore}! Purrfect!`;
    document.getElementById('lc-next-btn').style.display = 'none';
    document.getElementById('hud').style.display='none';
    document.getElementById('game-canvas-wrap').style.display='none';
    showScreen('levelcomplete-screen');
    spawnSoccerParticles(SF.FX+SF.FW/2, SF.FY+SF.FH/2, ['ğŸ†','âš½','ğŸ‰','âœ¨','ğŸŒŸ','ğŸ’›']);
  } else {
    document.getElementById('go-name').textContent = `Final score: ${ss.playerScore}â€“${ss.aiScore} ğŸ˜¿`;
    document.getElementById('hud').style.display='none';
    document.getElementById('game-canvas-wrap').style.display='none';
    showScreen('gameover-screen');
  }
}

// â”€â”€ Soccer sounds â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function playSoccerKick() {
  try {
    const ac = getAudio(), t = ac.currentTime;
    const o = ac.createOscillator(), g = ac.createGain();
    o.type='square'; o.frequency.setValueAtTime(180,t); o.frequency.exponentialRampToValueAtTime(90,t+0.07);
    g.gain.setValueAtTime(0.12,t); g.gain.exponentialRampToValueAtTime(0.001,t+0.09);
    o.connect(g); g.connect(ac.destination); o.start(t); o.stop(t+0.1);
  } catch(e){}
}
function playSoccerBounce() {
  try {
    const ac = getAudio(), t = ac.currentTime;
    const o = ac.createOscillator(), g = ac.createGain();
    o.type='sine'; o.frequency.setValueAtTime(300,t); o.frequency.exponentialRampToValueAtTime(180,t+0.06);
    g.gain.setValueAtTime(0.08,t); g.gain.exponentialRampToValueAtTime(0.001,t+0.07);
    o.connect(g); g.connect(ac.destination); o.start(t); o.stop(t+0.08);
  } catch(e){}
}
function playSoccerGoal(isPlayer=true) {
  try {
    const ac = getAudio(), t = ac.currentTime;
    const notes = isPlayer ? [523,659,784,1047] : [392,330,262];
    notes.forEach((freq,i) => {
      const o = ac.createOscillator(), g = ac.createGain();
      o.type='triangle'; o.frequency.value=freq;
      g.gain.setValueAtTime(0,t+i*0.12); g.gain.linearRampToValueAtTime(0.18,t+i*0.12+0.04);
      g.gain.exponentialRampToValueAtTime(0.001,t+i*0.12+0.4);
      o.connect(g); g.connect(ac.destination); o.start(t+i*0.12); o.stop(t+i*0.12+0.45);
    });
  } catch(e){}
}

// â”€â”€ Soccer particles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnSoccerParticles(x, y, emojis) {
  if (!soccerState) return;
  for (let i=0; i<12; i++) {
    const a = Math.random()*Math.PI*2;
    const spd = 2+Math.random()*5;
    soccerState.particles.push({
      x, y, vx:Math.cos(a)*spd, vy:Math.sin(a)*spd,
      emoji: emojis[Math.floor(Math.random()*emojis.length)],
      life:1, size:16+Math.random()*10,
    });
  }
}
function updateSoccerParticles() {
  if (!soccerState) return;
  soccerState.particles = soccerState.particles.filter(p=>p.life>0);
  for (const p of soccerState.particles) {
    p.x+=p.vx; p.y+=p.vy; p.vy+=0.12; p.life-=0.022;
  }
}

// â”€â”€ Soccer render â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderSoccer() {
  if (!soccerState) return;
  const ss = soccerState;
  const t = ss.time;
  ctx.clearRect(0,0,CW,CH);

  // â”€â”€ Pitch â”€â”€
  // Grass background
  ctx.fillStyle='#388e3c';
  ctx.fillRect(0,0,CW,CH);

  // Grass stripes
  for (let s=0; s<6; s++) {
    ctx.fillStyle = s%2===0 ? 'rgba(0,0,0,0.04)' : 'rgba(255,255,255,0.04)';
    ctx.fillRect(SF.FX, SF.FY + s*(SF.FH/6), SF.FW, SF.FH/6);
  }

  // Field border
  ctx.strokeStyle='rgba(255,255,255,0.9)'; ctx.lineWidth=3;
  ctx.strokeRect(SF.FX, SF.FY, SF.FW, SF.FH);

  // Centre line
  ctx.beginPath(); ctx.moveTo(SF.FX, SF.FY+SF.FH/2); ctx.lineTo(SF.FX+SF.FW, SF.FY+SF.FH/2); ctx.stroke();

  // Centre circle
  ctx.beginPath(); ctx.arc(SF.FX+SF.FW/2, SF.FY+SF.FH/2, 46, 0, Math.PI*2); ctx.stroke();
  ctx.fillStyle='rgba(255,255,255,0.08)'; ctx.fill();

  // Centre dot
  ctx.fillStyle='rgba(255,255,255,0.8)';
  ctx.beginPath(); ctx.arc(SF.FX+SF.FW/2, SF.FY+SF.FH/2, 4, 0, Math.PI*2); ctx.fill();

  // Penalty arcs (top and bottom)
  ctx.strokeStyle='rgba(255,255,255,0.6)'; ctx.lineWidth=2;
  ctx.fillStyle='rgba(255,255,255,0.04)';
  // Top penalty box
  ctx.beginPath(); ctx.rect(SF.FX+SF.FW*0.25, SF.FY, SF.FW*0.5, SF.FH*0.16); ctx.fill(); ctx.stroke();
  // Bottom penalty box
  ctx.beginPath(); ctx.rect(SF.FX+SF.FW*0.25, SF.FY+SF.FH*0.84, SF.FW*0.5, SF.FH*0.16); ctx.fill(); ctx.stroke();

  // â”€â”€ Goals â”€â”€
  // Top goal (AI scores here â†’ bad, player attacks here)
  drawSoccerGoal(SF.GX, SF.TOP_GY, SF.GW, SF.GD, '#ef5350', true);
  // Bottom goal (AI scores in player's goal)
  drawSoccerGoal(SF.GX, SF.BOTTOM_GY, SF.GW, SF.GD, '#4caf50', false);

  // Goal labels
  ctx.font='bold 11px Nunito,sans-serif'; ctx.textAlign='center';
  ctx.fillStyle='rgba(255,255,255,0.7)';
  ctx.fillText('ğŸ¯ Attack!', SF.FX+SF.FW/2, SF.FY-SF.GD-8);
  ctx.fillStyle='rgba(255,255,255,0.5)';
  ctx.fillText('ğŸ›¡ï¸ Defend!', SF.FX+SF.FW/2, SF.BOTTOM_GY+SF.GD+18);

  // â”€â”€ Opponent cat â”€â”€
  for (const ai of ss.aiCats) {
    drawCatTopDown(ctx, ai.x, ai.y, ai.cfg, t, ai.facingAngle, ai.moving, 0);
    drawSoccerNameTag(ai.x, ai.y, ai.name, '#ef9a9a');
  }



  // â”€â”€ Player cat â”€â”€
  const p = ss.player;
  // Rainbow glow during dash
  if (p.dashFrames > 0) {
    for (let i=0;i<3;i++) {
      const hue = (t*4+i*120)%360;
      ctx.save(); ctx.globalAlpha=0.35; ctx.strokeStyle=`hsl(${hue},100%,60%)`;
      ctx.lineWidth=3; ctx.beginPath(); ctx.arc(p.x,p.y,20+i*5,0,Math.PI*2); ctx.stroke(); ctx.restore();
    }
  }
  drawCatTopDown(ctx, p.x, p.y, p.cfg, t, p.facingAngle, p.moving, 0);

  // â”€â”€ Ball â”€â”€
  const b = ss.ball;
  const ballSpd = Math.hypot(b.vx,b.vy);
  // Shadow
  ctx.fillStyle='rgba(0,0,0,0.2)';
  ctx.beginPath(); ctx.ellipse(b.x+3, b.y+4, b.r*0.85, b.r*0.5, 0, 0, Math.PI*2); ctx.fill();
  // Ball glow when moving fast
  if (ballSpd > 5) {
    ctx.save(); ctx.globalAlpha=0.3;
    ctx.fillStyle='rgba(255,255,100,0.5)';
    ctx.beginPath(); ctx.arc(b.x, b.y, b.r+5, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }
  // Ball spin indicator
  const spinAngle = (b.x + b.y) * 0.06;
  ctx.save(); ctx.translate(b.x, b.y); ctx.rotate(spinAngle);
  // White ball base
  ctx.fillStyle='white'; ctx.shadowColor='rgba(0,0,0,0.3)'; ctx.shadowBlur=4;
  ctx.beginPath(); ctx.arc(0,0,b.r,0,Math.PI*2); ctx.fill();
  ctx.shadowBlur=0;
  // Classic soccer pattern (pentagons approximated)
  ctx.fillStyle='#222';
  const pts=[[0,-7],[6,5],[-6,5]]; // simple 3-point star pattern
  ctx.beginPath();
  for(const [px2,py2] of pts){
    ctx.moveTo(px2,py2); ctx.arc(px2,py2,2.8,0,Math.PI*2);
  }
  ctx.fill();
  ctx.restore();

  // â”€â”€ Particles â”€â”€
  for (const p2 of ss.particles) {
    ctx.save(); ctx.globalAlpha=p2.life;
    ctx.font=p2.size+'px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(p2.emoji, p2.x, p2.y); ctx.restore();
  }

  // â”€â”€ Scoreboard â”€â”€
  drawSoccerHUD(ss, t);

  // â”€â”€ Celebration overlay â”€â”€
  if (ss.celebration > 0 && !ss.winner) {
    const alpha = Math.min(1, ss.celebration/30) * Math.min(1, ss.celebration/30);
    ctx.save(); ctx.globalAlpha=alpha*0.85;
    ctx.fillStyle='rgba(0,0,0,0.45)'; ctx.fillRect(0,0,CW,CH);
    ctx.globalAlpha=alpha;
    ctx.font='bold 28px Nunito,sans-serif'; ctx.textAlign='center';
    ctx.fillStyle=ss.celebrationColor;
    ctx.shadowColor='rgba(0,0,0,0.6)'; ctx.shadowBlur=12;
    ctx.fillText(ss.celebrationMsg, CW/2, CH/2);
    ctx.restore();
  }

  // â”€â”€ Winner overlay â”€â”€
  if (ss.winner && ss.celebration > 0) {
    const alpha = Math.min(1, (160-ss.celebration)/30);
    ctx.save(); ctx.globalAlpha=alpha;
    ctx.fillStyle='rgba(0,0,0,0.55)'; ctx.fillRect(0,0,CW,CH);
    ctx.font='bold 34px Nunito,sans-serif'; ctx.textAlign='center';
    ctx.fillStyle = ss.winner==='player' ? '#ffd700' : '#ef9a9a';
    ctx.shadowColor='rgba(0,0,0,0.7)'; ctx.shadowBlur=16;
    ctx.fillText(ss.winner==='player' ? 'ğŸ† You Win!' : 'ğŸ˜¿ They Win!', CW/2, CH/2-20);
    ctx.font='18px Nunito,sans-serif';
    ctx.fillStyle='white'; ctx.shadowBlur=8;
    ctx.fillText(`${ss.playerScore} â€“ ${ss.aiScore}`, CW/2, CH/2+24);
    ctx.restore();
  }

  // â”€â”€ Kickoff overlay â”€â”€
  if (!ss.running && !ss.winner) {
    const isFirst = ss.playerScore === 0 && ss.aiScore === 0;
    // Dim
    ctx.fillStyle = 'rgba(0,0,0,0.52)';
    ctx.fillRect(0, 0, CW, CH);
    // Card
    const cw = 240, ch = isFirst ? 170 : 130;
    const cx2 = (CW-cw)/2, cy2 = (CH-ch)/2 - 20;
    ctx.fillStyle = '#fff9f0';
    ctx.beginPath(); ctx.roundRect(cx2, cy2, cw, ch, 14); ctx.fill();
    ctx.strokeStyle = '#d4a574'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.roundRect(cx2, cy2, cw, ch, 14); ctx.stroke();
    // Emoji + title
    ctx.textAlign = 'center';
    if (isFirst) {
      ctx.font = '32px serif'; ctx.fillText('âš½', CW/2, cy2+44);
      ctx.font = 'bold 16px Nunito,sans-serif'; ctx.fillStyle = '#5d3a1a';
      ctx.fillText('Cat Soccer!', CW/2, cy2+70);
      ctx.font = '10px Nunito,sans-serif'; ctx.fillStyle = '#a08060';
      ctx.fillText('Dash toward the ball to kick hard', CW/2, cy2+90);
      ctx.fillText(`Score ${SF.GOALS_TO_WIN} goals to win`, CW/2, cy2+106);
    } else {
      const lastMsg = ss.lastScorer === 'player'
        ? `âš½ You scored! ${ss.playerScore}â€“${ss.aiScore}`
        : `ğŸ˜¿ Mikan scored! ${ss.playerScore}â€“${ss.aiScore}`;
      ctx.font = 'bold 14px Nunito,sans-serif'; ctx.fillStyle = '#5d3a1a';
      ctx.fillText(lastMsg, CW/2, cy2+44);
      ctx.font = '10px Nunito,sans-serif'; ctx.fillStyle = '#a08060';
      ctx.fillText('Positions reset â€” ready?', CW/2, cy2+64);
    }
    // Kickoff button
    const btnW = 140, btnH = 36;
    const btnX = (CW-btnW)/2, btnY = cy2+ch-52;
    const pulse = 0.85 + Math.sin(ss.time*0.12)*0.15;
    ctx.save(); ctx.translate(CW/2, btnY+btnH/2); ctx.scale(pulse,pulse); ctx.translate(-CW/2, -(btnY+btnH/2));
    ctx.fillStyle = '#66bb6a';
    ctx.beginPath(); ctx.roundRect(btnX, btnY, btnW, btnH, 10); ctx.fill();
    ctx.strokeStyle = '#43a047'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.roundRect(btnX, btnY, btnW, btnH, 10); ctx.stroke();
    ctx.font = 'bold 14px Nunito,sans-serif'; ctx.fillStyle = 'white';
    ctx.fillText(isFirst ? 'ğŸŸ¢ Kick Off!' : 'ğŸŸ¢ Play!', CW/2, btnY+24);
    ctx.restore();
    // Store button bounds for click detection
    renderSoccer._kickBtnY = btnY; renderSoccer._kickBtnH = btnH;
    renderSoccer._kickBtnX = btnX; renderSoccer._kickBtnW = btnW;
  }

  drawPhotoFlash();
  drawHelp(t);
}

function drawSoccerNameTag(x, y, name, color) {
  ctx.save();
  ctx.fillStyle=color+'cc';
  ctx.beginPath(); ctx.roundRect(x-16, y-30, 32, 13, 3); ctx.fill();
  ctx.font='bold 8px Nunito,sans-serif'; ctx.textAlign='center';
  ctx.fillStyle='white';
  ctx.fillText(name, x, y-20);
  ctx.restore();
}

function drawSoccerGoal(gx, gy, gw, gd, color, isTop) {
  // Goal frame
  ctx.strokeStyle=color; ctx.lineWidth=4;
  ctx.fillStyle=`${color}22`;
  if (isTop) {
    ctx.beginPath();
    ctx.moveTo(gx, gy+gd);
    ctx.lineTo(gx, gy);
    ctx.lineTo(gx+gw, gy);
    ctx.lineTo(gx+gw, gy+gd);
    ctx.closePath(); ctx.fill(); ctx.stroke();
  } else {
    ctx.beginPath();
    ctx.moveTo(gx, gy);
    ctx.lineTo(gx, gy+gd);
    ctx.lineTo(gx+gw, gy+gd);
    ctx.lineTo(gx+gw, gy);
    ctx.closePath(); ctx.fill(); ctx.stroke();
  }
  // Net lines
  ctx.strokeStyle=`${color}44`; ctx.lineWidth=1;
  for (let i=1; i<4; i++) {
    ctx.beginPath();
    ctx.moveTo(gx+gw/4*i, gy);
    ctx.lineTo(gx+gw/4*i, isTop ? gy+gd : gy+gd);
    ctx.stroke();
  }
  const netY1 = isTop ? gy : gy+gd/3;
  ctx.beginPath(); ctx.moveTo(gx, netY1); ctx.lineTo(gx+gw, netY1); ctx.stroke();
}

function drawSoccerHUD(ss, t) {
  // Top bar
  ctx.fillStyle='rgba(0,0,0,0.65)';
  ctx.beginPath(); ctx.roundRect(SF.FX+SF.FW/2-90, 8, 180, 44, 10); ctx.fill();

  ctx.textAlign='center';
  // Score
  ctx.font='bold 26px Nunito,sans-serif';
  ctx.fillStyle='white';
  ctx.fillText(`${ss.playerScore}`, SF.FX+SF.FW/2-30, 42);
  ctx.fillStyle='rgba(255,255,255,0.5)';
  ctx.font='18px Nunito,sans-serif';
  ctx.fillText('â€“', SF.FX+SF.FW/2, 42);
  ctx.font='bold 26px Nunito,sans-serif';
  ctx.fillStyle='white';
  ctx.fillText(`${ss.aiScore}`, SF.FX+SF.FW/2+30, 42);

  // "You" and "Cats" labels
  ctx.font='bold 8px Nunito,sans-serif';
  ctx.fillStyle='#a5d6a7';
  ctx.fillText(catName.toUpperCase(), SF.FX+SF.FW/2-32, 20);
  ctx.fillStyle='#ef9a9a';
  ctx.fillText('MIKAN', SF.FX+SF.FW/2+32, 20);

  // Goal target
  ctx.font='10px Nunito,sans-serif'; ctx.fillStyle='rgba(255,255,255,0.5)';
  ctx.fillText(`First to ${SF.GOALS_TO_WIN}`, SF.FX+SF.FW/2, 60);

  // Dash cooldown bar (bottom right)
  const p = ss.player;
  if (p.dashCooldown > 0) {
    const barW = 80, barH = 8;
    const bx = SF.FX+SF.FW-barW-8, by = SF.FY+SF.FH+10;
    ctx.fillStyle='rgba(0,0,0,0.4)';
    ctx.beginPath(); ctx.roundRect(bx,by,barW,barH,4); ctx.fill();
    const pct = 1 - p.dashCooldown/90;
    ctx.fillStyle='#80deea';
    ctx.beginPath(); ctx.roundRect(bx,by,barW*pct,barH,4); ctx.fill();
    ctx.font='8px Nunito,sans-serif'; ctx.fillStyle='white'; ctx.textAlign='right';
    ctx.fillText('âš¡ Dash', bx+barW, by-2);
  }
}

// â”€â”€ Soccer game loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let soccerRaf = null;
function kickOff() {
  if (!soccerState) return;
  soccerState.running = true;
  soccerState.kickedOff = true;
  // Give ball a gentle random nudge to start
  const angle = Math.PI/2 + (Math.random()-0.5)*0.8;
  const side = Math.random() > 0.5 ? 1 : -1;
  soccerState.ball.vx = Math.cos(angle)*side*2;
  soccerState.ball.vy = Math.sin(angle)*2.5;
}

function soccerLoop() {
  soccerRaf = requestAnimationFrame(soccerLoop);
  updateSoccer();
  renderSoccer();
}

// (soccer dash handled inside triggerDash below)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// END CAT SOCCER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LEVEL DATA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const LEVEL_DEFS = [
  { name:'Home Sweet Home', icon:'ğŸ ', theme:'home', rows:32,
    floorTile:{fill:'#efebe9', alt:'#e8ddd8', line:'#d7ccc8'},
    wallFill:'#bcaaa4', elevFill:'#fff9f0', elevStroke:'#ffb3a0',
    completeTxt:'You found the cat door! ğŸ±âœ¨', catCount:3,
    collectEmojis:['ğŸŸ','ğŸ¥›','ğŸ£','ğŸ§¶','ğŸª†'],
    secretEmojis:['ğŸ ','ğŸ§¸','ğŸ’'],
    doorStyle:'home',
  },
  { name:'Neighbourhood Park', icon:'ğŸŒ³', theme:'park', rows:36,
    floorTile:{fill:'#c8e6c9', alt:'#b2dfdb', line:'#a5d6a7'},
    wallFill:'#388e3c', elevFill:'#e8f5e9', elevStroke:'#66bb6a',
    completeTxt:'You reached the park gate! ğŸŒ³ğŸŒ¸', catCount:4,
    collectEmojis:['ğŸ','ğŸŸ','ğŸŒ¸','ğŸ¾','ğŸ‚'],
    secretEmojis:['ğŸ¦‹','ğŸ„','ğŸªº'],
    doorStyle:'park',
  },
  { name:'The Big Building', icon:'ğŸ¢', theme:'building', rows:40,
    floorTile:{fill:'#cfd8dc', alt:'#b0bec5', line:'#90a4ae'},
    wallFill:'#607d8b', elevFill:'#eceff1', elevStroke:'#78909c',
    completeTxt:'Rooftop reached! ğŸ¢âœ¨', catCount:5,
    collectEmojis:['ğŸ±','ğŸ¥«','â­','ğŸ”®','ğŸ’'],
    secretEmojis:['ğŸ“€','ğŸ','ğŸ”®'],
    doorStyle:'building',
  },
  { name:'Train Station', icon:'ğŸš‰', theme:'station', rows:44,
    floorTile:{fill:'#d1c4e9', alt:'#b39ddb', line:'#9575cd'},
    wallFill:'#5e35b1', elevFill:'#ede7f6', elevStroke:'#9575cd',
    completeTxt:'All aboard! ğŸš‰ğŸŠ', catCount:5,
    collectEmojis:['ğŸ™','ğŸœ','ğŸ«','ğŸ§¸','ğŸš„'],
    secretEmojis:['ğŸŸï¸','ğŸ“¿','ğŸ—ï¸'],
    doorStyle:'station',
  },
];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WORLD GENERATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Tile types: 0=floor, 1=wall, 2=elevated(impassable without interaction), 3=void/water
function seededRng(seed) { let s = seed | 0; return () => { s = (s * 9301 + 49297) % 233280; return s / 233280; }; }

function generateWorld(levelIdx) {
  const def = LEVEL_DEFS[levelIdx];
  const R = def.rows;
  const grid = Array.from({length:R}, () => Array(C).fill(0));
  // Borders
  for (let r = 0; r < R; r++) { grid[r][0] = 1; grid[r][C-1] = 1; }
  for (let c = 0; c < C; c++) { grid[0][c] = 1; grid[R-1][c] = 1; }
  // Door gap
  grid[0][4] = 0; grid[0][5] = 0;

  const rng = seededRng(levelIdx * 7919 + Math.floor(Date.now() / 1000) % 9999);
  const themes = {
    home:     [{type:1,count:10,w:2,h:1},{type:1,count:6,w:1,h:2},{type:2,count:4,w:2,h:1}],
    park:     [{type:1,count:12,w:1,h:1},{type:3,count:2,w:3,h:3},{type:2,count:5,w:2,h:1}],
    building: [{type:1,count:14,w:3,h:1},{type:1,count:6,w:1,h:2},{type:2,count:6,w:2,h:1}],
    station:  [{type:1,count:12,w:2,h:1},{type:3,count:3,w:2,h:2},{type:2,count:6,w:2,h:1}],
  };
  for (const spec of (themes[def.theme] || themes.home)) {
    for (let i = 0; i < spec.count; i++) {
      const r = Math.floor(rng() * (R-6)) + 3;
      const c = Math.floor(rng() * (C-2-spec.w)) + 1;
      if (r <= 2 && c >= 3 && c <= 5) continue;
      if (r >= R - 4) continue;
      for (let dr = 0; dr < spec.h && r+dr < R-1; dr++)
        for (let dc = 0; dc < spec.w && c+dc < C-1; dc++)
          if (grid[r+dr][c+dc] === 0) grid[r+dr][c+dc] = spec.type;
    }
  }
  // Ensure navigable rows
  for (let r = 3; r < R-3; r += 3) {
    let hasGap = false;
    for (let c = 1; c < C-1; c++) if (grid[r][c] === 0) { hasGap = true; break; }
    if (!hasGap) { grid[r][4] = 0; grid[r][5] = 0; }
  }
  return grid;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INTERACTABLE GENERATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Types: 'box'(scratchable/breakable), 'lever'(toggles platform), 
//        'vending'(drops food), 'switch'(opens elev), 'plant'(decorative break),
//        'luggage'(knockable), 'feeder'(scatter birds)
function generateInteractables(levelIdx, grid, R, rng) {
  const def = LEVEL_DEFS[levelIdx];
  const items = [];
  const used = new Set();

  // Collect valid floor positions
  const floors = [];
  for (let r = 2; r < R-2; r++)
    for (let c = 1; c < C-1; c++)
      if (grid[r][c] === 0) floors.push({r,c});

  function place(type, emoji, brokenEmoji, pts, en, extra={}) {
    for (let a = 0; a < 40; a++) {
      const cell = floors[Math.floor(rng() * floors.length)];
      if (!cell) continue;
      const k = `${cell.r},${cell.c}`;
      if (used.has(k)) continue;
      // Don't crowd start/end
      if (cell.r >= R-4 || cell.r <= 2) continue;
      used.add(k);
      items.push({
        type, emoji, brokenEmoji, pts, en,
        wx: cell.c*TILE + TILE/2, wy: cell.r*TILE + TILE/2,
        active: true, activated: false, animTick: 0,
        ...extra
      });
      return true;
    }
    return false;
  }

  // Theme-specific interactables
  if (def.theme === 'home') {
    for (let i = 0; i < 5; i++) place('box','ğŸ“¦','ğŸ—ƒï¸', 8, 0);
    for (let i = 0; i < 3; i++) place('plant','ğŸª´','ğŸŒ¿', 4, 0);
    place('lamp','ğŸ’¡','ğŸ’¡', 0, 0, {toggled:false});
    // 2 lever+platform pairs
    for (let i = 0; i < 2; i++) placeLeverPlatformPair(items, floors, grid, R, rng, used, i, def);
  } else if (def.theme === 'park') {
    for (let i = 0; i < 4; i++) place('plant','ğŸŒ¸','ğŸŒ¸', 5, 0, {scatter:true});
    for (let i = 0; i < 3; i++) place('box','ğŸª¨','ğŸ’¨', 6, 0);
    place('feeder','ğŸ¦â€â¬›','ğŸ¦', 0, 0);
    for (let i = 0; i < 2; i++) placeLeverPlatformPair(items, floors, grid, R, rng, used, i, def);
  } else if (def.theme === 'building') {
    for (let i = 0; i < 4; i++) place('box','ğŸ“„','ğŸ“ƒ', 5, 0);
    place('vending','ğŸ°','ğŸ¥¤', 0, 0);
    for (let i = 0; i < 2; i++) place('plant','ğŸª´','ğŸŒ±', 3, 0);
    for (let i = 0; i < 2; i++) placeLeverPlatformPair(items, floors, grid, R, rng, used, i, def);
  } else {
    for (let i = 0; i < 5; i++) place('luggage','ğŸ§³','ğŸ‘œ', 7, 0);
    place('feeder','ğŸ“°','ğŸ“°', 0, 0);
    for (let i = 0; i < 2; i++) placeLeverPlatformPair(items, floors, grid, R, rng, used, i, def);
  }
  return items;
}

function placeLeverPlatformPair(items, floors, grid, R, rng, used, idx, def) {
  // Lever on one side, platform path across void/elevated area
  const leverFloors = floors.filter(p => p.r > 4 && p.r < R-5 && !used.has(`${p.r},${p.c}`));
  if (leverFloors.length < 2) return;
  const leverCell = leverFloors[Math.floor(rng() * leverFloors.length)];
  used.add(`${leverCell.r},${leverCell.c}`);
  const leverWx = leverCell.c*TILE + TILE/2;
  const leverWy = leverCell.r*TILE + TILE/2;
  const platformId = `plat_${idx}`;
  items.push({
    type:'lever', emoji:'ğŸ”§', brokenEmoji:'ğŸ”§', pts:0, en:0,
    wx:leverWx, wy:leverWy,
    active:true, activated:false, animTick:0,
    platformId,
  });
  // Moving platform â€” travels horizontally between two x positions
  const startX = (2 + Math.floor(rng() * 3)) * TILE + TILE/2;
  const endX   = (5 + Math.floor(rng() * 3)) * TILE + TILE/2;
  const platY  = leverCell.r * TILE - TILE * (2 + Math.floor(rng() * 3));
  items.push({
    type:'movingPlatform', platformId,
    wx: startX, wy: Math.max(TILE*2, platY),
    startX, endX, speed: 0.8 + rng()*0.5,
    dir: 1, running: false,
    w: TILE*2, h: TILE*0.6,
    catRiding: false,
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DOG DATA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Human definitions â€” 2-3 per level, slow wanderers, gift givers
const HUMAN_OUTFITS = {
  home:     [{top:'#ef9a9a',bottom:'#b0bec5',skin:'#ffcc80'},{top:'#80cbc4',bottom:'#ce93d8',skin:'#ffab91'},{top:'#fff9c4',bottom:'#a5d6a7',skin:'#ffe0b2'}],
  park:     [{top:'#a5d6a7',bottom:'#ffe082',skin:'#ffcc80'},{top:'#81d4fa',bottom:'#ef9a9a',skin:'#ffab91'},{top:'#f8bbd0',bottom:'#b0bec5',skin:'#ffe0b2'}],
  building: [{top:'#b0bec5',bottom:'#546e7a',skin:'#ffcc80'},{top:'#90a4ae',bottom:'#455a64',skin:'#ffab91'},{top:'#cfd8dc',bottom:'#607d8b',skin:'#ffe0b2'}],
  station:  [{top:'#ce93d8',bottom:'#7e57c2',skin:'#ffcc80'},{top:'#80deea',bottom:'#00838f',skin:'#ffab91'},{top:'#ef9a9a',bottom:'#c62828',skin:'#ffe0b2'}],
};
const HUMAN_GIFTS = ['treat','treat','pet','pet','treat','pet']; // shuffled each level

// Treat types: bone, meat, drumstick, cookie
// Dog treat preferences and required counts
// Friendly roaming cats â€” different colours, patterns, personalities
const FRIEND_CAT_TYPES = [
  {name:'Sora',    colorIdx:2, pattern:'tabby',  eyeIdx:0, speed:0.55, sound:'purr'},
  {name:'Mikan',   colorIdx:1, pattern:'tabby',  eyeIdx:2, speed:0.7,  sound:'chirp'},
  {name:'Kuro',    colorIdx:3, pattern:'solid',  eyeIdx:1, speed:0.45, sound:'purr'},
  {name:'Shiro',   colorIdx:0, pattern:'tuxedo', eyeIdx:2, speed:0.6,  sound:'mew'},
  {name:'Hana',    colorIdx:6, pattern:'calico', eyeIdx:4, speed:0.5,  sound:'trill'},
  {name:'Kinako',  colorIdx:4, pattern:'spots',  eyeIdx:2, speed:0.65, sound:'chirp'},
  {name:'Mugi',    colorIdx:5, pattern:'tabby',  eyeIdx:0, speed:0.5,  sound:'purr'},
];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BEGIN LEVEL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€ Spawn secrets â”€â”€
function spawnSecrets(def, floorCells, usedC, R, rng) {
  const secrets = [];
  const emojis = def.secretEmojis || ['ğŸ’','â­','ğŸŒŸ'];
  // Place in varied areas of the level
  const zones = [
    floorCells.filter(p => p.r > Math.floor(R*0.15) && p.r < Math.floor(R*0.4)),
    floorCells.filter(p => p.r > Math.floor(R*0.4)  && p.r < Math.floor(R*0.65)),
    floorCells.filter(p => p.r > Math.floor(R*0.65) && p.r < Math.floor(R*0.88)),
  ];
  for (let i = 0; i < 3; i++) {
    const zone = zones[i];
    if (!zone || zone.length === 0) continue;
    let cell;
    for (let a = 0; a < 30; a++) {
      cell = zone[Math.floor(rng() * zone.length)];
      if (cell && !usedC.has(`${cell.r},${cell.c}`)) break;
    }
    if (!cell) continue;
    usedC.add(`${cell.r},${cell.c}`);
    secrets.push({
      emoji: emojis[i % emojis.length],
      wx: cell.c*TILE + TILE/2,
      wy: cell.r*TILE + TILE/2,
      collected: false,
      revealed: false,
      bob: rng()*Math.PI*2,
    });
  }
  return secrets;
}

function spawnHumans(def, floorCells, R, rng) {
  const count = 2 + (R > 36 ? 1 : 0); // 2-3 depending on level size
  const humans = [];
  const outfits = HUMAN_OUTFITS[def.theme] || HUMAN_OUTFITS.home;
  const usedCells = new Set();
  // Spread across top 2/3 of level
  const zone = floorCells.filter(p => p.r > 3 && p.r < Math.floor(R * 0.82));
  for (let i = 0; i < count; i++) {
    let cell;
    for (let a = 0; a < 40; a++) {
      cell = zone[Math.floor(rng() * zone.length)];
      if (cell && !usedCells.has(`${cell.r},${cell.c}`)) break;
    }
    if (!cell) continue;
    usedCells.add(`${cell.r},${cell.c}`);
    const gift = rng() > 0.5 ? 'treat' : 'pet';
    const treatTypes = ['bone','meat','drumstick','cookie'];
    humans.push({
      wx: cell.c*TILE + TILE/2,
      wy: cell.r*TILE + TILE/2,
      outfit: outfits[i % outfits.length],
      gift,
      treatType: treatTypes[Math.floor(rng()*treatTypes.length)],
      state: 'wander',      // wander | offering | cooldown
      wanderAngle: rng()*Math.PI*2,
      wanderTimer: 80 + Math.floor(rng()*100),
      offerCooldown: 0,
      giftAnim: 0,
      facingAngle: 0,
      moving: false,
    });
  }
  return humans;
}

function beginLevel(idx) {
  if (idx === 4) { soccerState=null; if(soccerRaf){cancelAnimationFrame(soccerRaf);soccerRaf=null;} if(raf){cancelAnimationFrame(raf);raf=null;} beginSoccer(); return; }
  // Stop any soccer loop
  if(soccerRaf){cancelAnimationFrame(soccerRaf);soccerRaf=null;} soccerState=null;
  stopPreviewAnim();
  currentLevel = idx;
  const def = LEVEL_DEFS[idx];
  const R = def.rows;
  const rng = seededRng(idx * 7919 + Math.floor(Date.now() / 500) % 10000);
  const grid = generateWorld(idx);

  // Floor cells for spawning
  const floorCells = [];
  for (let r = 2; r < R-2; r++)
    for (let c = 1; c < C-1; c++)
      if (grid[r][c] === 0) floorCells.push({r,c});

  // Key in middle third
  const keyZone = floorCells.filter(p => p.r > R*0.25 && p.r < R*0.75);
  const keyCell = keyZone[Math.floor(rng() * keyZone.length)] || {r:Math.floor(R/2),c:5};

  // Collectibles
  const collectibles = [];
  const usedC = new Set([`${keyCell.r},${keyCell.c}`]);
  const count = 26 + idx*4;
  for (let i = 0; i < count; i++) {
    let cell;
    for (let a = 0; a < 20; a++) {
      cell = floorCells[Math.floor(rng() * floorCells.length)];
      if (cell && !usedC.has(`${cell.r},${cell.c}`) && cell.r < R-3) break;
    }
    if (!cell) continue;
    usedC.add(`${cell.r},${cell.c}`);
    const roll = rng();
    let type,emoji,pts,en;
    if (roll < 0.3)       { type='food';  emoji=def.collectEmojis[0]; pts=0; en=22; }
    else if (roll < 0.48) { type='food';  emoji=def.collectEmojis[1]||'ğŸŸ'; pts=0; en=18; }
    else if (roll < 0.62) { type='toy';   emoji=def.collectEmojis[2]||'ğŸ§¶'; pts=0; en=0; }
    else if (roll < 0.74) { type='toy';   emoji=def.collectEmojis[3]||'ğŸ¾'; pts=0; en=0; }
    else if (roll < 0.82) { type='mouse'; emoji='ğŸ­'; pts=0; en=10; }
    else if (roll < 0.86) { type='goldenmouse'; emoji='ğŸ­'; pts=0; en=0; }
    else if (roll < 0.93) { type='flower'; emoji=['ğŸŒ¸','ğŸŒ¼','ğŸ’'][Math.floor(rng()*3)]; pts=0; en=0; }
    else                  { type='flower'; emoji=['ğŸŒ¸','ğŸŒ¼','ğŸ’'][Math.floor(rng()*3)]; pts=0; en=0; }
    const isMouse = type==='mouse'||type==='goldenmouse';
    const spd = isMouse ? (type==='goldenmouse' ? 1.1:0.7) : 0;
    collectibles.push({
      type,emoji,pts,en:0,collected:false,
      wx:cell.c*TILE+TILE/2, wy:cell.r*TILE+TILE/2,
      moveSpeed:spd, moveDir:rng()>0.5?1:-1,
      moveMin:(cell.c-1)*TILE+TILE/2, moveMax:(cell.c+1)*TILE+TILE/2,
      bob:rng()*Math.PI*2, golden:type==='goldenmouse',
    });
  }

  // Friendly roaming cats
  const dogs = []; // kept as 'dogs' var name for minimal refactor, they're cats now
  const catCount = Math.round((def.catCount||3) * (CAT_COUNT_MULT||1));
  const catZone = floorCells.filter(p => p.r > 4 && p.r < R-4);
  for (let i = 0; i < catCount; i++) {
    let cell;
    for (let a = 0; a < 30; a++) {
      cell = catZone[Math.floor(rng() * catZone.length)];
      if (cell && !usedC.has(`${cell.r},${cell.c}`)) break;
    }
    if (!cell) continue;
    usedC.add(`${cell.r},${cell.c}`);
    const type = FRIEND_CAT_TYPES[Math.floor(rng() * FRIEND_CAT_TYPES.length)];
    dogs.push({
      ...type,
      wx: cell.c*TILE+TILE/2, wy: cell.r*TILE+TILE/2,
      state: 'wander',
      wanderTimer: 80+Math.floor(rng()*140),
      wanderAngle: rng()*Math.PI*2,
      facingAngle: 0,
      touchCooldown: 0,
      heartAnim: 0,
      bob: rng()*Math.PI*2,
    });
  }

  // Interactables
  const interactables = generateInteractables(idx, grid, R, rng);

  const humans = spawnHumans(def, floorCells, R, rng);

  // â”€â”€ Secret collectibles (3 per level, hidden) â”€â”€
  const secrets = spawnSecrets(def, floorCells, usedC, R, rng);
  const napSpots = spawnNapSpots(idx, floorCells, usedC, rng);
  const stickers = spawnLevelStickers(idx, floorCells, usedC, rng);
  const wateringCan = spawnWaterFeature(idx, floorCells, interactables, usedC, rng);
  const hiddenRoom = spawnHiddenRoom(idx, grid, R, floorCells, usedC, rng);
  // Fish tank â€” add as a fixed interactable near the start
  const ftZone = floorCells.filter(p => p.r > 2 && p.r < 8);
  const ftCell = ftZone[Math.floor(rng()*ftZone.length)] || floorCells[0];
  const fishTank = { wx: ftCell.c*TILE+TILE/2, wy: ftCell.r*TILE+TILE/2 };
  initWeather(idx);
  fishTapAnim = 0;

  gs = {
    running:true, time:0,
    hasKey:false, doorShake:0,
    camY:0, grid, R, def,
    cat:{
      wx:CW/2, wy:R*TILE - TILE*1.5,
      facingAngle:Math.PI, moving:false,
      scratchCooldown:0, scratchActive:false,
      onPlatform:null,
      dashFrames:0, dashCooldown:0, dashDx:0, dashDy:0,
      happyFrames:0,
    },
    key:{wx:keyCell.c*TILE+TILE/2, wy:keyCell.r*TILE+TILE/2, collected:false},
    door:{wx:(4.5)*TILE + TILE/2, wy:TILE*1.4},
    collectibles, dogs, interactables, secrets, humans,
    napSpots, stickers, hiddenRoom, fishTank,
    hasWateringCan: false, wateringCanItem: wateringCan,
    particles:[],
    joystick:{active:false,dx:0,dy:0},
    scratchPressed:false,
  };

  document.getElementById('hud').style.display = 'block';
  document.getElementById('game-canvas-wrap').style.display = 'block';
  document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
  if (raf) cancelAnimationFrame(raf);
  if (musicEnabled) startMusic();
  // Push watering can into collectibles list
  if (wateringCan) gs.collectibles.push(wateringCan);
  // Register hidden room trigger as a scratchable interactable
  if (hiddenRoom) {
    gs.interactables.push({
      type:'hiddenroom', emoji:hiddenRoom.emoji, wx:hiddenRoom.wx, wy:hiddenRoom.wy,
      active:true, broken:false, animTick:0, activated:false,
      _room: hiddenRoom,
    });
  }
  loadJournal();
  gameLoop();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GAME STATE & LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let gs = null, raf = null;
// Double-tap tracking for dash (PC)
const lastKeyTap = {}; // code -> timestamp of last tap
const DOUBLE_TAP_MS = 200;

// Swipe tracking for dash (mobile)
let swipeStart = null;
const SWIPE_MIN_DIST = 40;
const SWIPE_MAX_MS = 220;

const canvas = document.getElementById('gameCanvas');
// Scroll handling for help menu
canvas.addEventListener('wheel', e => {
  if (!helpOpen) return;
  e.preventDefault();
  const max = drawHelp._maxScroll || 0;
  helpScroll = Math.max(0, Math.min(max, helpScroll + e.deltaY * 0.4));
}, { passive: false });

// Touch scroll for help menu
let helpTouchY = null;
canvas.addEventListener('touchstart', e => {
  if (!helpOpen) return;
  helpTouchY = e.touches[0].clientY;
}, { passive: true });
canvas.addEventListener('touchmove', e => {
  if (!helpOpen || helpTouchY === null) return;
  const dy = helpTouchY - e.touches[0].clientY;
  helpTouchY = e.touches[0].clientY;
  const max = drawHelp._maxScroll || 0;
  helpScroll = Math.max(0, Math.min(max, helpScroll + dy * 1.2));
}, { passive: true });
canvas.addEventListener('touchend', () => { helpTouchY = null; });
// Soccer kickoff button click
canvas.addEventListener('click', e => {
  if (soccerState && !soccerState.running && !soccerState.winner) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = CW/rect.width, scaleY = CH/rect.height;
    const mx = (e.clientX-rect.left)*scaleX;
    const my = (e.clientY-rect.top)*scaleY;
    const bx = renderSoccer._kickBtnX||0, bw = renderSoccer._kickBtnW||140;
    const by = renderSoccer._kickBtnY||0, bh = renderSoccer._kickBtnH||36;
    if (mx>=bx && mx<=bx+bw && my>=by && my<=by+bh) {
      kickOff(); return;
    }
  }
});

// Click anywhere on help overlay to close
canvas.addEventListener('click', e => {
  if (!helpOpen) return;
  const rect = canvas.getBoundingClientRect();
  const scaleX = CW / rect.width, scaleY = CH / rect.height;
  const mx = (e.clientX - rect.left) * scaleX;
  const my = (e.clientY - rect.top) * scaleY;
  const pw = 310, ph = 410;
  const px = (CW-pw)/2, py = (CH-ph)/2;
  // Click X button or outside panel closes it
  const onX = mx > px+pw-30 && mx < px+pw-4 && my > py+10 && my < py+42;
  const outside = mx < px || mx > px+pw || my < py || my > py+ph;
  if (onX || outside) helpOpen = false;
});

const ctx = canvas.getContext('2d');
const keys = {};

window.addEventListener('keydown', e => {
  const wasDown = keys[e.code];
  keys[e.code] = true;
  if ((e.code==='KeyX'||e.code==='KeyZ') && gs?.running) {
    doScratch();
    if (gs.hasWateringCan) tryWaterPlant(gs.cat);
  }
  if (e.code==='KeyP') takePhoto();
  if (e.code==='KeyJ') toggleJournal();
  if (e.code==='KeyH') toggleHelp();
  if ((e.code==='Space'||e.code==='Enter') && soccerState && !soccerState.running && !soccerState.winner) kickOff();
  if (e.code==='Space') e.preventDefault();
  // Double-tap dash detection
  if (!wasDown && gs?.running) {
    const DASH_KEYS = ['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','KeyA','KeyD','KeyW','KeyS'];
    if (DASH_KEYS.includes(e.code)) {
      const now = Date.now();
      if (lastKeyTap[e.code] && now - lastKeyTap[e.code] < DOUBLE_TAP_MS) {
        triggerDash(e.code);
        lastKeyTap[e.code] = 0;
      } else {
        lastKeyTap[e.code] = now;
      }
    }
  }
});
window.addEventListener('keyup', e => keys[e.code] = false);

// Joystick
const jZone = document.getElementById('joystick-zone');
const jKnob = document.getElementById('joystick-knob');
let jTouch = null;
const JR = 52;
jZone.addEventListener('touchstart', e => {
  e.preventDefault(); const t = e.changedTouches[0];
  const rect = jZone.getBoundingClientRect();
  jTouch = {id:t.identifier, cx:rect.left+rect.width/2, cy:rect.top+rect.height/2};
  swipeStart = {x:t.clientX, y:t.clientY, time:Date.now()};
  updateJoystick(t.clientX, t.clientY);
}, {passive:false});
jZone.addEventListener('touchmove', e => {
  e.preventDefault();
  for (const t of e.changedTouches) if (jTouch && t.identifier===jTouch.id) updateJoystick(t.clientX, t.clientY);
}, {passive:false});
['touchend','touchcancel'].forEach(ev => jZone.addEventListener(ev, e => {
  for (const t of e.changedTouches) if (jTouch && t.identifier===jTouch.id) {
    jTouch = null;
    if (gs) gs.joystick = {active:false,dx:0,dy:0};
    if (soccerState) soccerState.joystick = {active:false,dx:0,dy:0};
    jKnob.style.transform = 'translate(-50%,-50%)';
    // Swipe-to-dash detection
    if (swipeStart && (gs?.running || soccerState?.running)) {
      const elapsed = Date.now() - swipeStart.time;
      const sdx = t.clientX - swipeStart.x, sdy = t.clientY - swipeStart.y;
      const sdist = Math.hypot(sdx, sdy);
      if (elapsed < SWIPE_MAX_MS && sdist > SWIPE_MIN_DIST) {
        triggerDash(null, sdx/sdist, sdy/sdist);
      }
    }
    swipeStart = null;
  }
}));
function updateJoystick(cx, cy) {
  if (!jTouch) return;
  let dx=cx-jTouch.cx, dy=cy-jTouch.cy;
  const d = Math.hypot(dx,dy); if (d>JR) {dx=dx/d*JR; dy=dy/d*JR;}
  jKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
  if (gs) gs.joystick = {active:true, dx:dx/JR, dy:dy/JR};
  if (soccerState) soccerState.joystick = {active:true, dx:dx/JR, dy:dy/JR};
}
function onScratchDown(e) { e.preventDefault(); if (soccerState && !soccerState.running && !soccerState.winner) { kickOff(); } else if (gs?.running) doScratch(); document.getElementById('scratch-btn').classList.add('pressed'); }
function onScratchUp(e)   { e.preventDefault(); document.getElementById('scratch-btn').classList.remove('pressed'); }

function triggerDash(keyCode, nx, ny) {
  // Soccer mode dash
  if (soccerState?.running) {
    const p = soccerState.player;
    if (p.dashFrames > 0 || p.dashCooldown > 0) return;
    let dx = nx||0, dy = ny||0;
    if (keyCode) {
      if (keyCode==='ArrowLeft'||keyCode==='KeyA')  { dx=-1; dy=0; }
      if (keyCode==='ArrowRight'||keyCode==='KeyD') { dx=1;  dy=0; }
      if (keyCode==='ArrowUp'||keyCode==='KeyW')    { dx=0;  dy=-1; }
      if (keyCode==='ArrowDown'||keyCode==='KeyS')  { dx=0;  dy=1; }
    }
    const dl = Math.hypot(dx,dy)||1; dx/=dl; dy/=dl;
    p.dashDx=dx; p.dashDy=dy; p.dashFrames=14; p.dashCooldown=90;
    p.justDashed=true;
    playDash();
    return;
  }
  if (!gs || gs.cat.dashFrames > 0 || gs.cat.dashCooldown > 0) return;
  let dx = nx||0, dy = ny||0;
  if (keyCode) {
    if (keyCode==='ArrowLeft'||keyCode==='KeyA')  { dx=-1; dy=0; }
    if (keyCode==='ArrowRight'||keyCode==='KeyD') { dx=1;  dy=0; }
    if (keyCode==='ArrowUp'||keyCode==='KeyW')    { dx=0;  dy=-1; }
    if (keyCode==='ArrowDown'||keyCode==='KeyS')  { dx=0;  dy=1; }
  }
  const dl = Math.hypot(dx,dy)||1; dx/=dl; dy/=dl;
  gs.cat.dashDx = dx; gs.cat.dashDy = dy;
  gs.cat.dashFrames = DASH_FRAMES;
  gs.cat.dashCooldown = DASH_COOLDOWN;
  playDash();
  // Spawn trail ghosts
  for (let i=0; i<5; i++) {
    gs.particles.push({
      wx:gs.cat.wx - dx*i*8, wy:gs.cat.wy - dy*i*8,
      vx:0, vy:0, life:0.7-i*0.12, size:24-i*2,
      emoji:null, isDashTrail:true,
      col:CAT_COLORS[catCfg.colorIdx].body,
      alpha:0.55-i*0.1,
    });
  }
}

function doScratch() {
  if (!gs || gs.cat.scratchCooldown > 0) return;
  gs.cat.scratchCooldown = SCRATCH_COOLDOWN;
  gs.cat.scratchActive = true;
  gs.energy = Math.max(0, gs.energy - 1);
  playMeow();
  checkScratchHits();
}


function checkScratchHits() {
  const cat = gs.cat;
  const fa = cat.facingAngle - Math.PI/2; // actual world direction

  // Friendly cats react to nearby scratch (gentle)
  for (const fc of gs.dogs) {
    const dx=fc.wx-cat.wx, dy=fc.wy-cat.wy;
    const dist=Math.hypot(dx,dy);
    if (dist>SCRATCH_RANGE) continue;
    if (fc.touchCooldown>0) continue;
    const angle=Math.atan2(dy,dx);
    const diff=Math.abs(normaliseAngle(angle-fa));
    if (diff>SCRATCH_ARC/2) continue;
    fc.touchCooldown=60; fc.heartAnim=55;
    playFriendCatSound(fc.sound);
    spawnParticles(fc.wx, fc.wy-10, 'ğŸ’•');
    break;
  }


  // Check interactables
  for (const obj of gs.interactables) {
    if (!obj.active || obj.type==='movingPlatform') continue;
    const dx=obj.wx-cat.wx, dy=obj.wy-cat.wy;
    const dist = Math.hypot(dx,dy);
    if (dist > SCRATCH_RANGE) continue;
    const angle = Math.atan2(dy,dx);
    const diff = Math.abs(normaliseAngle(angle - fa));
    if (diff > SCRATCH_ARC/2) continue;
    activateInteractable(obj);
  }
}

function normaliseAngle(a) {
  while (a > Math.PI) a -= Math.PI*2;
  while (a < -Math.PI) a += Math.PI*2;
  return a;
}

function activateInteractable(obj) {
  if (obj.type === 'hiddenroom') {
    if (!obj.activated) {
      obj.activated = true;
      obj._room.open = true; obj._room.openAnim = 0; obj._room.activated = true;
      spawnParticles(obj.wx, obj.wy, 'âœ¨');
      spawnParticles(obj.wx, obj.wy, 'ğŸŒŸ');
      spawnPop(obj.wx, obj.wy, 'Secret room! ğŸŒŸ', '#ce93d8');
      playDoorOpen();
    }
    return;
  }
  if (obj.type === 'plant' && obj.wilted) { tryWaterPlant(gs.cat); return; }

  obj.animTick = 20;
  if (obj.type==='box'||obj.type==='luggage') {
    obj.active = false; obj.broken = true;
    spawnPop(obj.wx, obj.wy, 'ğŸ’¥ Smash!', '#f48fb1');
    spawnParticles(obj.wx, obj.wy, obj.brokenEmoji||'âœ¨');
    playBreak();
  } else if (obj.type==='plant') {
    obj.active = false; obj.broken = true;
    spawnPop(obj.wx, obj.wy, 'ğŸŒ¿ Whoosh!', '#a5d6a7');
    spawnParticles(obj.wx, obj.wy, 'ğŸŒ¸');
    playBreak();
  } else if (obj.type==='feeder') {
    obj.active = false; obj.broken = true;
    spawnPop(obj.wx, obj.wy, 'ğŸ¦ Fly away!', '#81d4fa');
    spawnParticles(obj.wx, obj.wy, 'ğŸ¦');
    playBreak();
  } else if (obj.type==='lamp') {
    obj.toggled = !obj.toggled; obj.animTick = 15;
    spawnPop(obj.wx, obj.wy, obj.toggled?'ğŸ’¡ On!':'ğŸŒ‘ Off!', '#ffe082');
    playLeverClick();
  } else if (obj.type==='vending') {
    if (!obj.used) {
      obj.used = true; obj.animTick = 30;
      playCollect();
      // Drop food collectible nearby
      gs.collectibles.push({
        type:'food', emoji:'ğŸ¥¤', pts:15, en:35, collected:false,
        wx:obj.wx+20, wy:obj.wy+20,
        moveSpeed:0, moveDir:1, moveMin:obj.wx, moveMax:obj.wx+TILE, bob:0, golden:false,
      });
      spawnPop(obj.wx, obj.wy, 'ğŸ¥¤ Snack!', '#66bb6a');
      spawnParticles(obj.wx, obj.wy, 'ğŸ¥¤');
    } else {
      spawnPop(obj.wx, obj.wy, 'Empty!', '#bdbdbd');
    }
  } else if (obj.type==='lever') {
    obj.activated = !obj.activated; obj.animTick = 20;
    playLeverClick();
    // Find linked platform and toggle it
    const plat = gs.interactables.find(p => p.type==='movingPlatform' && p.platformId===obj.platformId);
    if (plat) {
      plat.running = obj.activated;
      if (plat.running) playPlatformStart();
      spawnPop(obj.wx, obj.wy, obj.activated?'âš™ï¸ Platform ON!':'âš™ï¸ Platform OFF!', '#ce93d8');
    }
  }
}

function gameLoop() {
  if (!gs || !gs.running) return;
  raf = requestAnimationFrame(gameLoop);
  gs.time++;
  update();
  render();
}

function update() {
  const cat = gs.cat;
  const d = {catCount:1};
  const t = gs.time;

  // Movement
  let ix=0, iy=0;
  if (keys['ArrowLeft']||keys['KeyA']) ix -= 1;
  if (keys['ArrowRight']||keys['KeyD']) ix += 1;
  if (keys['ArrowUp']||keys['KeyW']) iy -= 1;
  if (keys['ArrowDown']||keys['KeyS']) iy += 1;
  if (gs.joystick.active) { ix += gs.joystick.dx; iy += gs.joystick.dy; }
  const len = Math.hypot(ix,iy); if (len>1) {ix/=len; iy/=len;}
  cat.moving = len > 0.1;
  if (cat.moving) cat.facingAngle = Math.atan2(iy,ix) + Math.PI/2;

  // Moving platform riding
  cat.onPlatform = null;
  for (const obj of gs.interactables) {
    if (obj.type!=='movingPlatform'||!obj.running) continue;
    // Move platform
    obj.wx += obj.dir * obj.speed;
    if (obj.wx >= obj.endX||obj.wx <= obj.startX) obj.dir *= -1;
    // Check if cat is standing on it
    if (Math.abs(cat.wx-obj.wx)<obj.w/2 && Math.abs(cat.wy-obj.wy)<22) {
      cat.onPlatform = obj;
      cat.wx += obj.dir * obj.speed;
    }
  }

  // Dash movement
  if (cat.dashCooldown > 0) cat.dashCooldown--;
  if (cat.dashFrames > 0) {
    cat.dashFrames--;
    const dashSpd = DASH_SPEED * (cat.happyFrames>0?HAPPY_SPEED_MULT:1);
    cat.wx += cat.dashDx * dashSpd;
    cat.wy += cat.dashDy * dashSpd;
    cat.wx = Math.max(TILE*1.1, Math.min(COLS*TILE-TILE*1.1, cat.wx));
    cat.wy = Math.max(TILE*1.1, Math.min(gs.R*TILE-TILE*1.1, cat.wy));
    if (catHitsWall(cat.wx, cat.wy)) { cat.wx -= cat.dashDx*dashSpd; cat.wy -= cat.dashDy*dashSpd; cat.dashFrames=0; }
    // Spawn trail particle each dash frame
    if (cat.dashFrames % 3 === 0) {
      gs.particles.push({wx:cat.wx, wy:cat.wy, vx:0, vy:0, life:0.5, size:20, emoji:null,
        isDashTrail:true, col:CAT_COLORS[catCfg.colorIdx].body, alpha:0.4});
    }
    resolveCollisions(cat);
  } else {
    // Happy speed boost
    const spd = CAT_SPEED * (cat.happyFrames>0?HAPPY_SPEED_MULT:1);
    // Apply movement one axis at a time â€” stops cleanly, no bounce
    cat.wx += ix * spd;
    cat.wx = Math.max(TILE*1.1, Math.min(COLS*TILE - TILE*1.1, cat.wx));
    if (catHitsWall(cat.wx, cat.wy)) cat.wx -= ix * spd;

    cat.wy += iy * spd;
    cat.wy = Math.max(TILE*1.1, Math.min(gs.R*TILE - TILE*1.1, cat.wy));
    if (catHitsWall(cat.wx, cat.wy)) cat.wy -= iy * spd;

    resolveCollisions(cat);
  }
  // Tick happy
  if (cat.happyFrames > 0) cat.happyFrames--;

  // Scratch cooldown
  if (cat.scratchCooldown > 0) cat.scratchCooldown--;

  // Camera
  const targetCamY = cat.wy - CH * 0.62;
  gs.camY += (targetCamY - gs.camY) * 0.09;
  gs.camY = Math.max(0, Math.min(gs.R * TILE - CH, gs.camY));

  // Key pickup
  if (!gs.key.collected) {
    if (Math.hypot(cat.wx-gs.key.wx, cat.wy-gs.key.wy) < 24) {
      gs.key.collected=true; gs.hasKey=true;
      playKeyPickup();
      spawnPop(gs.key.wx, gs.key.wy, 'ğŸ—ï¸ Found the key!', '#ffd700');
      spawnParticles(gs.key.wx, gs.key.wy, 'âœ¨');
      document.getElementById('key-indicator').textContent='ğŸ—ï¸ âœ“';
    }
  }

  // Door
  const dd = Math.hypot(cat.wx-gs.door.wx, cat.wy-gs.door.wy);
  if (dd < 38) {
    if (gs.hasKey) {
      playDoorOpen(); gs.running=false; showLevelComplete(); return;
    } else if (!gs.doorShake) {
      gs.doorShake=30;
      spawnPop(gs.door.wx, gs.door.wy, 'ğŸ”‘ Need the key!', '#ff7043');
    }
  }
  if (gs.doorShake>0) gs.doorShake--;

  // Collectibles
  for (const c of gs.collectibles) {
    if (c.collected) continue;
    if (c.moveSpeed>0) {
      // Flee from cat when nearby
      const mouseDist = Math.hypot(cat.wx-c.wx, cat.wy-c.wy);
      const fleeing = mouseDist < 100;
      const spd = c.moveSpeed * (fleeing ? 1.3 : 1);

      // Try moving in current direction; also drift vertically for 2D roaming
      if (!c.vy) c.vy = (Math.random()-0.5)*0.8;
      if (fleeing) {
        // Run directly away from cat
        const fx = c.wx-cat.wx, fy = c.wy-cat.wy;
        const fl = Math.hypot(fx,fy)||1;
        c.wx += fx/fl * spd;
        c.wy += fy/fl * spd;
        c.moveDir = fx > 0 ? 1 : -1;
      } else {
        c.wx += c.moveDir * spd;
        c.wy += c.vy;
        // Occasionally change vertical drift
        if (Math.random() < 0.01) c.vy = (Math.random()-0.5)*1.2;
      }

      // Check if mouse is now inside a solid tile â€” teleport to a random floor cell ("mouse hole")
      const mgr = Math.floor(c.wy/TILE), mgc = Math.floor(c.wx/TILE);
      const inWall = mgr<0||mgr>=gs.R||mgc<0||mgc>=COLS ||
                     gs.grid[mgr][mgc]===1||gs.grid[mgr][mgc]===2||gs.grid[mgr][mgc]===3;
      const outOfBounds = c.wx<TILE||c.wx>(COLS-1)*TILE||c.wy<TILE||c.wy>(gs.R-1)*TILE;
      if (inWall||outOfBounds) {
        // Mouse pops out of a random floor tile (mouse hole!)
        const floorCells=[];
        for(let r=2;r<gs.R-2;r++) for(let cc=1;cc<COLS-1;cc++) if(gs.grid[r][cc]===0) floorCells.push({r,cc});
        if(floorCells.length>0){
          const pick=floorCells[Math.floor(Math.random()*floorCells.length)];
          c.wx=pick.cc*TILE+TILE/2; c.wy=pick.r*TILE+TILE/2;
        }
        c.moveDir*=-1; c.vy=(Math.random()-0.5)*0.8;
      }
    }
    if (Math.hypot(cat.wx-c.wx, cat.wy-c.wy)<20) {
      c.collected=true;
      if (c.type === 'wateringcan') {
        gs.hasWateringCan = true;
        playCollect();
        spawnPop(c.wx, c.wy, 'ğŸª£ Watering can!', '#80cbc4');
        spawnParticles(c.wx, c.wy, 'ğŸ’§');
      } else {
        playCollect();
        spawnPop(c.wx, c.wy, c.golden?'âœ¨ Shiny!':'Yay!', c.golden?'#ffd700':'#ce93d8');
        spawnParticles(c.wx, c.wy, c.golden?'âœ¨':'ğŸŒ¸');
      }
    }
  }

  updateDogs();
  updateSecrets();
  updateStickerPickup();
  updateNapSpots();
  checkFishTank();
  updateWeather();
  updateHumans();
  updateHUD();
}

function updateHumans() {
  if (!gs.humans) return;
  const cat = gs.cat;
  for (const h of gs.humans) {
    if (h.offerCooldown > 0) h.offerCooldown--;
    if (h.giftAnim > 0) h.giftAnim--;

    const dist = Math.hypot(cat.wx - h.wx, cat.wy - h.wy);

    if (dist < 48 && h.offerCooldown === 0) {
      // Give gift to cat
      h.state = 'offering';
      h.giftAnim = 40;
      h.offerCooldown = 300; // 5s cooldown before offering again
      h.facingAngle = Math.atan2(cat.wy - h.wy, cat.wx - h.wx) + Math.PI/2;
      h.moving = false;

      if (h.gift === 'treat') {
          playCollect();
          spawnPop(h.wx, h.wy, 'ğŸŸ Snack!', '#f48fb1');
          spawnParticles(h.wx, h.wy, 'ğŸŸ');
          spawnParticles(h.wx, h.wy, 'ğŸ’•');
      } else {
        // Pet â€” give happiness boost
        cat.happyFrames = HAPPY_DURATION;
        playPurr();
        spawnPop(h.wx, h.wy, 'ğŸŒˆ Good kitty!', '#ce93d8');
        spawnParticles(h.wx, h.wy, 'ğŸŒˆ');
        spawnParticles(cat.wx, cat.wy, 'âœ¨');
      }
    } else if (dist >= 48) {
      h.state = 'wander';
    }

    if (h.state === 'wander') {
      h.wanderTimer--;
      if (h.wanderTimer <= 0) {
        h.wanderAngle += (Math.random()-0.5)*1.1;
        h.wanderTimer = 80 + Math.floor(Math.random()*120);
      }
      const spd = 0.4;
      const nx = Math.cos(h.wanderAngle)*spd, ny = Math.sin(h.wanderAngle)*spd;
      h.wx += nx; h.wy += ny;
      h.moving = Math.abs(nx)+Math.abs(ny) > 0.05;
      if (h.moving) h.facingAngle = Math.atan2(ny, nx) + Math.PI/2;
      // Clamp to world
      h.wx = Math.max(TILE*1.5, Math.min((COLS-1)*TILE-TILE*1.5, h.wx));
      h.wy = Math.max(TILE*1.5, Math.min((gs.R-1)*TILE-TILE*1.5, h.wy));
      // Bounce off walls
      const hgr = Math.floor(h.wy/TILE), hgc = Math.floor(h.wx/TILE);
      if (hgr>=0&&hgr<gs.R&&hgc>=0&&hgc<COLS && (gs.grid[hgr][hgc]===1||gs.grid[hgr][hgc]===2||gs.grid[hgr][hgc]===3)) {
        h.wx -= nx; h.wy -= ny;
        h.wanderAngle += Math.PI * (0.5 + Math.random()*0.5);
      }
    }
  }
}


function updateSecrets() {
  if (!gs.secrets) return;
  const cat = gs.cat;
  for (const s of gs.secrets) {
    if (s.collected) continue;
    const dist = Math.hypot(cat.wx-s.wx, cat.wy-s.wy);
    if (dist < 30) s.revealed = true;
    if (dist < 20 && s.revealed) {
      s.collected = true;
      playKeyPickup(); // nice chime for secret find
      spawnPop(s.wx, s.wy, 'ğŸ” Secret found! âœ¨', '#ffd700');
      spawnParticles(s.wx, s.wy, 'âœ¨');
      spawnParticles(s.wx, s.wy, s.emoji);
    }
  }
}

// Returns true if the cat circle at (wx,wy) overlaps any solid tile
function catHitsWall(wx, wy) {
  const R2 = 13;
  const probes = [[R2,0],[-R2,0],[0,R2],[0,-R2],[R2,R2*.7],[-R2,R2*.7],[R2,-R2*.7],[-R2,-R2*.7]];
  for (const [dx,dy] of probes) {
    const gr = Math.floor((wy+dy)/TILE);
    const gc = Math.floor((wx+dx)/TILE);
    if (gr<0||gr>=gs.R||gc<0||gc>=COLS) return true;
    const t = gs.grid[gr][gc];
    if (t===1||t===2||t===3) return true;
  }
  return false;
}

function resolveCollisions(cat) {
  const R2 = 13;
  // Fine-grain snap: push cat out of any overlapping solid tile
  const probes = [[R2,0],[-R2,0],[0,R2],[0,-R2],[R2,R2*.7],[-R2,R2*.7],[R2,-R2*.7],[-R2,-R2*.7]];
  for (let pass=0; pass<3; pass++) {
    for (const [dx,dy] of probes) {
      const gr = Math.floor((cat.wy+dy)/TILE);
      const gc = Math.floor((cat.wx+dx)/TILE);
      if (gr<0||gr>=gs.R||gc<0||gc>=COLS) continue;
      const tile = gs.grid[gr][gc];
      if (tile!==1&&tile!==2&&tile!==3) continue;
      // Compute overlap and push out along minimum axis
      const tileX = gc*TILE + TILE/2, tileY = gr*TILE + TILE/2;
      const overlapX = (R2 + TILE/2) - Math.abs(cat.wx - tileX);
      const overlapY = (R2 + TILE/2) - Math.abs(cat.wy - tileY);
      if (overlapX > 0 && overlapY > 0) {
        if (overlapX < overlapY) {
          cat.wx += cat.wx < tileX ? -overlapX : overlapX;
        } else {
          cat.wy += cat.wy < tileY ? -overlapY : overlapY;
        }
      }
    }
  }
  // Solid interactables (unbroken boxes/luggage)
  for (const obj of gs.interactables) {
    if (obj.type==='movingPlatform'||!obj.active||obj.broken) continue;
    if (obj.type!=='box'&&obj.type!=='luggage') continue;
    const dx2=cat.wx-obj.wx, dy2=cat.wy-obj.wy;
    const half = TILE*0.55;
    if (Math.abs(dx2)<half && Math.abs(dy2)<half) {
      if (Math.abs(dx2) >= Math.abs(dy2)) cat.wx = obj.wx + (dx2>0?half:-half);
      else cat.wy = obj.wy + (dy2>0?half:-half);
    }
  }
  cat.wx = Math.max(TILE+R2, Math.min((COLS-1)*TILE-R2, cat.wx));
  cat.wy = Math.max(TILE+R2, Math.min((gs.R-1)*TILE-R2, cat.wy));
}

function updateDogs() { // friendly cats
  const cat = gs.cat;
  for (const fc of gs.dogs) {
    if (fc.heartAnim > 0) fc.heartAnim--;
    if (fc.touchCooldown > 0) fc.touchCooldown--;

    // Wander gently
    fc.wanderTimer--;
    if (fc.wanderTimer <= 0) {
      fc.wanderAngle += (Math.random()-0.5)*1.1;
      fc.wanderTimer = 90 + Math.floor(Math.random()*160);
    }
    const nx = Math.cos(fc.wanderAngle)*fc.speed*0.32;
    const ny = Math.sin(fc.wanderAngle)*fc.speed*0.32;
    fc.wx += nx; fc.wy += ny;
    if (Math.abs(nx)+Math.abs(ny)>0.05) fc.facingAngle = Math.atan2(ny,nx)+Math.PI/2;

    // Clamp + wall bounce
    fc.wx = Math.max(TILE*1.5, Math.min((COLS-1)*TILE-TILE*1.5, fc.wx));
    fc.wy = Math.max(TILE*1.5, Math.min((gs.R-1)*TILE-TILE*1.5, fc.wy));
    const fgr=Math.floor(fc.wy/TILE), fgc=Math.floor(fc.wx/TILE);
    if (fgr>=0&&fgr<gs.R&&fgc>=0&&fgc<COLS &&
        (gs.grid[fgr][fgc]===1||gs.grid[fgr][fgc]===2||gs.grid[fgr][fgc]===3)) {
      fc.wx -= nx; fc.wy -= ny;
      fc.wanderAngle += Math.PI*(0.5+Math.random()*0.5);
    }

    // Touch detection â€” play sound + show heart
    const dist = Math.hypot(cat.wx-fc.wx, cat.wy-fc.wy);
    if (dist < 28 && fc.touchCooldown === 0) {
      fc.touchCooldown = 90;
      fc.heartAnim = 55;
      playFriendCatSound(fc.sound);
      spawnParticles(fc.wx, fc.wy-10, 'ğŸ’•');
    }
    // Soft nudge so cats don't overlap player
    if (dist < 26) {
      const ex=(cat.wx-fc.wx)/(dist||1), ey=(cat.wy-fc.wy)/(dist||1);
      cat.wx += ex*1.0; cat.wy += ey*1.0;
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RENDER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function render() {
  ctx.clearRect(0,0,CW,CH);
  ctx.save(); ctx.translate(0, -gs.camY);
  const camY=gs.camY, def=gs.def;
  const startR=Math.max(0,Math.floor(camY/TILE)-1);
  const endR=Math.min(gs.R,startR+Math.ceil(CH/TILE)+2);

  // Tiles
  for (let r=startR; r<endR; r++)
    for (let c=0; c<COLS; c++)
      drawTile(c*TILE, r*TILE, gs.grid[r][c], def, r, c);

  // Moving platforms (draw under everything)
  for (const obj of gs.interactables) {
    if (obj.type!=='movingPlatform') continue;
    drawMovingPlatform(obj, def);
  }

  // Door
  drawDoor(gs.door.wx, gs.door.wy, def, gs.hasKey, gs.doorShake, gs.time);

  // Key
  if (!gs.key.collected) drawKey(gs.key.wx, gs.key.wy, gs.time);

  // Collectibles
  for (const c of gs.collectibles) if (!c.collected) drawCollectible(c, gs.time);

  // Interactables
  for (const obj of gs.interactables) {
    if (obj.type!=='movingPlatform') drawInteractable(obj, gs.time);
  }

  // Dogs
  for (const dog of gs.dogs) if (dog.state!=='gone') drawDogTopDown(dog, gs.time, gs.cat);

  // Humans
  if (gs.humans) for (const h of gs.humans) drawHuman(h, gs.time);

  // Secrets (hidden until near)
  if (gs.secrets) for (const s of gs.secrets) if (!s.collected) drawSecret(s, gs.time, gs.cat);

  // Nap spots (under cat)
  if (gs.napSpots) drawNapSpots(gs.time);
  // Fish tank
  drawFishTank(gs.time);
  // Hidden room
  drawHiddenRoom(gs.time);
  // Sticker items
  drawStickerItems(gs.time);

  // Dash trail (behind cat)
  drawDashTrail();

  // Rainbow glow (under cat, above trail)
  if (gs.cat.happyFrames > 0) drawRainbowGlow(gs.cat.wx, gs.cat.wy, gs.time, gs.cat.happyFrames);

  // Cat
  drawCatTopDown(ctx, gs.cat.wx, gs.cat.wy, catCfg, gs.time, gs.cat.facingAngle, gs.cat.moving, gs.cat.scratchCooldown);

  // Particles
  drawParticles();
  ctx.restore();

  // Progress bar (screen-space)
  drawProgress();
}

function drawTile(tx,ty,tile,def,r,c) {
  const alt=(r+c)%2===1;
  if (tile===0) {
    ctx.fillStyle=alt?def.floorTile.alt:def.floorTile.fill;
    ctx.fillRect(tx,ty,TILE,TILE);
    ctx.strokeStyle=def.floorTile.line; ctx.lineWidth=0.4;
    ctx.strokeRect(tx,ty,TILE,TILE);
  } else if (tile===1) {
    ctx.fillStyle=def.wallFill; ctx.fillRect(tx,ty,TILE,TILE);
    ctx.fillStyle='rgba(255,255,255,0.15)'; ctx.fillRect(tx,ty,TILE,3);
    const iconSets={home:['ğŸ›‹ï¸','ğŸ“¦','ğŸª‘','ğŸšª'],park:['ğŸŒ³','ğŸª¨','ğŸŒ¿','ğŸŒ²'],building:['ğŸ–¥ï¸','ğŸ“','ğŸª‘','ğŸ—„ï¸'],station:['ğŸ§³','ğŸ—‘ï¸','ğŸ“¦','ğŸª‘']};
    const icons=iconSets[def.theme]||['â¬œ'];
    ctx.font='18px serif'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.globalAlpha=0.65;
    ctx.fillText(icons[((r*COLS+c)*31)%icons.length],tx+TILE/2,ty+TILE/2); ctx.globalAlpha=1;
  } else if (tile===2) {
    ctx.fillStyle=def.elevFill; ctx.fillRect(tx,ty,TILE,TILE);
    ctx.strokeStyle=def.elevStroke; ctx.lineWidth=2.5; ctx.strokeRect(tx+1,ty+1,TILE-2,TILE-2);
    ctx.fillStyle='rgba(0,0,0,0.1)'; ctx.fillRect(tx+3,ty+TILE-4,TILE-3,4); ctx.fillRect(tx+TILE-4,ty+3,4,TILE-4);
    ctx.fillStyle='rgba(255,255,255,0.28)'; ctx.fillRect(tx,ty,TILE,3); ctx.fillRect(tx,ty,3,TILE);
  } else if (tile===3) {
    const wt=gs.time*0.025;
    const wc={home:'#b0bec5',park:'#81d4fa',building:'#263238',station:'#1a237e'};
    ctx.fillStyle=wc[def.theme]||'#90caf9'; ctx.fillRect(tx,ty,TILE,TILE);
    ctx.globalAlpha=0.25+Math.sin(wt+r+c)*0.1;
    ctx.fillStyle='rgba(255,255,255,0.4)';
    ctx.beginPath(); ctx.ellipse(tx+TILE*0.3,ty+TILE*0.45,7,3.5,wt,0,Math.PI*2); ctx.fill();
    ctx.globalAlpha=1;
  }
}

function drawMovingPlatform(obj, def) {
  const pw=obj.w, ph=obj.h+8;
  ctx.save(); ctx.translate(obj.wx-pw/2, obj.wy-ph/2);
  // Platform shadow
  ctx.fillStyle='rgba(0,0,0,0.12)'; ctx.fillRect(4,6,pw,ph);
  // Platform body
  const pColors={home:'#8d6e63',park:'#388e3c',building:'#455a64',station:'#4527a0'};
  ctx.fillStyle=pColors[def.theme]||'#795548';
  ctx.beginPath(); ctx.roundRect(0,0,pw,ph,6); ctx.fill();
  ctx.fillStyle='rgba(255,255,255,0.25)'; ctx.fillRect(0,0,pw,4);
  // Arrow showing direction
  ctx.fillStyle='rgba(255,255,255,0.5)'; ctx.font='12px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(obj.running?(obj.dir>0?'â†’':'â†'):'â¸', pw/2, ph/2);
  ctx.restore();
}

function drawInteractable(obj, t) {
  if (obj.type==='movingPlatform') return;
  ctx.save(); ctx.translate(obj.wx, obj.wy);
  const pulse = obj.animTick>0 ? (obj.animTick/20)*0.4 : 0;
  ctx.scale(1+pulse*0.3, 1+pulse*0.3);
  if (obj.animTick>0) obj.animTick--;

  if (obj.broken) {
    ctx.globalAlpha=0.5;
    ctx.font='18px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(obj.brokenEmoji||'ğŸ’¨',0,0);
  } else {
    ctx.font='22px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
    if (obj.type==='lamp') {
      ctx.fillText(obj.toggled?'ğŸ’¡':'ğŸ•¯ï¸',0,0);
      if (obj.toggled) {
        ctx.globalAlpha=0.15+Math.sin(t*0.1)*0.05;
        ctx.fillStyle='#ffe082'; ctx.beginPath(); ctx.arc(0,0,30,0,Math.PI*2); ctx.fill();
        ctx.globalAlpha=1;
      }
    } else if (obj.type==='lever') {
      ctx.fillText(obj.activated?'ğŸ”›':'ğŸ”§',0,0);
      // glow if activated
      if (obj.activated) {
        ctx.globalAlpha=0.2+Math.sin(t*0.12)*0.1;
        ctx.fillStyle='#ce93d8'; ctx.beginPath(); ctx.arc(0,0,24,0,Math.PI*2); ctx.fill();
        ctx.globalAlpha=1;
      }
    } else {
      ctx.fillText(obj.emoji,0,0);
    }
    // Interaction hint when nearby (handled below in render-hint pass)
  }
  ctx.restore();
}

function drawInteractableHints() {
  if (!gs) return;
  const cat = gs.cat;
  for (const obj of gs.interactables) {
    if (obj.type==='movingPlatform'||!obj.active||obj.broken) continue;
    const dist=Math.hypot(cat.wx-obj.wx, cat.wy-obj.wy);
    if (dist<70) {
      ctx.save(); ctx.translate(obj.wx, obj.wy-22);
      ctx.globalAlpha=0.7+Math.sin(gs.time*0.15)*0.3;
      ctx.font='bold 10px Nunito,sans-serif'; ctx.fillStyle='white';
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.beginPath(); ctx.roundRect(-16,-8,32,16,6); ctx.fill();
      ctx.fillStyle='white'; ctx.fillText('[!]',0,0);
      ctx.restore();
    }
  }
}

function drawDoor(wx,wy,def,hasKey,shake,t) {
  const x=wx+(shake>0?Math.sin(t*0.8)*(shake/5):0), y=wy;
  const dc={home:{frame:'#795548',panel:'#8d6e63'},park:{frame:'#388e3c',panel:'#4caf50'},building:{frame:'#455a64',panel:'#607d8b'},station:{frame:'#4527a0',panel:'#5e35b1'}};
  const c=dc[def.theme]||dc.home;
  ctx.save(); ctx.translate(x,y);
  ctx.fillStyle=c.frame; ctx.fillRect(-22,-30,44,54);
  ctx.fillStyle=hasKey?'#66bb6a':c.panel; ctx.fillRect(-17,-25,34,47);
  ctx.fillStyle='rgba(255,255,255,0.15)';
  ctx.fillRect(-13,-21,13,18); ctx.fillRect(2,-21,13,18);
  ctx.fillRect(-13,-1,13,18); ctx.fillRect(2,-1,13,18);
  ctx.fillStyle=hasKey?'#ffd700':'rgba(255,255,255,0.6)'; ctx.beginPath(); ctx.arc(10,4,4,0,Math.PI*2); ctx.fill();
  if (hasKey) {
    ctx.save(); ctx.globalAlpha=0.3+Math.sin(t*0.1)*0.12;
    ctx.fillStyle='#a5d6a7'; ctx.beginPath(); ctx.arc(0,0,30,0,Math.PI*2); ctx.fill(); ctx.restore();
  }
  ctx.font='bold 8px Nunito,sans-serif'; ctx.fillStyle=hasKey?'#2e7d32':'rgba(255,255,255,0.85)';
  ctx.textAlign='center'; ctx.textBaseline='bottom';
  ctx.fillText(hasKey?'OPEN':'ğŸ”’ LOCKED',0,-32);
  ctx.fillStyle=c.frame; ctx.beginPath(); ctx.arc(0,-30,22,Math.PI,2*Math.PI); ctx.fill();
  ctx.fillStyle=hasKey?'#a5d6a7':c.panel; ctx.beginPath(); ctx.arc(0,-30,17,Math.PI,2*Math.PI); ctx.fill();
  ctx.restore();
}

function drawKey(wx,wy,t) {
  ctx.save(); ctx.translate(wx,wy);

  // Large outer beacon glow â€” visible from far away
  const outerR = 34 + Math.sin(t*0.07)*6;
  const grd = ctx.createRadialGradient(0,0,4,0,0,outerR);
  grd.addColorStop(0,'rgba(255,220,0,0.45)');
  grd.addColorStop(0.5,'rgba(255,180,0,0.22)');
  grd.addColorStop(1,'rgba(255,160,0,0)');
  ctx.fillStyle=grd;
  ctx.beginPath(); ctx.arc(0,0,outerR,0,Math.PI*2); ctx.fill();

  // Pulsing solid ring
  ctx.strokeStyle=`rgba(255,215,0,${0.55+Math.sin(t*0.12)*0.35})`;
  ctx.lineWidth=2.5;
  ctx.beginPath(); ctx.arc(0,0,22+Math.sin(t*0.09)*4,0,Math.PI*2); ctx.stroke();

  // Second smaller ring, offset phase
  ctx.strokeStyle=`rgba(255,255,150,${0.4+Math.sin(t*0.12+2)*0.3})`;
  ctx.lineWidth=1.5;
  ctx.beginPath(); ctx.arc(0,0,15+Math.sin(t*0.11+1)*3,0,Math.PI*2); ctx.stroke();

  // Key emoji â€” larger, strong shadow
  ctx.shadowColor='#ffd700'; ctx.shadowBlur=18+Math.sin(t*0.1)*8;
  const s = 1.0+Math.sin(t*0.08)*0.1; ctx.scale(s,s);
  ctx.font='28px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText('ğŸ—ï¸',0,1);
  ctx.shadowBlur=0;

  // 4 orbiting sparkles
  ctx.globalAlpha=0.85;
  ctx.font='11px serif';
  for(let i=0;i<4;i++){
    const a = t*0.06 + i*Math.PI/2;
    const r = 28+Math.sin(t*0.1+i)*4;
    ctx.fillText(['âœ¨','â­','âœ¨','ğŸ’›'][i], Math.cos(a)*r, Math.sin(a)*r);
  }
  ctx.restore();
}

function drawCollectible(c,t) {
  const bob = Math.sin(t*0.07+c.bob)*3;
  ctx.save();
  ctx.translate(c.wx, c.wy+bob);

  // Glow ring underneath
  const isFood = c.type==='food';
  const isToy  = c.type==='toy'||c.type==='flower';
  const isMouse= c.type==='mouse'||c.type==='goldenmouse'||c.golden;
  const ringColor = isMouse?'#ffd700': isFood?'#f48fb1':'#ce93d8';
  const ringR = isMouse ? 18 : 14;
  const ringAlpha = 0.35 + Math.sin(t*0.1+c.bob)*0.18;
  ctx.globalAlpha = ringAlpha;
  ctx.fillStyle = ringColor;
  ctx.beginPath(); ctx.arc(0, 0, ringR, 0, Math.PI*2); ctx.fill();
  // Outer pulse ring
  const pulseR = ringR + 4 + Math.sin(t*0.08+c.bob)*4;
  ctx.globalAlpha = ringAlpha*0.4;
  ctx.beginPath(); ctx.arc(0, 0, pulseR, 0, Math.PI*2); ctx.fill();
  ctx.globalAlpha = 1;

  // Drop shadow for depth
  ctx.shadowColor = 'rgba(0,0,0,0.35)';
  ctx.shadowBlur = 6;
  ctx.shadowOffsetY = 3;

  // Golden glow
  if (isMouse) { ctx.shadowColor='#ffd700'; ctx.shadowBlur=14+Math.sin(t*0.1)*6; ctx.shadowOffsetY=0; }

  ctx.font = isMouse?'26px serif':'22px serif';
  ctx.textAlign='center'; ctx.textBaseline='middle';
  if (c.moveSpeed>0&&c.moveDir<0) ctx.scale(-1,1);
  ctx.fillText(c.emoji, 0, 0);
  ctx.restore();
}

function playFriendCatSound(soundType) {
  try {
    const ac = getAudio(), t = ac.currentTime;
    if (soundType === 'purr') {
      // Gentle purr â€” low rumbling sine
      const o = ac.createOscillator(), g = ac.createGain();
      const lfo = ac.createOscillator(), lg = ac.createGain();
      o.type='sine'; o.frequency.value=62;
      lfo.type='sine'; lfo.frequency.value=26; lg.gain.value=14;
      lfo.connect(lg); lg.connect(o.frequency);
      g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(0.18,t+0.08);
      g.gain.setValueAtTime(0.18,t+0.35); g.gain.exponentialRampToValueAtTime(0.001,t+0.55);
      o.connect(g); g.connect(ac.destination);
      o.start(t); o.stop(t+0.6); lfo.start(t); lfo.stop(t+0.6);
    } else if (soundType === 'mew') {
      // Short mew â€” higher pitch meow
      const o = ac.createOscillator(), g = ac.createGain();
      o.type='sine'; o.frequency.setValueAtTime(520,t); o.frequency.exponentialRampToValueAtTime(380,t+0.18);
      g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(0.16,t+0.03);
      g.gain.exponentialRampToValueAtTime(0.001,t+0.22);
      o.connect(g); g.connect(ac.destination); o.start(t); o.stop(t+0.25);
    } else if (soundType === 'chirp') {
      // Chirp trill â€” rapidly oscillating
      const o = ac.createOscillator(), g = ac.createGain();
      const trem = ac.createOscillator(), tg = ac.createGain();
      o.type='triangle'; o.frequency.value=680;
      trem.type='sine'; trem.frequency.value=22; tg.gain.value=0.12;
      trem.connect(tg); tg.connect(g.gain);
      g.gain.setValueAtTime(0.14,t); g.gain.exponentialRampToValueAtTime(0.001,t+0.28);
      o.connect(g); g.connect(ac.destination);
      o.start(t); o.stop(t+0.3); trem.start(t); trem.stop(t+0.3);
    } else {
      // trill â€” two-note warble
      [0, 0.1].forEach((dt,i) => {
        const o = ac.createOscillator(), g = ac.createGain();
        o.type='sine'; o.frequency.value = i===0?440:520;
        g.gain.setValueAtTime(0,t+dt); g.gain.linearRampToValueAtTime(0.14,t+dt+0.04);
        g.gain.exponentialRampToValueAtTime(0.001,t+dt+0.18);
        o.connect(g); g.connect(ac.destination); o.start(t+dt); o.stop(t+dt+0.2);
      });
    }
  } catch(e){}
}

function drawDogTopDown(fc, t, cat) {
  // Draw a friendly roaming cat
  const cfg = {colorIdx:fc.colorIdx, pattern:fc.pattern, eyeIdx:fc.eyeIdx, accessory:'none'};
  const bob = Math.sin(t*0.09 + fc.bob)*2;
  const moving = true; // always animate gently

  ctx.save();
  ctx.translate(fc.wx, fc.wy + bob);
  ctx.rotate(fc.facingAngle);

  // Soft shadow
  ctx.fillStyle='rgba(0,0,0,0.07)';
  ctx.beginPath(); ctx.ellipse(0,6,12,5,0,0,Math.PI*2); ctx.fill();

  // Reuse the main cat drawing but smaller
  ctx.scale(0.72, 0.72);
  drawCatTopDown(ctx, 0, 0, cfg, t + fc.bob*40, 0, true, 0);
  ctx.restore();

  // Name label (shows on nearby approach)
  const dist = Math.hypot(cat.wx-fc.wx, cat.wy-fc.wy);
  if (dist < 70) {
    ctx.save();
    ctx.globalAlpha = Math.min(1, (70-dist)/30);
    ctx.font = 'bold 9px Nunito, sans-serif';
    ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
    ctx.fillStyle = 'rgba(0,0,0,0.45)';
    ctx.fillText(fc.name, fc.wx+0.5, fc.wy-22+0.5);
    ctx.fillStyle = 'white';
    ctx.fillText(fc.name, fc.wx, fc.wy-22);
    ctx.restore();
  }

  // Heart animation when touched
  if (fc.heartAnim > 0) {
    const prog = fc.heartAnim/55;
    ctx.save();
    ctx.globalAlpha = prog * 0.9;
    ctx.font = `${10+prog*6}px serif`;
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText('ğŸ’•', fc.wx + Math.sin(fc.heartAnim*0.3)*8, fc.wy - 28 - (55-fc.heartAnim)*0.6);
    ctx.restore();
  }
}



function drawSecret(s, t, cat) {
  const dist = Math.hypot(cat.wx-s.wx, cat.wy-s.wy);
  const nearbyFactor = Math.max(0, 1-(dist/80)); // shimmer builds as you approach

  ctx.save();
  ctx.translate(s.wx, s.wy);

  if (s.revealed) {
    // Fully revealed â€” pulse and glow
    const pulse = 0.85 + Math.sin(t*0.1+s.bob)*0.18;
    ctx.save(); ctx.scale(pulse, pulse);
    ctx.shadowColor='#ffd700'; ctx.shadowBlur=14+Math.sin(t*0.1)*6;
    ctx.globalAlpha=1;
    ctx.font='22px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(s.emoji, 0, 0);
    ctx.restore();
    // Gold ring
    ctx.globalAlpha=0.4+Math.sin(t*0.12)*0.2;
    ctx.strokeStyle='#ffd700'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc(0,0,18,0,Math.PI*2); ctx.stroke();
    ctx.globalAlpha=1;
    // "SECRET" label
    ctx.font='bold 8px Nunito,sans-serif';
    ctx.fillStyle='#ffd700'; ctx.textAlign='center'; ctx.textBaseline='bottom';
    ctx.fillText('SECRET',0,-22);
  } else if (nearbyFactor > 0) {
    // Subtle shimmer hint when nearby â€” just barely visible
    ctx.globalAlpha = nearbyFactor * 0.35;
    ctx.fillStyle='#ffd700';
    // Sparkle particles at item location
    ctx.font='10px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
    const sparkAngle = t*0.08 + s.bob;
    ctx.fillText('âœ¨', Math.cos(sparkAngle)*10, Math.sin(sparkAngle)*10);
    ctx.fillText('âœ¨', Math.cos(sparkAngle+Math.PI)*8, Math.sin(sparkAngle+Math.PI)*8);
    ctx.globalAlpha=1;
  }
  ctx.restore();
}

function drawHuman(h, t) {
  const o = h.outfit;
  const bob = h.moving ? Math.sin(t*0.22)*1.5 : 0;
  const isOffering = h.state==='offering';
  const armWave = isOffering ? Math.sin(t*0.25)*0.4 : Math.sin(t*0.1)*0.15;

  ctx.save();
  ctx.translate(h.wx, h.wy + bob);
  ctx.rotate(h.facingAngle);

  // Shadow
  ctx.fillStyle='rgba(0,0,0,0.08)';
  ctx.beginPath(); ctx.ellipse(0,6,14,5,0,0,Math.PI*2); ctx.fill();

  // Legs
  const legSwing = h.moving ? Math.sin(t*0.2)*8 : 0;
  ctx.fillStyle=o.bottom; ctx.strokeStyle='rgba(0,0,0,0.15)'; ctx.lineWidth=1;
  [[-5,14+legSwing],[5,14-legSwing]].forEach(([lx,ly])=>{
    ctx.beginPath(); ctx.roundRect(lx-4,8,8,ly-8,3); ctx.fill(); ctx.stroke();
  });
  // Feet
  ctx.fillStyle='#5d4037';
  [[-5,14+legSwing],[5,14-legSwing]].forEach(([lx,ly])=>{
    ctx.beginPath(); ctx.ellipse(lx,ly+2,5,3,0,0,Math.PI*2); ctx.fill();
  });

  // Body
  ctx.fillStyle=o.top; ctx.strokeStyle='rgba(0,0,0,0.1)'; ctx.lineWidth=1.5;
  ctx.beginPath(); ctx.roundRect(-9,-4,18,13,4); ctx.fill(); ctx.stroke();

  // Arms
  ctx.fillStyle=o.top; ctx.strokeStyle='rgba(0,0,0,0.1)'; ctx.lineWidth=1;
  const leftArm = h.moving ? armWave : armWave;
  const rightArm = -leftArm;
  // Left arm
  ctx.save(); ctx.translate(-9,0); ctx.rotate(leftArm);
  ctx.beginPath(); ctx.roundRect(-4,0,8,10,3); ctx.fill(); ctx.stroke(); ctx.restore();
  // Right arm â€” if offering, extends forward holding gift
  ctx.save(); ctx.translate(9,0); ctx.rotate(isOffering ? -0.6 : rightArm);
  ctx.beginPath(); ctx.roundRect(-4,0,8,10,3); ctx.fill(); ctx.stroke();
  if (isOffering) {
    // Hand holding gift
    ctx.fillStyle=o.skin; ctx.beginPath(); ctx.arc(0,12,4,0,Math.PI*2); ctx.fill();
    ctx.font='11px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(h.gift==='treat'?'ğŸŸ':'ğŸ¤š',0,12);
  }
  ctx.restore();

  // Head
  ctx.fillStyle=o.skin; ctx.strokeStyle='rgba(0,0,0,0.12)'; ctx.lineWidth=1.5;
  ctx.beginPath(); ctx.arc(0,-12,10,0,Math.PI*2); ctx.fill(); ctx.stroke();

  // Hair â€” simple arc
  const hairColors=['#5d4037','#212121','#ffd54f','#ef9a9a','#b0bec5'];
  ctx.fillStyle=hairColors[Math.abs(h.wx*3|0)%hairColors.length];
  ctx.beginPath(); ctx.arc(0,-14,10,Math.PI,2*Math.PI); ctx.fill();

  // Face
  ctx.fillStyle='#3e2723';
  ctx.beginPath(); ctx.arc(-3,-12,1.8,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(3,-12,1.8,0,Math.PI*2); ctx.fill();
  // Smile when offering
  ctx.strokeStyle='#3e2723'; ctx.lineWidth=1.5; ctx.lineCap='round';
  ctx.beginPath();
  if (isOffering) {
    ctx.arc(0,-10,4,0.2,Math.PI-0.2); // big smile
  } else {
    ctx.arc(0,-10,3,0.3,Math.PI-0.3); // small smile
  }
  ctx.stroke();

  // Gift bubble when nearby but not yet offering
  if (h.offerCooldown === 0 && h.state!=='offering') {
    const giftEmoji = h.gift==='treat'?'ğŸŸ':'ğŸ¤—';
    ctx.save();
    ctx.globalAlpha=0.7+Math.sin(t*0.12)*0.3;
    ctx.font='14px serif'; ctx.textAlign='center';
    // Small floating icon hint
    ctx.fillText(giftEmoji, 2, -26-Math.sin(t*0.08)*3);
    ctx.restore();
  }

  // Offering animation â€” sparkle burst
  if (h.giftAnim > 0) {
    const prog = h.giftAnim/40;
    ctx.save(); ctx.globalAlpha=prog;
    ctx.font='14px serif'; ctx.textAlign='center';
    ctx.fillText('âœ¨', -15*prog, -20-10*prog);
    ctx.fillText('âœ¨',  15*prog, -20-8*prog);
    ctx.restore();
  }

  ctx.restore();
}

function drawParticles() {
  gs.particles=gs.particles.filter(p=>p.life>0);
  for (const p of gs.particles) {
    if (p.isDashTrail) { p.life-=0.07; continue; } // drawn by drawDashTrail
    ctx.save(); ctx.globalAlpha=p.life;
    ctx.font=p.size+'px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(p.emoji,p.wx,p.wy); ctx.restore();
    p.wx+=p.vx; p.wy+=p.vy; p.vy-=0.08; p.life-=0.022;
  }
}

function drawDashTrail() {
  for (const p of gs.particles) {
    if (!p.isDashTrail) continue;
    ctx.save();
    ctx.globalAlpha = p.life * 0.7;
    ctx.fillStyle = p.col || '#f8bbd0';
    ctx.beginPath(); ctx.arc(p.wx, p.wy, p.size/2, 0, Math.PI*2); ctx.fill();
    ctx.restore();
    p.life -= 0.07;
  }
}

function drawRainbowGlow(wx, wy, t, frames) {
  const intensity = Math.min(1, frames / 60); // fade in/out
  const ringCount = 3;
  for (let i = 0; i < ringCount; i++) {
    const hue = ((t * 3 + i * (360/ringCount)) % 360);
    const r = 22 + i*5 + Math.sin(t*0.15+i)*3;
    ctx.save();
    ctx.globalAlpha = intensity * (0.35 - i*0.08) * (0.7 + Math.sin(t*0.1+i)*0.3);
    ctx.strokeStyle = `hsl(${hue},100%,65%)`;
    ctx.lineWidth = 4 - i;
    ctx.beginPath(); ctx.arc(wx, wy, r, 0, Math.PI*2); ctx.stroke();
    ctx.restore();
  }
  // Sparkles orbiting
  if (frames > 30) {
    for (let i = 0; i < 4; i++) {
      const a = t*0.08 + i*Math.PI/2;
      const hue = ((t*4 + i*90) % 360);
      ctx.save();
      ctx.globalAlpha = intensity * 0.8;
      ctx.fillStyle = `hsl(${hue},100%,70%)`;
      ctx.beginPath();
      ctx.arc(wx + Math.cos(a)*28, wy + Math.sin(a)*28, 3, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  }
}

function drawProgress() {
  const pct=Math.max(0,1-(gs.cat.wy/(gs.R*TILE)));
  const bx=CW-13,by=40,bh=CH-80;
  ctx.fillStyle='rgba(255,255,255,0.2)'; ctx.beginPath(); ctx.roundRect(bx-3,by,6,bh,3); ctx.fill();
  const fh=bh*pct;
  ctx.fillStyle='rgba(244,143,177,0.65)'; ctx.beginPath(); ctx.roundRect(bx-3,by+bh-fh,6,fh,3); ctx.fill();
  ctx.fillStyle='#f48fb1'; ctx.beginPath(); ctx.arc(bx,by+bh-fh,5,0,Math.PI*2); ctx.fill();
  ctx.font='12px serif'; ctx.textAlign='center'; ctx.fillText('ğŸ',bx,by+4);
  // Also draw interactable hints in world space
  ctx.save(); ctx.translate(0,-gs.camY); drawInteractableHints(); ctx.restore();
}

function spawnParticles(wx,wy,emoji='âœ¨') {
  const emojis=[emoji,'âœ¨','ğŸŒ¸','â­'];
  for (let i=0;i<5;i++) gs.particles.push({
    wx,wy,vx:(Math.random()-0.5)*3.5,vy:-2-Math.random()*2.5,
    life:1,size:12+Math.random()*6,emoji:emojis[Math.floor(Math.random()*emojis.length)]
  });
}

function spawnPop(wx,wy,text,color) {
  const layer=document.getElementById('popup-layer');
  const screenX=wx, screenY=wy-gs.camY-28;
  if (screenY<-20||screenY>CH+20) return;
  const el=document.createElement('div'); el.className='pop';
  el.style.left=Math.max(4,Math.min(CW-90,screenX-30))+'px';
  el.style.top=Math.max(4,screenY)+'px';
  el.style.color=color||'#5d4037';
  el.textContent=text; layer.appendChild(el);
  setTimeout(()=>el.remove(),1100);
}

function updateHUD() {
  document.getElementById('key-indicator').textContent=gs.hasKey?'ğŸ—ï¸ âœ“':'ğŸ—ï¸ âœ—';
  const waterEl = document.getElementById('watering-hud');
  if (waterEl) waterEl.style.display = gs.hasWateringCan ? '' : 'none';
  const dtEl = document.getElementById('daytime-hud');
  if (dtEl) dtEl.textContent = getDayOverlay().label;
  // Happy indicator
  const happyEl = document.getElementById('happy-hud');
  if (gs.cat.happyFrames > 0) {
    happyEl.style.display='';
    const secs = Math.ceil(gs.cat.happyFrames/60);
    document.getElementById('happy-display').textContent=`ğŸŒˆ ${secs}s`;
  } else {
    happyEl.style.display='none';
  }
}


function showGameOver() {
  stopMusic();
  document.getElementById('go-name').textContent=`${catName} got lostâ€¦ ğŸ˜¿`;
  document.getElementById('hud').style.display='none';
  document.getElementById('game-canvas-wrap').style.display='none';
  showScreen('gameover-screen');
}

function showLevelComplete() {
  stopMusic();
  if (currentLevel+1>unlockedLevels) unlockedLevels=currentLevel+1;
  const def=LEVEL_DEFS[currentLevel];
  document.getElementById('lc-emoji').textContent=def.icon;
  document.getElementById('lc-title').textContent=currentLevel===3?'ğŸŠ All Done!':'Level Complete!';
  document.getElementById('lc-desc').textContent=def.completeTxt;
  document.getElementById('lc-next-btn').style.display=currentLevel<3?'':'none';
  document.getElementById('hud').style.display='none';
  document.getElementById('game-canvas-wrap').style.display='none';
  showScreen('levelcomplete-screen');
  updateLevelCards();
}

// Init
startPreviewAnim();
renderCatPreview('titleCatCanvas',130,130);
</script>
</body>
</html>
