<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Neko Day ğŸ±</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Nunito:wght@400;700;900&family=Fredoka+One&display=swap');
:root{
  --pink:#f48fb1;--lavender:#ce93d8;--peach:#ffcc80;--mint:#b2dfdb;
  --text:#5d4037;--shadow:rgba(180,100,140,0.22);
  --W:420px;--H:700px;
}
*{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent;}
html,body{
  width:100%;height:100%;height:100dvh;
  font-family:'Nunito',sans-serif;
  background:#1a0a2e;
  display:flex;align-items:center;justify-content:center;
  overflow:hidden;user-select:none;overscroll-behavior:none;
}
#app{
  width:min(420px,100vw);
  height:min(700px,100dvh);
  position:relative;overflow:hidden;
  background:#fff9f0;
  border-radius:clamp(0px,3vw,24px);
  box-shadow:0 0 80px rgba(244,143,177,0.4),0 0 0 1px rgba(255,255,255,0.1);
}
/* safe-area insets for notched devices */
@supports(padding:env(safe-area-inset-bottom)){
  .screen{padding-bottom:max(20px,env(safe-area-inset-bottom));}
  #touch-controls{padding-bottom:max(20px,env(safe-area-inset-bottom));}
}

/* â”€â”€ SCREENS â”€â”€ */
.screen{
  position:absolute;inset:0;
  display:flex;flex-direction:column;
  align-items:center;justify-content:center;
  gap:14px;padding:20px 18px;
  overflow-y:auto;
  transition:opacity 0.3s;
}
.screen.hidden{display:none;}

/* â”€â”€ TITLE â”€â”€ */
#title-screen{
  background:linear-gradient(170deg,#fde8f5 0%,#f3e5f5 40%,#e8f5e9 100%);
}
.title-logo{
  font-family:'Fredoka One',cursive;
  font-size:52px;color:var(--text);
  text-shadow:3px 3px 0 var(--pink),6px 6px 0 rgba(244,143,177,.25);
  letter-spacing:2px;text-align:center;
  animation:titleBounce 2.2s ease-in-out infinite;
}
.title-sub{font-size:14px;color:#a0887a;font-weight:700;text-align:center;line-height:1.7;}
#title-cat-preview{
  width:140px;height:140px;
  border-radius:50%;
  background:white;
  box-shadow:0 8px 32px var(--shadow),0 0 0 4px rgba(244,143,177,0.2);
  display:flex;align-items:center;justify-content:center;
  overflow:hidden;
}
#title-cat-preview canvas{display:block;}

/* â”€â”€ CUSTOM â”€â”€ */
#custom-screen{
  background:linear-gradient(170deg,#e8f5e9 0%,#f3e5f5 60%,#fde8f5 100%);
  justify-content:flex-start;padding-top:16px;
  gap:10px;
}
#custom-screen h2{
  font-family:'Fredoka One',cursive;
  font-size:28px;color:var(--text);
  text-shadow:2px 2px 0 var(--pink);
  margin-top:4px;
}
.custom-section{width:100%;max-width:360px;}
.custom-label{
  font-size:12px;font-weight:900;color:#b06090;
  text-transform:uppercase;letter-spacing:1px;
  margin-bottom:6px;display:block;
}
.swatch-row{display:flex;gap:7px;flex-wrap:wrap;}
.swatch{
  width:36px;height:36px;border-radius:50%;
  border:3px solid transparent;cursor:pointer;
  transition:transform .12s,border-color .12s;
  touch-action:manipulation;
  box-shadow:0 2px 6px rgba(0,0,0,.15);
}
.swatch.selected{border-color:#5d4037;transform:scale(1.2);}
.swatch:active{transform:scale(0.9);}
.option-row{display:flex;gap:7px;flex-wrap:wrap;}
.opt-btn{
  padding:6px 12px;border-radius:20px;
  border:2.5px solid transparent;
  background:white;cursor:pointer;
  font-family:'Nunito',sans-serif;font-size:12px;font-weight:900;
  color:var(--text);box-shadow:0 2px 8px var(--shadow);
  transition:all .12s;touch-action:manipulation;
}
.opt-btn.selected{border-color:var(--pink);background:#fce4ec;color:#ad1457;}
.opt-btn:active{transform:scale(0.93);}

/* cat preview card */
#custom-preview-wrap{
  display:flex;flex-direction:column;align-items:center;gap:6px;
}
#preview-canvas-wrap{
  width:100px;height:100px;border-radius:50%;
  background:white;box-shadow:0 4px 18px var(--shadow),0 0 0 3px rgba(244,143,177,0.3);
  display:flex;align-items:center;justify-content:center;overflow:hidden;
}
#cat-name-input{
  padding:8px 18px;border-radius:30px;
  border:2.5px solid #f8bbd0;
  font-family:'Nunito',sans-serif;font-size:15px;font-weight:700;
  color:var(--text);background:white;text-align:center;outline:none;
  width:180px;box-shadow:0 2px 8px var(--shadow);
}
#cat-name-input:focus{border-color:var(--pink);}


/* â”€â”€ GAME SELECT â”€â”€ */
#level-screen{
  background:linear-gradient(170deg,#fff9f0 0%,#fce4ec 60%,#f3e5f5 100%);
  justify-content:flex-start;
  padding-top:14px;
}
#level-screen h2{
  font-family:'Fredoka One',cursive;font-size:26px;
  color:var(--text);text-shadow:2px 2px 0 var(--peach);
  flex-shrink:0;
}
.level-list{display:flex;flex-direction:column;gap:8px;width:100%;max-width:340px;flex-shrink:1;}
.level-card{
  background:white;border-radius:16px;padding:11px 16px;
  border:3px solid transparent;cursor:pointer;
  display:flex;align-items:center;gap:12px;
  box-shadow:0 4px 14px var(--shadow);
  transition:all .15s;touch-action:manipulation;
  flex-shrink:0;
  min-height:60px;
}
.level-card.unlocked{border-color:var(--pink);}
.level-card:active:not(.locked){transform:scale(0.97);}
.level-icon{font-size:32px;flex-shrink:0;}
.level-card-text{}
.level-card-name{font-size:15px;font-weight:900;color:var(--text);}
.level-card-desc{font-size:11px;font-weight:700;color:#a0887a;margin-top:2px;}

/* â”€â”€ GAME OVER / COMPLETE â”€â”€ */
#gameover-screen{background:linear-gradient(170deg,#fde8f5,#f3e5f5);}
#levelcomplete-screen{background:linear-gradient(170deg,#e8f5e9,#f3e5f5);}
#gameover-screen h2,#levelcomplete-screen h2{
  font-family:'Fredoka One',cursive;font-size:36px;
  color:var(--text);text-align:center;
}
.result-emoji{font-size:72px;animation:titleBounce 1.5s ease-in-out infinite;}
.result-score{font-size:22px;font-weight:900;color:var(--text);}

/* â”€â”€ BUTTONS â”€â”€ */
.btn{
  background:linear-gradient(135deg,var(--pink),var(--lavender));
  color:white;border:none;
  padding:12px 36px;border-radius:50px;
  font-family:'Fredoka One',cursive;font-size:18px;
  cursor:pointer;
  box-shadow:0 5px 0 #b06090,0 8px 18px rgba(200,100,150,.3);
  transition:transform .1s,box-shadow .1s;touch-action:manipulation;
}
.btn:active{transform:translateY(3px);box-shadow:0 2px 0 #b06090;}
.btn-green{background:linear-gradient(135deg,#66bb6a,#26a69a);box-shadow:0 5px 0 #2e7d32,0 8px 16px rgba(50,150,80,.3);}
.btn-green:active{box-shadow:0 2px 0 #2e7d32;}
.btn-sm{font-size:14px;padding:9px 24px;}
.btn-grey{background:linear-gradient(135deg,#ce93d8,#b0bec5);box-shadow:0 5px 0 #7b6080;}
.btn-grey:active{box-shadow:0 2px 0 #7b6080;}
.btn-row{display:flex;gap:10px;flex-wrap:wrap;justify-content:center;}

/* â”€â”€ HUD â”€â”€ */
#hud{
  position:absolute;top:0;left:0;right:0;
  display:none;
  padding:max(8px,env(safe-area-inset-top)) 10px 6px;
  background:linear-gradient(180deg,rgba(255,249,240,0.96) 60%,rgba(255,249,240,0));
  z-index:20;pointer-events:none;
}
#hud .hud-row{pointer-events:none;}
#hud .hud-pill[onclick],#hud #games-back-btn{pointer-events:auto;touch-action:manipulation;}
.hud-row{display:flex;align-items:center;gap:6px;flex-wrap:wrap;}
.hud-pill{
  background:rgba(255,255,255,0.9);
  backdrop-filter:blur(6px);
  border-radius:20px;padding:5px 12px;
  display:flex;align-items:center;gap:5px;
  box-shadow:0 2px 8px var(--shadow);
  font-size:12px;font-weight:700;color:var(--text);
  min-height:32px;
}
#games-back-btn{
  background:rgba(244,143,177,0.18);
  border:1.5px solid rgba(244,143,177,0.5);
  font-size:13px;
}
#key-indicator{font-size:14px;}

/* â”€â”€ GAME CANVAS â”€â”€ */
#game-canvas-wrap{
  position:absolute;inset:0;
  display:none;
  background:#1a1a2e;
}
#gameCanvas{
  display:block;
  width:100%;height:100%;
  object-fit:contain;
  touch-action:none;
}

/* â”€â”€ TOUCH CONTROLS â”€â”€ */
#touch-controls{
  position:absolute;bottom:0;left:0;right:0;
  display:none;
  padding:12px 16px 20px;
  justify-content:space-between;align-items:flex-end;
  pointer-events:none;
  z-index:25;
}
#joystick-zone{
  width:110px;height:110px;
  border-radius:50%;
  background:rgba(255,255,255,0.25);
  backdrop-filter:blur(6px);
  border:2px solid rgba(255,255,255,0.4);
  position:relative;pointer-events:auto;
  touch-action:none;
}
#joystick-knob{
  position:absolute;
  width:46px;height:46px;border-radius:50%;
  background:rgba(255,255,255,0.75);
  border:2.5px solid rgba(244,143,177,0.8);
  box-shadow:0 3px 10px rgba(180,100,140,.3);
  top:50%;left:50%;
  transform:translate(-50%,-50%);
  transition:transform 0.05s;
  pointer-events:none;
}
.action-btns{display:flex;flex-direction:column;gap:10px;align-items:flex-end;pointer-events:auto;}
.touch-action-btn{
  width:64px;height:64px;border-radius:50%;
  background:rgba(255,255,255,0.65);
  backdrop-filter:blur(6px);
  border:2.5px solid rgba(244,143,177,0.6);
  box-shadow:0 3px 12px rgba(180,100,140,.25);
  display:flex;align-items:center;justify-content:center;
  font-size:22px;cursor:pointer;touch-action:manipulation;
  user-select:none;-webkit-user-select:none;
  transition:transform .08s,background .1s;
  pointer-events:auto;
}
.touch-action-btn.pressed{background:rgba(244,143,177,0.5);transform:scale(0.88);}
#scratch-btn{
  background:linear-gradient(135deg,rgba(244,143,177,0.7),rgba(206,147,216,0.7));
  border-color:rgba(244,143,177,0.9);width:72px;height:72px;font-size:26px;
}

/* â”€â”€ POPUP SCORES â”€â”€ */
.pop{
  position:absolute;pointer-events:none;z-index:30;
  font-size:16px;font-weight:900;
  font-family:'Nunito',sans-serif;color:var(--text);
  animation:popUp 1.1s ease-out forwards;
  white-space:nowrap;
}
@keyframes popUp{0%{transform:translateY(0) scale(.7);opacity:1;}100%{transform:translateY(-60px) scale(1.1);opacity:0;}}
@keyframes titleBounce{0%,100%{transform:translateY(0)}50%{transform:translateY(-8px)}}
@keyframes doorShake{0%,100%{transform:translateX(0)}20%{transform:translateX(-5px)}40%{transform:translateX(5px)}60%{transform:translateX(-4px)}80%{transform:translateX(4px)}}
@keyframes keyPulse{0%,100%{filter:drop-shadow(0 0 4px #ffd700)}50%{filter:drop-shadow(0 0 12px #ffd700) drop-shadow(0 0 4px #ff8c00)}}

@media(pointer:coarse){#touch-controls{display:flex;}}
#touch-controls.hide-joystick #joystick-zone{visibility:hidden;pointer-events:none;}
#touch-controls.hidden-all{display:none !important;}
#touch-controls.hide-scratch .action-btns{visibility:hidden;pointer-events:none;}
@media(min-width:421px){
  #app{box-shadow:0 0 100px rgba(244,143,177,0.5),0 0 0 1px rgba(255,255,255,0.08);}
}
</style>
</head>
<body>
<div id="app">

<!-- TITLE -->
<div class="screen" id="title-screen">
  <div id="title-cat-preview"><canvas id="titleCatCanvas" width="130" height="130"></canvas></div>
  <div class="title-logo">Neko Day âœ¨</div>
  <div class="title-sub">Six cozy games Â· customize your cat<br>âš½ ğŸª¨ ğŸ£ ğŸ§¶ ğŸŒ± ğŸŒ³</div>
      <div style="position:absolute;top:14px;right:14px;display:flex;gap:8px;"><button class="btn btn-grey" style="padding:8px 16px;font-size:14px;min-height:44px;" onclick="toggleMusic()" title="Toggle music">ğŸµ</button></div>
  <button class="btn" onclick="showScreen('custom-screen')">Customize Your Cat ğŸ±</button>
  <button class="btn btn-grey btn-sm" style="margin-top:-4px" onclick="quickPlay()">Quick Play â†’</button>
</div>

<!-- CUSTOMISE -->
<div class="screen hidden" id="custom-screen">
  <h2>Your Cat âœ¨</h2>
  <div id="custom-preview-wrap">
    <div id="preview-canvas-wrap"><canvas id="previewCanvas" width="90" height="90"></canvas></div>
    <input class="name-box" id="cat-name-input" placeholder="Mochi" maxlength="14" value="Mochi" oninput="updatePreview()"/>
  </div>

  <div class="custom-section">
    <span class="custom-label">ğŸ¨ Fur Color</span>
    <div class="swatch-row" id="color-swatches">
      <div class="swatch selected" data-idx="0" style="background:#fff9f0;border:2px solid #ddd" onclick="setCatProp('colorIdx',0)"></div>
      <div class="swatch" data-idx="1" style="background:#ffb74d" onclick="setCatProp('colorIdx',1)"></div>
      <div class="swatch" data-idx="2" style="background:#9e9e9e" onclick="setCatProp('colorIdx',2)"></div>
      <div class="swatch" data-idx="3" style="background:#424242" onclick="setCatProp('colorIdx',3)"></div>
      <div class="swatch" data-idx="4" style="background:#ffcc80" onclick="setCatProp('colorIdx',4)"></div>
      <div class="swatch" data-idx="5" style="background:#a1887f" onclick="setCatProp('colorIdx',5)"></div>
      <div class="swatch" data-idx="6" style="background:#f8bbd0" onclick="setCatProp('colorIdx',6)"></div>
    </div>
  </div>

  <div class="custom-section">
    <span class="custom-label">ğŸ¾ Pattern</span>
    <div class="option-row" id="pattern-opts">
      <div class="opt-btn selected" data-val="solid" onclick="setCatProp('pattern','solid')">Solid</div>
      <div class="opt-btn" data-val="tabby" onclick="setCatProp('pattern','tabby')">Tabby</div>
      <div class="opt-btn" data-val="spots" onclick="setCatProp('pattern','spots')">Spotty</div>
      <div class="opt-btn" data-val="tuxedo" onclick="setCatProp('pattern','tuxedo')">Tuxedo</div>
      <div class="opt-btn" data-val="calico" onclick="setCatProp('pattern','calico')">Calico</div>
    </div>
  </div>

  <div class="custom-section">
    <span class="custom-label">ğŸ‘ï¸ Eye Color</span>
    <div class="swatch-row" id="eye-swatches">
      <div class="swatch selected" data-idx="0" style="background:#4caf50" onclick="setCatProp('eyeIdx',0)"></div>
      <div class="swatch" data-idx="1" style="background:#2196f3" onclick="setCatProp('eyeIdx',1)"></div>
      <div class="swatch" data-idx="2" style="background:#ff9800" onclick="setCatProp('eyeIdx',2)"></div>
      <div class="swatch" data-idx="3" style="background:#9c27b0" onclick="setCatProp('eyeIdx',3)"></div>
      <div class="swatch" data-idx="4" style="background:linear-gradient(135deg,#2196f3,#ff9800)" onclick="setCatProp('eyeIdx',4)"></div>
    </div>
  </div>

  <div class="custom-section">
    <span class="custom-label">ğŸ€ Accessory</span>
    <div class="option-row" id="acc-opts">
      <div class="opt-btn selected" data-val="none" onclick="setCatProp('accessory','none')">None</div>
      <div class="opt-btn" data-val="bow" onclick="setCatProp('accessory','bow')">ğŸ€ Bow</div>
      <div class="opt-btn" data-val="flower" onclick="setCatProp('accessory','flower')">ğŸŒ¸ Flower</div>
      <div class="opt-btn" data-val="hat" onclick="setCatProp('accessory','hat')">ğŸ© Hat</div>
      <div class="opt-btn" data-val="stars" onclick="setCatProp('accessory','stars')">â­ Stars</div>
      <div class="opt-btn" data-val="crown" onclick="setCatProp('accessory','crown')">ğŸ‘‘ Crown</div>
    </div>
  </div>

  <div class="btn-row">
    <button class="btn btn-grey btn-sm" onclick="showScreen('title-screen')">â† Back</button>
    <button class="btn btn-sm" onclick="goLevelSelect()">Play â†’</button>
  </div>
</div>

<!-- GAME SELECT -->
<div class="screen hidden" id="level-screen">
  <h2>Choose a Game ğŸ±</h2>
  <div class="level-list" id="level-list">
    <div class="level-card unlocked" onclick="beginSoccer()">
      <div class="level-icon">âš½</div>
      <div class="level-card-text">
        <div class="level-card-name">Cat Soccer</div>
        <div class="level-card-desc">1v1 Â· swipe to kick hard Â· score 7 to win</div>
      </div>
    </div>
    <div class="level-card unlocked" onclick="beginZenGarden()">
      <div class="level-icon">ğŸª¨</div>
      <div class="level-card-text">
        <div class="level-card-name">Zen Garden</div>
        <div class="level-card-desc">Rake sand into patterns Â· patterns slowly fade</div>
      </div>
    </div>
    <div class="level-card unlocked" onclick="beginFishing()">
      <div class="level-icon">ğŸ£</div>
      <div class="level-card-text">
        <div class="level-card-name">Fishing Hole</div>
        <div class="level-card-desc">Cast, wait, reel in Â· cosy pond vibes</div>
      </div>
    </div>
    <div class="level-card unlocked" onclick="beginYarnBat()">
      <div class="level-icon">ğŸ§¶</div>
      <div class="level-card-text">
        <div class="level-card-name">Yarn Bat</div>
        <div class="level-card-desc">Bat the yarn ball around Â· just for fun</div>
      </div>
    </div>
    <div class="level-card unlocked" onclick="beginGarden()">
      <div class="level-icon">ğŸŒ±</div>
      <div class="level-card-text">
        <div class="level-card-name">Garden Patch</div>
        <div class="level-card-desc">Plant seeds Â· water them Â· watch flowers bloom</div>
      </div>
    </div>
    <div class="level-card unlocked" onclick="beginTopiary()">
      <div class="level-icon">ğŸŒ³</div>
      <div class="level-card-text">
        <div class="level-card-name">Topiary Garden</div>
        <div class="level-card-desc">Trim the bush Â· carve shapes Â· draw with shears</div>
      </div>
    </div>
  </div>
  <button class="btn btn-grey btn-sm" onclick="showScreen('custom-screen')">â† Back</button>
</div>

<!-- RESULT SCREEN (soccer win/lose) -->
<div class="screen hidden" id="gameover-screen">
  <div class="result-emoji">ğŸ˜¿</div>
  <h2>So Close!</h2>
  <div id="go-name" style="font-size:15px;color:#8d6e63;font-weight:700;text-align:center;max-width:260px"></div>
  <div class="btn-row">
    <button class="btn btn-grey btn-sm" onclick="goLevelSelect()">ğŸ® Games</button>
  </div>
</div>

<!-- WIN SCREEN -->
<div class="screen hidden" id="levelcomplete-screen">
  <div class="result-emoji" id="lc-emoji">ğŸ‰</div>
  <h2 id="lc-title">You Win!</h2>
  <div id="lc-desc" style="font-size:14px;color:#5d4037;font-weight:700;text-align:center;max-width:280px"></div>
  <div class="btn-row">
    <button class="btn btn-green btn-sm" id="lc-next-btn" onclick="goLevelSelect()">ğŸ® Games</button>
  </div>
</div>

<!-- HUD -->
<div id="hud">
  <div class="hud-row">
    <div class="hud-pill" id="games-back-btn" style="display:none;cursor:pointer;padding:6px 14px;font-size:13px;" onclick="goLevelSelect()" title="Back to games">â† Games</div>
    <div class="hud-pill" id="key-indicator-pill"><span id="key-indicator">ğŸ”‘ âœ—</span></div>
    <div class="hud-pill" id="happy-hud" style="display:none"><span id="happy-display">ğŸŒˆ</span></div>
    <div class="hud-pill" id="watering-hud" style="display:none">ğŸª£</div>
    <div class="hud-pill" id="daytime-hud" style="font-size:10px">â˜€ï¸</div>
    <div class="hud-pill" style="cursor:pointer;padding:6px 12px;font-size:15px;" onclick="toggleMusic()" id="music-toggle-btn" title="Music">ğŸµ</div>
    <div class="hud-pill" style="cursor:pointer;padding:6px 12px;font-size:15px;" onclick="toggleHelp()" title="Help (H)">â“</div>
  </div>
</div>

<!-- CANVAS -->
<div id="game-canvas-wrap">
  <canvas id="gameCanvas" width="420" height="700"></canvas>
  <!-- TOUCH -->
  <div id="touch-controls">
    <div id="joystick-zone"><div id="joystick-knob"></div></div>
    <div class="action-btns">
      <div class="touch-action-btn" id="scratch-btn" ontouchstart="onScratchDown(event)" ontouchend="onScratchUp(event)">ğŸ¾</div>
    </div>
  </div>
</div>

<!-- POPUP CONTAINER -->
<div id="popup-layer" style="position:absolute;inset:0;pointer-events:none;z-index:30;overflow:hidden;"></div>

</div><!-- #app -->

</body>
</html>
<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AUDIO ENGINE (Web Audio API â€” no files needed)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let audioCtx = null;
function getAudio() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if (audioCtx.state === 'suspended') audioCtx.resume();
  return audioCtx;
}

function playMeow() {
  try {
    const ac = getAudio(), t = ac.currentTime;
    // Meow: two formants, pitch glide
    const osc1 = ac.createOscillator(), osc2 = ac.createOscillator();
    const gain = ac.createGain(), gain2 = ac.createGain();
    const filter = ac.createBiquadFilter();
    filter.type = 'bandpass'; filter.frequency.value = 1200; filter.Q.value = 3;
    osc1.type = 'sawtooth'; osc2.type = 'sine';
    osc1.frequency.setValueAtTime(340, t);
    osc1.frequency.exponentialRampToValueAtTime(520, t + 0.12);
    osc1.frequency.exponentialRampToValueAtTime(380, t + 0.28);
    osc2.frequency.setValueAtTime(680, t);
    osc2.frequency.exponentialRampToValueAtTime(1040, t + 0.12);
    osc2.frequency.exponentialRampToValueAtTime(760, t + 0.28);
    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(0.28, t + 0.04);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.32);
    gain2.gain.setValueAtTime(0.08, t);
    gain2.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
    osc1.connect(filter); filter.connect(gain); gain.connect(ac.destination);
    osc2.connect(gain2); gain2.connect(ac.destination);
    osc1.start(t); osc1.stop(t + 0.35);
    osc2.start(t); osc2.stop(t + 0.30);
  } catch(e) {}
}

function playHit() {
  try {
    const ac = getAudio(), t = ac.currentTime;
    const buf = ac.createBuffer(1, ac.sampleRate * 0.12, ac.sampleRate);
    const d = buf.getChannelData(0);
    for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / d.length, 2);
    const src = ac.createBufferSource(), g = ac.createGain();
    const f = ac.createBiquadFilter(); f.type = 'lowpass'; f.frequency.value = 800;
    src.buffer = buf; g.gain.setValueAtTime(0.35, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
    src.connect(f); f.connect(g); g.connect(ac.destination); src.start(t);
  } catch(e) {}
}

function playCollect() {
  try {
    const ac = getAudio(), t = ac.currentTime;
    [0, 0.07, 0.14].forEach((dt, i) => {
      const o = ac.createOscillator(), g = ac.createGain();
      o.type = 'sine'; o.frequency.value = [523, 659, 784][i];
      g.gain.setValueAtTime(0.18, t + dt); g.gain.exponentialRampToValueAtTime(0.001, t + dt + 0.18);
      o.connect(g); g.connect(ac.destination); o.start(t + dt); o.stop(t + dt + 0.2);
    });
  } catch(e) {}
}

function playKeyPickup() {
  try {
    const ac = getAudio(), t = ac.currentTime;
    [0, 0.08, 0.16, 0.24].forEach((dt, i) => {
      const o = ac.createOscillator(), g = ac.createGain();
      o.type = 'triangle'; o.frequency.value = [392, 523, 659, 1047][i];
      g.gain.setValueAtTime(0.22, t + dt); g.gain.exponentialRampToValueAtTime(0.001, t + dt + 0.25);
      o.connect(g); g.connect(ac.destination); o.start(t + dt); o.stop(t + dt + 0.3);
    });
  } catch(e) {}
}

function playDoorOpen() {
  try {
    const ac = getAudio(), t = ac.currentTime;
    [0, 0.1, 0.2, 0.3, 0.4].forEach((dt, i) => {
      const o = ac.createOscillator(), g = ac.createGain();
      o.type = 'sine'; o.frequency.value = [261, 329, 392, 523, 784][i];
      g.gain.setValueAtTime(0.2, t + dt); g.gain.exponentialRampToValueAtTime(0.001, t + dt + 0.35);
      o.connect(g); g.connect(ac.destination); o.start(t + dt); o.stop(t + dt + 0.4);
    });
  } catch(e) {}
}

function playLeverClick() {
  try {
    const ac = getAudio(), t = ac.currentTime;
    const o = ac.createOscillator(), g = ac.createGain();
    o.type = 'square'; o.frequency.setValueAtTime(180, t); o.frequency.exponentialRampToValueAtTime(90, t + 0.08);
    g.gain.setValueAtTime(0.25, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
    o.connect(g); g.connect(ac.destination); o.start(t); o.stop(t + 0.12);
  } catch(e) {}
}

function playBreak() {
  try {
    const ac = getAudio(), t = ac.currentTime;
    const buf = ac.createBuffer(1, ac.sampleRate * 0.18, ac.sampleRate);
    const d = buf.getChannelData(0);
    for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / d.length, 1.5) * 0.6;
    const src = ac.createBufferSource(), g = ac.createGain();
    const f = ac.createBiquadFilter(); f.type = 'highpass'; f.frequency.value = 400;
    src.buffer = buf; g.gain.setValueAtTime(0.4, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.18);
    src.connect(f); f.connect(g); g.connect(ac.destination); src.start(t);
  } catch(e) {}
}

function playWoof() {
  try {
    const ac = getAudio(), t = ac.currentTime;
    // Two-part woof: sharp attack bark + tail resonance
    const osc1 = ac.createOscillator(), osc2 = ac.createOscillator();
    const g1 = ac.createGain(), g2 = ac.createGain();
    const dist = ac.createWaveShaper();
    // Soft distortion for rough bark texture
    const curve = new Float32Array(256);
    for (let i = 0; i < 256; i++) { const x = (i * 2) / 256 - 1; curve[i] = (Math.PI + 200) * x / (Math.PI + 200 * Math.abs(x)); }
    dist.curve = curve;
    osc1.type = 'sawtooth';
    osc1.frequency.setValueAtTime(220, t);
    osc1.frequency.exponentialRampToValueAtTime(140, t + 0.08);
    osc1.frequency.exponentialRampToValueAtTime(100, t + 0.22);
    osc2.type = 'sine';
    osc2.frequency.setValueAtTime(180, t);
    osc2.frequency.exponentialRampToValueAtTime(80, t + 0.18);
    g1.gain.setValueAtTime(0, t);
    g1.gain.linearRampToValueAtTime(0.35, t + 0.02);
    g1.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
    g2.gain.setValueAtTime(0.15, t);
    g2.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
    osc1.connect(dist); dist.connect(g1); g1.connect(ac.destination);
    osc2.connect(g2); g2.connect(ac.destination);
    osc1.start(t); osc1.stop(t + 0.28);
    osc2.start(t); osc2.stop(t + 0.22);
  } catch(e) {}
}

function playDash() {
  try {
    const ac = getAudio(), t = ac.currentTime;
    const o = ac.createOscillator(), g = ac.createGain();
    const f = ac.createBiquadFilter(); f.type='highpass'; f.frequency.value=300;
    o.type='sawtooth';
    o.frequency.setValueAtTime(600,t); o.frequency.exponentialRampToValueAtTime(200,t+0.12);
    g.gain.setValueAtTime(0.18,t); g.gain.exponentialRampToValueAtTime(0.001,t+0.14);
    o.connect(f); f.connect(g); g.connect(ac.destination); o.start(t); o.stop(t+0.15);
  } catch(e){}
}

function playPurr() {
  try {
    const ac = getAudio(), t = ac.currentTime;
    // Low rumble oscillating â€” purring
    const o1 = ac.createOscillator(), o2 = ac.createOscillator();
    const lfo = ac.createOscillator(), lfoG = ac.createGain();
    const g = ac.createGain();
    o1.type='sine'; o1.frequency.value=55;
    o2.type='sine'; o2.frequency.value=60;
    lfo.type='sine'; lfo.frequency.value=28; // purr rate
    lfoG.gain.value=20;
    lfo.connect(lfoG); lfoG.connect(o1.frequency); lfoG.connect(o2.frequency);
    g.gain.setValueAtTime(0,t);
    g.gain.linearRampToValueAtTime(0.22,t+0.1);
    g.gain.setValueAtTime(0.22,t+0.55);
    g.gain.exponentialRampToValueAtTime(0.001,t+0.75);
    o1.connect(g); o2.connect(g); g.connect(ac.destination);
    o1.start(t); o1.stop(t+0.8);
    o2.start(t); o2.stop(t+0.8);
    lfo.start(t); lfo.stop(t+0.8);
  } catch(e){}
}

function playNapSound() {
  try {
    const ac = getAudio(), t = ac.currentTime;
    // Gentle lullaby-ish chime
    [523, 659, 784].forEach((freq, i) => {
      const o = ac.createOscillator(), g = ac.createGain();
      o.type = 'sine'; o.frequency.value = freq;
      g.gain.setValueAtTime(0, t+i*0.22);
      g.gain.linearRampToValueAtTime(0.12, t+i*0.22+0.06);
      g.gain.exponentialRampToValueAtTime(0.001, t+i*0.22+0.6);
      o.connect(g); g.connect(ac.destination); o.start(t+i*0.22); o.stop(t+i*0.22+0.7);
    });
  } catch(e){}
}

function playPlatformStart() {
  try {
    const ac = getAudio(), t = ac.currentTime;
    const o = ac.createOscillator(), g = ac.createGain();
    o.type = 'sawtooth'; o.frequency.setValueAtTime(220, t); o.frequency.linearRampToValueAtTime(330, t + 0.15);
    g.gain.setValueAtTime(0.2, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.22);
    o.connect(g); g.connect(ac.destination); o.start(t); o.stop(t + 0.25);
  } catch(e) {}
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COZY JAPANESE MUSIC ENGINE
// Procedural pentatonic koto/shakuhachi-inspired ambient music
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let musicCtx = null, musicPlaying = false, musicEnabled = true;
let musicNodes = []; // track active nodes for cleanup

// Japanese pentatonic scale (A minor pentatonic) in Hz
// éŸ³éš: A3, C4, D4, E4, G4, A4, C5, D5, E5, G5
const PENTATONIC = [220.0, 261.6, 293.7, 329.6, 392.0, 440.0, 523.3, 587.3, 659.3, 784.0];

// Melodic phrases â€” indices into PENTATONIC
const PHRASES = [
  [5,4,3,2,1,0,2,3],       // falling
  [0,2,3,5,4,3,2,0],       // arch
  [5,5,4,3,5,4,2,0],       // ornamental
  [3,4,5,4,3,2,3,2],       // winding
  [0,3,2,0,2,3,5,4],       // rising
  [5,4,3,5,3,2,0,2],       // meditative
];

function getMusicCtx() {
  if (!musicCtx) {
    musicCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (musicCtx.state === 'suspended') musicCtx.resume();
  return musicCtx;
}

// Master gain for music (separate from SFX)
let masterGain = null;
function getMasterGain() {
  if (!masterGain) {
    const ac = getMusicCtx();
    masterGain = ac.createGain();
    masterGain.gain.value = 0.0;
    masterGain.connect(ac.destination);
  }
  return masterGain;
}

// Reverb convolver for lush room sound
let reverbNode = null;
async function getReverb() {
  if (reverbNode) return reverbNode;
  const ac = getMusicCtx();
  reverbNode = ac.createConvolver();
  // Generate synthetic impulse response (room reverb)
  const len = ac.sampleRate * 2.8;
  const buf = ac.createBuffer(2, len, ac.sampleRate);
  for (let ch = 0; ch < 2; ch++) {
    const d = buf.getChannelData(ch);
    for (let i = 0; i < len; i++) {
      const decay = Math.pow(1 - i/len, 2.2);
      d[i] = (Math.random()*2-1) * decay * (i < ac.sampleRate*0.01 ? 0 : 1);
    }
  }
  reverbNode.buffer = buf;
  reverbNode.connect(getMasterGain());
  return reverbNode;
}

// Koto-like pluck: sine + triangle blend, fast attack, long decay
function playKotoNote(freq, startTime, duration, gain=0.22, reverb=null) {
  try {
    const ac = getMusicCtx();
    const osc1 = ac.createOscillator();
    const osc2 = ac.createOscillator();
    const g = ac.createGain();
    const filter = ac.createBiquadFilter();

    osc1.type = 'triangle'; osc1.frequency.value = freq;
    osc2.type = 'sine';     osc2.frequency.value = freq * 2.003; // slight detune for shimmer
    filter.type = 'lowpass'; filter.frequency.setValueAtTime(3000, startTime);
    filter.frequency.exponentialRampToValueAtTime(800, startTime + duration*0.4);

    // Pluck envelope: very fast attack, exponential decay (koto character)
    g.gain.setValueAtTime(0, startTime);
    g.gain.linearRampToValueAtTime(gain, startTime + 0.008);
    g.gain.exponentialRampToValueAtTime(gain * 0.3, startTime + duration * 0.25);
    g.gain.exponentialRampToValueAtTime(0.0001, startTime + duration);

    osc1.connect(filter); osc2.connect(filter); filter.connect(g);
    if (reverb) g.connect(reverb);
    g.connect(getMasterGain());

    osc1.start(startTime); osc1.stop(startTime + duration + 0.1);
    osc2.start(startTime); osc2.stop(startTime + duration + 0.1);
    musicNodes.push(osc1, osc2);
  } catch(e) {}
}

// Shakuhachi-like breathy tone: sine + slight noise + vibrato
function playFluteNote(freq, startTime, duration, gain=0.12) {
  try {
    const ac = getMusicCtx();
    const osc = ac.createOscillator();
    const vibLfo = ac.createOscillator();
    const vibGain = ac.createGain();
    const noiseNode = ac.createOscillator(); // second osc for breath texture
    const g = ac.createGain();
    const filter = ac.createBiquadFilter();

    osc.type = 'sine'; osc.frequency.value = freq;
    vibLfo.type = 'sine'; vibLfo.frequency.value = 5.2; // natural vibrato rate
    vibGain.gain.value = freq * 0.012; // subtle vibrato depth
    vibLfo.connect(vibGain); vibGain.connect(osc.frequency);

    noiseNode.type = 'sawtooth'; noiseNode.frequency.value = freq * 1.01;
    filter.type = 'bandpass'; filter.frequency.value = freq * 1.5; filter.Q.value = 8;

    // Breath envelope: slow attack, long sustain
    g.gain.setValueAtTime(0, startTime);
    g.gain.linearRampToValueAtTime(gain, startTime + duration*0.18);
    g.gain.setValueAtTime(gain, startTime + duration*0.7);
    g.gain.exponentialRampToValueAtTime(0.0001, startTime + duration);

    const ng = ac.createGain(); ng.gain.value = gain * 0.18;
    noiseNode.connect(filter); filter.connect(ng); ng.connect(g);
    osc.connect(g); g.connect(getMasterGain());

    osc.start(startTime); osc.stop(startTime + duration + 0.05);
    noiseNode.start(startTime); noiseNode.stop(startTime + duration + 0.05);
    vibLfo.start(startTime); vibLfo.stop(startTime + duration + 0.05);
    musicNodes.push(osc, vibLfo, noiseNode);
  } catch(e) {}
}

// Low drum (taiko-ish): noise burst + low sine thud
function playDrum(startTime, gain=0.14) {
  try {
    const ac = getMusicCtx();
    const buf = ac.createBuffer(1, ac.sampleRate * 0.25, ac.sampleRate);
    const d = buf.getChannelData(0);
    for (let i=0; i<d.length; i++) d[i] = (Math.random()*2-1)*Math.pow(1-i/d.length,1.6);
    const src = ac.createBufferSource();
    const osc = ac.createOscillator(); // thud body
    const g1 = ac.createGain(), g2 = ac.createGain();
    const f = ac.createBiquadFilter(); f.type='lowpass'; f.frequency.value=180;

    src.buffer = buf;
    osc.type='sine'; osc.frequency.setValueAtTime(80,startTime); osc.frequency.exponentialRampToValueAtTime(40,startTime+0.12);
    g1.gain.setValueAtTime(gain*0.7,startTime); g1.gain.exponentialRampToValueAtTime(0.0001,startTime+0.22);
    g2.gain.setValueAtTime(gain,startTime); g2.gain.exponentialRampToValueAtTime(0.0001,startTime+0.14);

    src.connect(f); f.connect(g1); g1.connect(getMasterGain());
    osc.connect(g2); g2.connect(getMasterGain());

    src.start(startTime); osc.start(startTime); osc.stop(startTime+0.28);
    musicNodes.push(osc);
  } catch(e){}
}

// Schedule one "bar" of music
let musicScheduleId = null;
let nextBarTime = 0;
const BAR_DURATION = 3.2; // seconds per bar â€” slow, meditative tempo
let currentPhraseIdx = 0;
let phrasePosition = 0;

function scheduleMusicBar() {
  if (!musicPlaying || !musicEnabled) return;
  try {
    const ac = getMusicCtx();
    const barStart = nextBarTime;
    const phrase = PHRASES[currentPhraseIdx % PHRASES.length];
    const noteDur = BAR_DURATION / phrase.length;

    // Schedule koto melody
    phrase.forEach((noteIdx, i) => {
      const freq = PENTATONIC[noteIdx];
      const noteStart = barStart + i * noteDur;
      // Vary velocity for humanised feel
      const vel = 0.14 + Math.random()*0.12;
      playKotoNote(freq, noteStart, noteDur*0.85, vel);
      // Occasionally double the note an octave down for depth
      if (Math.random() < 0.25) {
        playKotoNote(freq * 0.5, noteStart + 0.015, noteDur*0.7, vel*0.4);
      }
    });

    // Flute line â€” plays a slower counter-melody every 2 bars
    if (currentPhraseIdx % 2 === 0) {
      const flutePhrase = [phrase[0], phrase[2], phrase[4]||phrase[3], phrase[6]||phrase[5]];
      flutePhrase.forEach((noteIdx, i) => {
        const freq = PENTATONIC[Math.min(noteIdx+2, PENTATONIC.length-1)] * 0.5; // lower octave flute
        const noteStart = barStart + i * (BAR_DURATION/flutePhrase.length);
        if (Math.random() < 0.7) playFluteNote(freq, noteStart, BAR_DURATION/flutePhrase.length * 0.9, 0.08);
      });
    }

    // Sparse taiko drums â€” 1-2 per bar on random beats
    const drumBeats = [0, 1, 3].filter(()=>Math.random()<0.45);
    drumBeats.forEach(beat => {
      playDrum(barStart + beat * (BAR_DURATION/4), 0.10+Math.random()*0.06);
    });

    // Ambient bass drone (root note) â€” very soft
    playKotoNote(PENTATONIC[0] * 0.25, barStart, BAR_DURATION * 0.95, 0.06);

    // Advance phrase every 2 bars
    phrasePosition++;
    if (phrasePosition >= 2) {
      phrasePosition = 0;
      currentPhraseIdx = (currentPhraseIdx + 1) % PHRASES.length;
    }

    nextBarTime += BAR_DURATION;

    // Schedule next bar slightly before this one ends
    const msUntilNext = (nextBarTime - ac.currentTime - 0.3) * 1000;
    musicScheduleId = setTimeout(scheduleMusicBar, Math.max(0, msUntilNext));
  } catch(e) {}
}

function startMusic() {
  if (musicPlaying) return;
  musicPlaying = true;
  try {
    const ac = getMusicCtx();
    nextBarTime = ac.currentTime + 0.2;
    getMasterGain().gain.cancelScheduledValues(ac.currentTime);
    getMasterGain().gain.setValueAtTime(getMasterGain().gain.value, ac.currentTime);
    getMasterGain().gain.linearRampToValueAtTime(0.72, ac.currentTime + 1.5);
    // Kick off reverb (async, but music starts without it)
    getReverb().catch(()=>{});
    scheduleMusicBar();
  } catch(e){}
}

function stopMusic(fade=true) {
  musicPlaying = false;
  if (musicScheduleId) { clearTimeout(musicScheduleId); musicScheduleId=null; }
  try {
    const ac = getMusicCtx();
    const mg = getMasterGain();
    if (fade) {
      mg.gain.cancelScheduledValues(ac.currentTime);
      mg.gain.setValueAtTime(mg.gain.value, ac.currentTime);
      mg.gain.linearRampToValueAtTime(0.0, ac.currentTime + 1.2);
    } else {
      mg.gain.value = 0;
    }
  } catch(e){}
}

function toggleMusic() {
  musicEnabled = !musicEnabled;
  const btn = document.getElementById('music-toggle-btn');
  if (musicEnabled) {
    startMusic();
    if (btn) btn.textContent = 'ğŸµ';
    if (btn) btn.title = 'Music: On';
  } else {
    stopMusic(true);
    if (btn) btn.textContent = 'ğŸ”‡';
    if (btn) btn.title = 'Music: Off';
  }
}


// â”€â”€â”€ WEATHER SYSTEM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const LEVEL_WEATHER = ['rain', 'blossoms', 'dustmotes', 'snow'];

let weatherParticles = [];
function initWeather(levelIdx) {
  weatherParticles = [];
  const type = LEVEL_WEATHER[levelIdx] || 'none';
  const count = {rain:80, blossoms:40, dustmotes:50, snow:60}[type] || 0;
  for (let i = 0; i < count; i++) weatherParticles.push(makeWeatherParticle(type, true));
}

function makeWeatherParticle(type, init=false) {
  const p = { type };
  if (type === 'rain') {
    p.x = Math.random()*CW; p.y = init ? Math.random()*CH : -8;
    p.vy = 9 + Math.random()*5; p.vx = -1.5 + Math.random()*0.5;
    p.len = 8 + Math.random()*10; p.alpha = 0.2 + Math.random()*0.3;
  } else if (type === 'blossoms') {
    p.x = Math.random()*CW; p.y = init ? Math.random()*CH : -12;
    p.vx = -0.4 + Math.random()*0.8; p.vy = 0.5 + Math.random()*0.8;
    p.rot = Math.random()*Math.PI*2; p.rotV = (Math.random()-0.5)*0.04;
    p.size = 5 + Math.random()*5; p.hue = 340 + Math.random()*20;
    p.swing = Math.random()*Math.PI*2; p.swingS = 0.02+Math.random()*0.02;
  } else if (type === 'dustmotes') {
    p.x = Math.random()*CW; p.y = Math.random()*CH;
    p.vx = (Math.random()-0.5)*0.3; p.vy = (Math.random()-0.5)*0.2;
    p.r = 1 + Math.random()*2; p.alpha = 0.08 + Math.random()*0.15;
    p.pulsePhase = Math.random()*Math.PI*2;
  } else if (type === 'snow') {
    p.x = Math.random()*CW; p.y = init ? Math.random()*CH : -8;
    p.vx = (Math.random()-0.5)*0.6; p.vy = 0.6 + Math.random()*0.8;
    p.r = 2 + Math.random()*3; p.alpha = 0.5 + Math.random()*0.4;
    p.swing = Math.random()*Math.PI*2; p.swingS = 0.01+Math.random()*0.02;
    p.settled = false;
  }
  return p;
}

function updateWeather() {
  if (!gs || !weatherParticles.length) return;
  const t = gs.time;
  for (let i = weatherParticles.length - 1; i >= 0; i--) {
    const p = weatherParticles[i];
    if (p.type === 'rain') {
      p.x += p.vx; p.y += p.vy;
      if (p.y > CH + 10) weatherParticles[i] = makeWeatherParticle('rain');
    } else if (p.type === 'blossoms') {
      p.swing += p.swingS; p.rot += p.rotV;
      p.x += p.vx + Math.sin(p.swing)*0.4; p.y += p.vy;
      if (p.y > CH + 14) weatherParticles[i] = makeWeatherParticle('blossoms');
    } else if (p.type === 'dustmotes') {
      p.pulsePhase += 0.02;
      p.x += p.vx; p.y += p.vy;
      if (p.x < 0) p.x = CW; if (p.x > CW) p.x = 0;
      if (p.y < 0) p.y = CH; if (p.y > CH) p.y = 0;
    } else if (p.type === 'snow') {
      p.swing += p.swingS;
      p.x += p.vx + Math.sin(p.swing)*0.5; p.y += p.vy;
      if (p.y > CH + 8) weatherParticles[i] = makeWeatherParticle('snow');
    }
  }
}

function drawWeather() {
  if (!weatherParticles.length) return;
  ctx.save();
  for (const p of weatherParticles) {
    if (p.type === 'rain') {
      ctx.strokeStyle = `rgba(180,220,255,${p.alpha})`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(p.x, p.y);
      ctx.lineTo(p.x + p.vx * 1.5, p.y - p.len);
      ctx.stroke();
    } else if (p.type === 'blossoms') {
      ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(p.rot);
      ctx.globalAlpha = 0.75;
      // 5-petal flower shape
      ctx.fillStyle = `hsl(${p.hue},80%,80%)`;
      for (let k = 0; k < 5; k++) {
        ctx.save(); ctx.rotate(k * Math.PI * 2 / 5);
        ctx.beginPath(); ctx.ellipse(0, -p.size*0.55, p.size*0.3, p.size*0.5, 0, 0, Math.PI*2);
        ctx.fill(); ctx.restore();
      }
      ctx.fillStyle = `hsl(50,90%,85%)`; // center
      ctx.beginPath(); ctx.arc(0, 0, p.size*0.22, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    } else if (p.type === 'dustmotes') {
      const a = p.alpha * (0.7 + Math.sin(p.pulsePhase)*0.3);
      ctx.fillStyle = `rgba(255,245,220,${a})`;
      ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
    } else if (p.type === 'snow') {
      ctx.fillStyle = `rgba(255,255,255,${p.alpha})`;
      ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
    }
  }
  // Rain window overlay for home level
  if (weatherParticles[0]?.type === 'rain') {
    ctx.fillStyle = 'rgba(180,210,255,0.04)';
    ctx.fillRect(0, 0, CW, CH);
  }
  ctx.restore();
}

// â”€â”€â”€ NAP SPOTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnNapSpots(levelIdx, floorCells, usedC, rng) {
  const opts = [
    [['ğŸ›ï¸','bed'],['ğŸ›‹ï¸','couch'],['ğŸ§¸','cushion']],
    [['ğŸŒ¿','grass'],['ğŸªµ','log'],['ğŸŒ¸','petal-bed']],
    [['ğŸª‘','chair'],['ğŸ“‹','mat'],['ğŸ§º','basket']],
    [['ğŸ’','bench'],['ğŸ“°','paper-pile'],['ğŸ’º','seat']],
  ][levelIdx] || [['ğŸŒ¸','spot'],['âœ¨','nook'],['ğŸƒ','leaf-bed']];
  const spots = [];
  const zone = floorCells.filter(p => p.r > 4 && p.r < floorCells.reduce((m,p)=>Math.max(m,p.r),0)-4);
  for (let i = 0; i < 3; i++) {
    let cell;
    for (let a = 0; a < 40; a++) {
      cell = zone[Math.floor(rng()*zone.length)];
      if (cell && !usedC.has(`${cell.r},${cell.c}`)) break;
    }
    if (!cell) continue;
    usedC.add(`${cell.r},${cell.c}`);
    const [emoji, name] = opts[i % opts.length];
    spots.push({
      emoji, name, wx: cell.c*TILE+TILE/2, wy: cell.r*TILE+TILE/2,
      napTimer: 0, napping: false, napAnim: 0, zzzPhase: 0,
    });
  }
  return spots;
}

function updateNapSpots() {
  if (!gs.napSpots) return;
  const cat = gs.cat;
  for (const s of gs.napSpots) {
    const dist = Math.hypot(cat.wx-s.wx, cat.wy-s.wy);
    const moving = cat.moving || cat.dashFrames > 0;
    if (dist < 26 && !moving) {
      s.napTimer++;
      if (s.napTimer > 90 && !s.napping) {
        s.napping = true; s.napAnim = 0;
        playNapSound();
      }
    } else {
      if (s.napping && (moving || dist > 32)) {
        s.napping = false;
        cat.happyFrames = Math.max(cat.happyFrames, HAPPY_DURATION);
        spawnParticles(cat.wx, cat.wy, 'ğŸŒˆ');
        spawnParticles(cat.wx, cat.wy, 'âœ¨');
      }
      s.napTimer = 0;
    }
    if (s.napping) { s.napAnim++; s.zzzPhase += 0.06; }
  }
}

function drawNapSpots(t) {
  if (!gs.napSpots) return;
  const cat = gs.cat;
  for (const s of gs.napSpots) {
    ctx.save(); ctx.translate(s.wx, s.wy);
    // Glow under spot
    const dist = Math.hypot(cat.wx-s.wx, cat.wy-s.wy);
    if (dist < 55) {
      const nearAlpha = (55-dist)/55*0.18;
      ctx.fillStyle=`rgba(255,220,180,${nearAlpha})`;
      ctx.beginPath(); ctx.arc(0,0,22,0,Math.PI*2); ctx.fill();
    }
    ctx.font='20px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(s.emoji, 0, 0);
    // Name hint
    if (dist < 55 && !s.napping) {
      ctx.font='bold 8px Nunito,sans-serif'; ctx.fillStyle='rgba(120,80,60,0.7)';
      ctx.fillText('Nap here~', 0, -18);
    }
    // Zzz floating up when napping
    if (s.napping) {
      const zs = [0, 0.7, 1.4];
      for (let i=0; i<3; i++) {
        const phase = (s.zzzPhase + zs[i]) % (Math.PI*2);
        const progress = phase / (Math.PI*2);
        const zy = -20 - progress*28;
        const zx = Math.sin(phase*2)*8 + 10;
        const alpha = progress < 0.7 ? progress/0.7 : 1 - (progress-0.7)/0.3;
        const fsize = 9 + i*3;
        ctx.globalAlpha = alpha * 0.8;
        ctx.font = `${fsize}px serif`;
        ctx.fillText('z', zx, zy);
      }
      ctx.globalAlpha = 1;
    }
    ctx.restore();
  }
}

// â”€â”€â”€ WATERING + BLOOMING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnWaterFeature(levelIdx, floorCells, interactables, usedC, rng) {
  // One watering can per level + mark some plants as waterable
  const zone = floorCells.filter(p => p.r > 6);
  let cell;
  for (let a = 0; a < 40; a++) {
    cell = zone[Math.floor(rng()*zone.length)];
    if (cell && !usedC.has(`${cell.r},${cell.c}`)) break;
  }
  const can = cell ? {
    type:'wateringcan', emoji:'ğŸª£', wx:cell.c*TILE+TILE/2, wy:cell.r*TILE+TILE/2,
    collected:false, pts:0, en:0, bob:rng()*Math.PI*2,
    moveSpeed:0, moveDir:1, moveMin:0, moveMax:0, golden:false, treatType:null,
  } : null;
  if (can) { usedC.add(`${cell.r},${cell.c}`); }
  // Mark 2-3 random plants as wilted/waterable
  const plants = interactables.filter(o => o.type==='plant');
  const numWilt = Math.min(plants.length, 2+Math.floor(rng()*2));
  for (let i=0; i<numWilt; i++) {
    const idx = Math.floor(rng()*plants.length);
    plants[idx].wilted = true; plants[idx].emoji = 'ğŸ¥€'; plants[idx].bloomed = false;
  }
  return can;
}

function tryWaterPlant(cat) {
  if (!gs.hasWateringCan) return;
  // Water nearest wilted plant within scratch range
  for (const obj of gs.interactables) {
    if (!obj.wilted || obj.bloomed) continue;
    const dist = Math.hypot(cat.wx-obj.wx, cat.wy-obj.wy);
    if (dist < SCRATCH_RANGE + 10) {
      obj.bloomed = true; obj.emoji = 'ğŸŒ¸'; obj.wilted = false;
      obj.animTick = 30;
      spawnParticles(obj.wx, obj.wy, 'ğŸŒ¸');
      spawnParticles(obj.wx, obj.wy, 'ğŸ’§');
      spawnPop(obj.wx, obj.wy, 'Bloomed! ğŸŒ¸', '#f48fb1');
      playCollect();
      return;
    }
  }
}

// â”€â”€â”€ FISH TANK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let fishTapAnim = 0; // global anim timer for fish tap
function checkFishTank() {
  if (!gs.fishTank) return;
  const cat = gs.cat;
  const dist = Math.hypot(cat.wx-gs.fishTank.wx, cat.wy-gs.fishTank.wy);
  if (dist < 38 && fishTapAnim === 0) {
    fishTapAnim = 80;
    spawnParticles(gs.fishTank.wx, gs.fishTank.wy-8, 'ğŸ’§');
    spawnParticles(gs.fishTank.wx+8, gs.fishTank.wy, 'ğŸŸ');
    spawnPop(gs.fishTank.wx, gs.fishTank.wy, 'Tap tap! ğŸ¾', '#80deea');
    // Soft bloop sound
    try {
      const ac = getAudio(), t = ac.currentTime;
      const o = ac.createOscillator(), g = ac.createGain();
      o.type='sine'; o.frequency.setValueAtTime(520,t); o.frequency.exponentialRampToValueAtTime(200,t+0.18);
      g.gain.setValueAtTime(0.12,t); g.gain.exponentialRampToValueAtTime(0.001,t+0.22);
      o.connect(g); g.connect(ac.destination); o.start(t); o.stop(t+0.25);
    } catch(e){}
  }
  if (fishTapAnim > 0) fishTapAnim--;
}

function drawFishTank(t) {
  if (!gs.fishTank) return;
  const ft = gs.fishTank;
  ctx.save(); ctx.translate(ft.wx, ft.wy);
  // Tank body
  ctx.fillStyle='rgba(100,200,255,0.18)';
  ctx.strokeStyle='rgba(100,200,255,0.5)'; ctx.lineWidth=2;
  ctx.beginPath(); ctx.roundRect(-18,-14,36,28,4); ctx.fill(); ctx.stroke();
  // Water shimmer
  ctx.fillStyle='rgba(150,220,255,0.12)';
  ctx.beginPath(); ctx.roundRect(-18,-14,36,10,{upperLeft:4,upperRight:4}); ctx.fill();
  // Fish swimming
  const fx = Math.sin(t*0.06)*10;
  ctx.font='12px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.save(); if(fx<0) ctx.scale(-1,1);
  ctx.fillText('ğŸ ', fx, 2); ctx.restore();
  ctx.font='8px serif'; ctx.fillText('ğŸ¡', Math.sin(t*0.04+1)*8, -4);
  // Paw tap overlay
  if (fishTapAnim > 0) {
    const prog = fishTapAnim/80;
    ctx.globalAlpha = prog;
    ctx.font='14px serif';
    ctx.fillText('ğŸ¾', 16, -10-prog*6);
  }
  ctx.restore();
}

// â”€â”€â”€ PHOTO MODE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let photoFlash = 0;
let shutterSound = () => {
  try {
    const ac = getAudio(), t = ac.currentTime;
    // Click sound
    const buf = ac.createBuffer(1, ac.sampleRate*0.05, ac.sampleRate);
    const d = buf.getChannelData(0);
    for (let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*Math.pow(1-i/d.length,0.5);
    const src = ac.createBufferSource();
    const g = ac.createGain(); g.gain.value=0.3;
    src.buffer=buf; src.connect(g); g.connect(ac.destination); src.start(t);
    // Wind-down whir
    const o = ac.createOscillator(), og = ac.createGain();
    o.type='sine'; o.frequency.setValueAtTime(1800,t+0.05); o.frequency.exponentialRampToValueAtTime(400,t+0.25);
    og.gain.setValueAtTime(0.1,t+0.05); og.gain.exponentialRampToValueAtTime(0.001,t+0.28);
    o.connect(og); og.connect(ac.destination); o.start(t+0.05); o.stop(t+0.3);
  } catch(e){}
};

function takePhoto() {
  if (!gs?.running) return;
  shutterSound();
  photoFlash = 30;
  // Composite current game canvas into a polaroid
  setTimeout(() => {
    try {
      const tmp = document.createElement('canvas');
      tmp.width = CW + 20; tmp.height = CH + 60;
      const tx = tmp.getContext('2d');
      // Polaroid background
      tx.fillStyle='#fff9f0'; tx.fillRect(0,0,tmp.width,tmp.height);
      tx.fillStyle='#f0e0d0'; tx.fillRect(5,5,tmp.width-10,tmp.height-10);
      // Game screenshot
      tx.drawImage(canvas, 10, 10, CW, CH);
      // Polaroid border
      tx.strokeStyle='#d4b896'; tx.lineWidth=3;
      tx.strokeRect(10,10,CW,CH);
      // Label
      tx.font='bold 14px Georgia,serif'; tx.fillStyle='#8d6e63';
      tx.textAlign='center';
      tx.fillText('Neko Day âœ¨', tmp.width/2, CH+35);
      const levelName = ['Home','Park','Building','Station','Soccer'][currentLevel]||'';
      tx.font='10px Georgia,serif'; tx.fillStyle='#a08070';
      tx.fillText(levelName, tmp.width/2, CH+52);
      // Download
      const link = document.createElement('a');
      link.download = `neko-day-photo-${Date.now()}.png`;
      link.href = tmp.toDataURL('image/png');
      link.click();
    } catch(e){ console.log('Photo error:', e); }
  }, 80);
}

function drawPhotoFlash() {
  if (photoFlash <= 0) return;
  const alpha = photoFlash/30;
  ctx.fillStyle=`rgba(255,255,255,${alpha})`;
  ctx.fillRect(0,0,CW,CH);
  // Polaroid frame hint
  if (photoFlash > 18) {
    ctx.strokeStyle=`rgba(200,180,160,${alpha*0.8})`;
    ctx.lineWidth=12; ctx.strokeRect(6,6,CW-12,CH-12);
  }
  photoFlash--;
}
// â”€â”€â”€ END PHOTO MODE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// â”€â”€â”€ STICKER JOURNAL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Stickers are hidden in each level â€” collect them by walking near
const LEVEL_STICKERS = [
  ['ğŸ ','ğŸ›','ğŸª´','ğŸµ','ğŸ•¯ï¸'],   // Home
  ['ğŸŒ³','ğŸŒ¸','ğŸ¦','ğŸŒ¿','â˜€ï¸'],   // Park
  ['ğŸ’¼','ğŸ“','â˜•','ğŸ™ï¸','ğŸ–¥ï¸'],   // Building
  ['ğŸš†','ğŸ«','ğŸ§³','ğŸ—ºï¸','âŒš'],   // Station
];

let collectedStickers = {}; // levelIdx -> [emoji array]
let journalOpen = false;
let journalAnim = 0;

async function loadJournal() {
  try {
    const res = await window.storage.get('neko-journal');
    if (res) collectedStickers = JSON.parse(res.value);
  } catch(e) { collectedStickers = {}; }
}

async function saveJournal() {
  try { await window.storage.set('neko-journal', JSON.stringify(collectedStickers)); } catch(e){}
}

function spawnLevelStickers(levelIdx, floorCells, usedC, rng) {
  const stickers = LEVEL_STICKERS[levelIdx] || [];
  const items = [];
  const zone = floorCells.filter(p => p.r > 5 && p.r < floorCells.reduce((m,p)=>Math.max(m,p.r),0)-3);
  for (let i=0; i<Math.min(3, stickers.length); i++) {
    let cell;
    for (let a=0;a<40;a++) {
      cell = zone[Math.floor(rng()*zone.length)];
      if (cell && !usedC.has(`${cell.r},${cell.c}`)) break;
    }
    if (!cell) continue;
    usedC.add(`${cell.r},${cell.c}`);
    items.push({
      emoji: stickers[i], wx: cell.c*TILE+TILE/2, wy: cell.r*TILE+TILE/2,
      collected:false, revealed:false, bob:rng()*Math.PI*2,
    });
  }
  return items;
}

function updateStickerPickup() {
  if (!gs.stickers) return;
  const cat = gs.cat;
  for (const s of gs.stickers) {
    if (s.collected) continue;
    const dist = Math.hypot(cat.wx-s.wx, cat.wy-s.wy);
    if (dist < 50) s.revealed = true;
    if (dist < 22 && s.revealed) {
      s.collected = true;
      if (!collectedStickers[currentLevel]) collectedStickers[currentLevel] = [];
      if (!collectedStickers[currentLevel].includes(s.emoji))
        collectedStickers[currentLevel].push(s.emoji);
      saveJournal();
      playKeyPickup();
      spawnPop(s.wx, s.wy, `${s.emoji} Sticker!`, '#ffd700');
      spawnParticles(s.wx, s.wy, s.emoji);
      spawnParticles(s.wx, s.wy, 'âœ¨');
    }
  }
}

function drawStickerItems(t) {
  if (!gs.stickers) return;
  const cat = gs.cat;
  for (const s of gs.stickers) {
    if (s.collected) continue;
    const dist = Math.hypot(cat.wx-s.wx, cat.wy-s.wy);
    const nearFactor = Math.max(0, 1-dist/70);
    ctx.save(); ctx.translate(s.wx, s.wy);
    if (s.revealed) {
      const bob = Math.sin(t*0.1+s.bob)*3;
      ctx.translate(0, bob);
      ctx.shadowColor='#ffd700'; ctx.shadowBlur=10+Math.sin(t*0.12)*5;
      ctx.font='18px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(s.emoji, 0, 0);
      ctx.shadowBlur=0;
      ctx.font='bold 7px Nunito,sans-serif'; ctx.fillStyle='#ffd700';
      ctx.fillText('STICKER', 0, -16);
    } else if (nearFactor > 0) {
      ctx.globalAlpha = nearFactor*0.4;
      ctx.font='9px serif'; ctx.textAlign='center';
      ctx.fillText('âœ¨', Math.cos(t*0.1)*8, Math.sin(t*0.1)*8);
    }
    ctx.restore();
  }
}

function toggleJournal() {
  journalOpen = !journalOpen;
  journalAnim = 0;
}

function drawJournal(t) {
  if (!journalOpen) return;
  journalAnim++;
  const progress = Math.min(1, journalAnim/18);
  const ease = progress < 0.5 ? 2*progress*progress : -1+(4-2*progress)*progress;
  const w=260, h=200;
  const x=(CW-w)/2, y=(CH-h)/2;
  ctx.save();
  ctx.translate(CW/2, CH/2); ctx.scale(ease, ease); ctx.translate(-CW/2, -CH/2);
  // Page shadow
  ctx.fillStyle='rgba(0,0,0,0.18)'; ctx.beginPath();
  ctx.roundRect(x+6, y+6, w, h, 12); ctx.fill();
  // Page
  const pg = ctx.createLinearGradient(x,y,x+w,y+h);
  pg.addColorStop(0,'#fff9f0'); pg.addColorStop(1,'#ffeedd');
  ctx.fillStyle=pg; ctx.beginPath(); ctx.roundRect(x,y,w,h,12); ctx.fill();
  ctx.strokeStyle='#d4b896'; ctx.lineWidth=2;
  ctx.beginPath(); ctx.roundRect(x,y,w,h,12); ctx.stroke();
  // Binding
  ctx.fillStyle='#c4956a'; ctx.beginPath();
  ctx.roundRect(x+12,y,16,h,{upperLeft:12,bottomLeft:12}); ctx.fill();
  // Lines
  ctx.strokeStyle='rgba(180,150,120,0.25)'; ctx.lineWidth=1;
  for (let ly=y+35; ly<y+h-15; ly+=18) {
    ctx.beginPath(); ctx.moveTo(x+36,ly); ctx.lineTo(x+w-16,ly); ctx.stroke();
  }
  // Title
  ctx.font='bold 14px Georgia,serif'; ctx.fillStyle='#8d5524'; ctx.textAlign='center';
  ctx.fillText('âœ¨ Sticker Journal', x+w/2, y+22);
  // Stickers grid per level
  let sx=x+42, sy=y+42;
  const levelNames=['ğŸ ','ğŸŒ³','ğŸ¢','ğŸš‰'];
  for (let lv=0; lv<4; lv++) {
    const stks = collectedStickers[lv] || [];
    ctx.font='10px Nunito,sans-serif'; ctx.fillStyle='#a08070'; ctx.textAlign='left';
    ctx.fillText(levelNames[lv], sx, sy-4);
    for (let si=0; si<5; si++) {
      const stk = stks[si];
      // Slot
      ctx.fillStyle = stk ? 'rgba(255,220,160,0.4)' : 'rgba(200,180,150,0.15)';
      ctx.strokeStyle='rgba(180,150,100,0.3)'; ctx.lineWidth=1;
      ctx.beginPath(); ctx.roundRect(sx+si*33, sy+4, 28, 28, 4); ctx.fill(); ctx.stroke();
      if (stk) {
        ctx.font='16px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText(stk, sx+si*33+14, sy+18);
      } else {
        ctx.font='12px serif'; ctx.fillStyle='rgba(180,150,120,0.4)';
        ctx.fillText('?', sx+si*33+14, sy+18);
      }
    }
    sy += 44;
  }
  // Close hint
  ctx.font='10px Nunito,sans-serif'; ctx.fillStyle='#b09070'; ctx.textAlign='center';
  ctx.fillText('Press J or ğŸ“” to close', x+w/2, y+h-10);
  ctx.restore();
}
// â”€â”€â”€ END STICKER JOURNAL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


// â”€â”€â”€ HIDDEN ROOMS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnHiddenRoom(levelIdx, grid, R, floorCells, usedC, rng) {
  // Find a wall cluster near the middle and carve a small secret room
  const triggers = [
    {emoji:'ğŸ“š', name:'bookshelf'},
    {emoji:'ğŸª', name:'mirror'},
    {emoji:'ğŸ—„ï¸', name:'cabinet'},
    {emoji:'ğŸªŸ', name:'panel'},
  ];
  const t = triggers[levelIdx % triggers.length];
  // Find a floor cell adjacent to a wall to place trigger
  const candidates = floorCells.filter(p => {
    if (usedC.has(`${p.r},${p.c}`)) return false;
    // Must have a wall neighbor
    return [[p.r-1,p.c],[p.r+1,p.c],[p.r,p.c-1],[p.r,p.c+1]]
      .some(([nr,nc]) => nr>=0&&nr<R&&nc>=0&&nc<COLS && grid[nr][nc]===1);
  });
  if (!candidates.length) return null;
  const cell = candidates[Math.floor(rng()*Math.min(candidates.length,20))];
  usedC.add(`${cell.r},${cell.c}`);
  // Carve the secret room (3x3) beyond an adjacent wall
  const wallDirs = [[0,1],[0,-1],[1,0],[-1,0]];
  let carved = false, roomCenter = null;
  for (const [dr,dc] of wallDirs) {
    const wr=cell.r+dr, wc=cell.c+dc;
    if (wr<2||wr>R-3||wc<2||wc>COLS-3) continue;
    if (grid[wr][wc]!==1) continue;
    // Try to carve a 3x3 room beyond
    const ok = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,0],[0,1],[1,-1],[1,0],[1,1]]
      .every(([rrr,rcc])=>{
        const rr=wr+dr+rrr, rc=wc+dc+rcc;
        return rr>=1&&rr<R-1&&rc>=1&&rc<COLS-1;
      });
    if (!ok) continue;
    // Carve room
    for (const [rrr,rcc] of [[-1,-1],[-1,0],[-1,1],[0,-1],[0,0],[0,1],[1,-1],[1,0],[1,1]]) {
      grid[wr+dr+rrr][wc+dc+rcc] = 0;
    }
    grid[wr][wc] = 0; // open passage
    roomCenter = {r:wr+dr, c:wc+dc};
    carved = true;
    break;
  }
  if (!carved) return null;
  return {
    ...t,
    wx: cell.c*TILE+TILE/2, wy: cell.r*TILE+TILE/2,
    open: false, openAnim: 0, activated: false,
    roomCenter, roomX: roomCenter.c*TILE+TILE/2, roomY: roomCenter.r*TILE+TILE/2,
    // Decor inside the secret room
    decor: ['âœ¨','ğŸŒ¸','ğŸ’'].map((e,i)=>({
      emoji:e, wx:roomCenter.c*TILE+TILE/2+(i-1)*TILE*0.7, wy:roomCenter.r*TILE+TILE/2,
    })),
  };
}

function updateHiddenRoom() {
  if (!gs.hiddenRoom || gs.hiddenRoom.open) return;
  // Opened via scratch (handled in checkScratchHits via activateInteractable)
}

function drawHiddenRoom(t) {
  if (!gs.hiddenRoom) return;
  const r = gs.hiddenRoom;
  // Trigger object
  ctx.save(); ctx.translate(r.wx, r.wy);
  ctx.font='20px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
  if (!r.activated) {
    ctx.shadowColor='rgba(200,150,255,0.5)';
    ctx.shadowBlur=6+Math.sin(t*0.08)*4;
  }
  ctx.fillText(r.emoji, 0, 0);
  if (!r.activated) {
    ctx.shadowBlur=0;
    ctx.font='bold 7px Nunito,sans-serif'; ctx.fillStyle='rgba(150,100,200,0.7)';
    const cat = gs.cat;
    if (Math.hypot(cat.wx-r.wx,cat.wy-r.wy)<60)
      ctx.fillText('scratch me~', 0, -18);
  }
  ctx.restore();
  // Secret room decor
  if (r.open) {
    r.openAnim = Math.min(r.openAnim+1, 60);
    const prog = r.openAnim/60;
    for (const d of r.decor) {
      ctx.save(); ctx.translate(d.wx, d.wy);
      ctx.globalAlpha = prog;
      const bob = Math.sin(t*0.08+d.wx)*3;
      ctx.translate(0, bob - 20*(1-prog));
      ctx.shadowColor='#ffd700'; ctx.shadowBlur=8;
      ctx.font='18px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(d.emoji, 0, 0);
      ctx.restore();
    }
    // Sparkle aura around room
    if (r.openAnim < 50) {
      ctx.save();
      ctx.globalAlpha=(50-r.openAnim)/50*0.5;
      ctx.fillStyle='rgba(200,150,255,0.4)';
      ctx.beginPath(); ctx.arc(r.roomX, r.roomY, TILE*1.8, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }
  }
}
// â”€â”€â”€ END HIDDEN ROOMS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// â”€â”€â”€ END FISH TANK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// â”€â”€â”€ END WATERING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// â”€â”€â”€ END NAP SPOTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// â”€â”€â”€ END WEATHER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


// â”€â”€â”€ HELP MENU â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let helpOpen = false;
let helpAnim = 0;
let helpScroll = 0;

function toggleHelp() {
  helpOpen = !helpOpen;
  helpAnim = 0;
  helpScroll = 0;
}

const HELP_SECTIONS = [
  {
    icon: 'ğŸ®', title: 'Controls',
    items: [
      ['Move',       'Arrow keys / WASD  Â·  Joystick (mobile)'],
      ['Dash',       'Double-tap a direction  Â·  Quick flick joystick'],
      ['Scratch/Pet','X or Z  Â·  scratch button (mobile)'],
      ['Photo',      'P key  Â·  ğŸ“· button'],
      ['Journal',    'J key  Â·  ğŸ“” button'],
      ['Help',       'H key  Â·  â“ button'],
      ['Music',      'ğŸµ button to toggle on/off'],
    ]
  },
  {
    icon: 'ğŸ®', title: 'Mini-Games',
    items: [
      ['â† Games button', 'Return to the game selection screen anytime'],
      ['ğŸµ Music','Toggle the background music on or off'],
    ]
  },
  {
    icon: 'ğŸ±', title: 'Friendly Cats',
    items: [
      ['Meet them',   'Named cats roam each level â€” walk close to see their name'],
      ['Touch them',  'Brush past a cat and it will purr, mew, chirp or trill ğŸ’•'],
      ['Scratch near','Use X/Z close to a cat for an extra heart reaction'],
    ]
  },
  {
    icon: 'ğŸ‘¤', title: 'Humans',
    items: [
      ['Treat givers', 'Walk up and they hand you a ğŸŸ fish snack'],
      ['Petters',      'Some humans pet your cat â€” activates the ğŸŒˆ rainbow boost!'],
      ['Rainbow boost','Speed boost + glowing aura for 8 seconds'],
    ]
  },
  {
    icon: 'ğŸ˜´', title: 'Napping',
    items: [
      ['Find a spot',  'Look for ğŸ›ï¸ ğŸ›‹ï¸ ğŸŒ¿ ğŸªµ nap spots on the floor'],
      ['Fall asleep',  'Stand still on one for ~1.5s â€” cat curls up with Zzz'],
      ['Wake up',      'Move to wake â€” you get the ğŸŒˆ rainbow boost as a reward!'],
    ]
  },
  {
    icon: 'ğŸª£', title: 'Watering Can',
    items: [
      ['Find it',     'One ğŸª£ watering can hidden per level'],
      ['Use it',      'Walk near a wilted ğŸ¥€ plant and press X/Z to water it'],
      ['Watch it grow','The plant blooms into ğŸŒ¸ with a petal burst!'],
    ]
  },
  {
    icon: 'ğŸŸ', title: 'Fish Tank',
    items: [
      ['Find it',     'One fish tank near the start of each level'],
      ['Tap the glass','Walk up and your cat automatically paw-taps the glass'],
      ['Watch the fish','ğŸ  ğŸ¡ swim back and forth inside!'],
    ]
  },
  {
    icon: 'ğŸ“š', title: 'Hidden Rooms',
    items: [
      ['Find the trigger','Look for glowing ğŸ“šğŸªğŸ—„ï¸ğŸªŸ objects on walls'],
      ['Open it',         'Scratch near it (X/Z) to reveal a secret room!'],
      ['Explore inside',  'Secret rooms hold glowing treasures âœ¨ğŸ’ğŸŒ¸'],
    ]
  },
  {
    icon: 'ğŸŒŸ', title: 'Secrets & Stickers',
    items: [
      ['Hidden secrets','Walk everywhere â€” items shimmer âœ¨ when close'],
      ['Stickers',      'Collect 3 stickers per level â€” glow gold when near'],
      ['Your journal',  'Press J or ğŸ“” to see all collected stickers'],
    ]
  },
  {
    icon: 'ğŸŒ…', title: 'World & Weather',
    items: [
      ['Day/Night',   'World cycles: Dawn ğŸŒ… Â· Day â˜€ï¸ Â· Dusk ğŸŒ‡ Â· Night ğŸŒ™'],
      ['Stars',       'Look up at night â€” stars appear and twinkle!'],
      ['Weather',     'Home: ğŸŒ§ï¸  Â·  Park: ğŸŒ¸  Â·  Building: âœ¨  Â·  Station: â„ï¸'],
    ]
  },
  {
    icon: 'ğŸ“·', title: 'Photo Mode',
    items: [
      ['Take a photo', 'Press P or ğŸ“· to capture the current scene'],
      ['Polaroid',     'Downloads as a PNG with a cozy polaroid border'],
      ['Best shots',   'Try capturing cats, blooming flowers, or night scenes!'],
    ]
  },
];
function drawHelp(t) {
  if (!helpOpen) return;
  if (!t && t !== 0) t = Date.now() * 0.016;
  helpAnim = Math.min(helpAnim + 1, 14);
  const ease = helpAnim / 14;
  const smooth = ease < 0.5 ? 2*ease*ease : -1+(4-2*ease)*ease;

  // Full-screen semi-transparent backdrop
  ctx.save();
  ctx.fillStyle = `rgba(30,20,50,${0.82 * smooth})`;
  ctx.fillRect(0, 0, CW, CH);

  const PW = Math.min(CW - 24, 340);
  const PH = CH - 32;
  const PX = (CW - PW) / 2;
  const PY = 16;

  // Panel
  ctx.save();
  ctx.translate(CW/2, CH/2);
  ctx.scale(0.85 + 0.15*smooth, 0.85 + 0.15*smooth);
  ctx.translate(-CW/2, -CH/2);

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.25)';
  ctx.beginPath(); ctx.roundRect(PX+4, PY+4, PW, PH, 16); ctx.fill();

  // Panel background â€” warm parchment
  const pg = ctx.createLinearGradient(PX, PY, PX+PW, PY+PH);
  pg.addColorStop(0, '#fff8f0');
  pg.addColorStop(1, '#ffeedd');
  ctx.fillStyle = pg;
  ctx.beginPath(); ctx.roundRect(PX, PY, PW, PH, 16); ctx.fill();

  // Decorative border
  ctx.strokeStyle = '#d4a574';
  ctx.lineWidth = 2.5;
  ctx.beginPath(); ctx.roundRect(PX+4, PY+4, PW-8, PH-8, 12); ctx.stroke();

  // Header
  ctx.fillStyle = '#5d3a1a';
  ctx.font = 'bold 17px Nunito, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('âœ¨ How to Play âœ¨', CW/2, PY + 28);

  // Divider
  ctx.strokeStyle = '#d4a574';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(PX + 20, PY + 38);
  ctx.lineTo(PX + PW - 20, PY + 38);
  ctx.stroke();

  // Scrollable content area â€” use clipping
  const contentY = PY + 46;
  const contentH = PH - 60;
  ctx.save();
  ctx.beginPath();
  ctx.rect(PX + 8, contentY, PW - 16, contentH);
  ctx.clip();

  const SECTION_GAP = 10;
  const ITEM_H = 28;
  const SECTION_TITLE_H = 22;
  let totalH = 0;
  for (const s of HELP_SECTIONS) {
    totalH += SECTION_TITLE_H + s.items.length * ITEM_H + SECTION_GAP;
  }
  const maxScroll = Math.max(0, totalH - contentH);

  // Scroll via mouse wheel / touch (handled separately)
  let yOff = contentY - helpScroll;

  for (const sec of HELP_SECTIONS) {
    if (yOff + SECTION_TITLE_H > contentY && yOff < contentY + contentH) {
      // Section header
      ctx.fillStyle = 'rgba(212,165,116,0.25)';
      ctx.beginPath();
      ctx.roundRect(PX+10, yOff, PW-20, SECTION_TITLE_H, 6);
      ctx.fill();

      ctx.font = 'bold 11px Nunito, sans-serif';
      ctx.textAlign = 'left';
      ctx.fillStyle = '#7b4c1e';
      ctx.fillText(`${sec.icon} ${sec.title}`, PX + 18, yOff + 15);
    }
    yOff += SECTION_TITLE_H;

    for (const [label, desc] of sec.items) {
      if (yOff + ITEM_H > contentY && yOff < contentY + contentH) {
        // Key chip
        ctx.fillStyle = '#f3e5d0';
        ctx.strokeStyle = '#d4a574';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.roundRect(PX + 14, yOff + 5, 62, 17, 4);
        ctx.fill(); ctx.stroke();

        ctx.font = 'bold 8.5px Nunito, sans-serif';
        ctx.fillStyle = '#8b5e3c';
        ctx.textAlign = 'center';
        ctx.fillText(label, PX + 45, yOff + 16);

        // Description
        ctx.font = '9px Nunito, sans-serif';
        ctx.fillStyle = '#5a3820';
        ctx.textAlign = 'left';
        ctx.fillText(desc, PX + 84, yOff + 16);
      }
      yOff += ITEM_H;
    }
    yOff += SECTION_GAP;
  }

  ctx.restore(); // unclip

  // Scroll indicator
  if (maxScroll > 0) {
    const trackH = contentH - 10;
    const thumbH = Math.max(30, trackH * (contentH / totalH));
    const thumbY = contentY + 5 + (helpScroll / maxScroll) * (trackH - thumbH);
    ctx.fillStyle = 'rgba(212,165,116,0.3)';
    ctx.beginPath(); ctx.roundRect(PX+PW-14, contentY+5, 6, trackH, 3); ctx.fill();
    ctx.fillStyle = '#d4a574';
    ctx.beginPath(); ctx.roundRect(PX+PW-14, thumbY, 6, thumbH, 3); ctx.fill();
  }

  // Footer
  ctx.font = '9px Nunito, sans-serif';
  ctx.fillStyle = '#a08060';
  ctx.textAlign = 'center';
  ctx.fillText('Scroll â†•  Â·  Press H or â“ to close', CW/2, PY + PH - 8);

  ctx.restore(); // unscale
  ctx.restore(); // main save

  // Store maxScroll for event handlers
  drawHelp._maxScroll = maxScroll;
}

// â”€â”€â”€ END HELP MENU â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// â”€â”€â”€ DAY/NIGHT CYCLE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Cycles over ~8 minutes (28800 frames at 60fps), or manually via HUD
// Phases: dawn(0-0.15) â†’ day(0.15-0.5) â†’ dusk(0.5-0.7) â†’ night(0.7-1)
const DAY_CYCLE_LEN = 3600; // ~1 min per full cycle â€” cozy but visible
const TIME_OVERLAYS = [
  // [phase_start, r,g,b, alpha, label]
  [0.00, 255,180,120, 0.10, 'Dawn ğŸŒ…'],
  [0.15, 255,255,220, 0.00, 'Day â˜€ï¸'],
  [0.50, 255,150, 80, 0.12, 'Dusk ğŸŒ‡'],
  [0.70,  30, 20, 80, 0.30, 'Night ğŸŒ™'],
  [0.90, 255,180,120, 0.08, 'Dawn ğŸŒ…'],
];

function getDayPhase() {
  if (!gs) return 0.2;
  return (gs.time % DAY_CYCLE_LEN) / DAY_CYCLE_LEN;
}

function getDayOverlay() {
  const ph = getDayPhase();
  // Find surrounding keyframes and lerp
  const kf = TIME_OVERLAYS;
  let a = kf[kf.length-1], b = kf[0];
  for (let i = 0; i < kf.length-1; i++) {
    if (ph >= kf[i][0] && ph < kf[i+1][0]) { a = kf[i]; b = kf[i+1]; break; }
  }
  const t = (ph - a[0]) / Math.max(0.001, b[0] - a[0]);
  const r = Math.round(a[1] + (b[1]-a[1])*t);
  const g = Math.round(a[2] + (b[2]-a[2])*t);
  const bv = Math.round(a[3] + (b[3]-a[3])*t);
  const al = a[4] + (b[4]-a[4])*t;
  return {r,g,b:bv,al, label: ph < 0.15||ph >= 0.9 ? 'Dawn ğŸŒ…' : ph < 0.5 ? 'Day â˜€ï¸' : ph < 0.7 ? 'Dusk ğŸŒ‡' : 'Night ğŸŒ™'};
}

function drawDayNightOverlay() {
  const ov = getDayOverlay();
  if (ov.al < 0.01) return;
  ctx.fillStyle = `rgba(${ov.r},${ov.g},${ov.b},${ov.al.toFixed(3)})`;
  ctx.fillRect(0, 0, CW, CH);
  // Stars at night
  if (getDayPhase() > 0.65) {
    const starAlpha = Math.min(1, (getDayPhase()-0.65)/0.1) * 0.6;
    ctx.fillStyle = `rgba(255,255,255,${starAlpha})`;
    // Fixed stars (seeded)
    for (let i = 0; i < 28; i++) {
      const sx = (i*137.5 % CW);
      const sy = (i*97.3 % (CH*0.6));
      const pulse = 0.5 + Math.sin(gs.time*0.05 + i)*0.5;
      ctx.globalAlpha = starAlpha * pulse;
      ctx.beginPath(); ctx.arc(sx, sy, 1.2, 0, Math.PI*2); ctx.fill();
    }
    ctx.globalAlpha = 1;
  }
}
// â”€â”€â”€ END DAY/NIGHT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// â”€â”€â”€ END HELP MENU â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONSTANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const CW = 420, CH = 700;
const TILE = 42;
const COLS = 10;
const C = COLS; // global alias used throughout
const CAT_SPEED = 2.1;
const SCRATCH_RANGE = 92;
const DASH_SPEED = 8.5;
const DASH_FRAMES = 18;
const DASH_COOLDOWN = 90;   // 1.5s at 60fps
const HAPPY_DURATION = 480; // 8s
const HAPPY_SPEED_MULT = 1.18;

const SCRATCH_ARC = Math.PI * 1.1;
const SCRATCH_COOLDOWN = 24;

const CAT_COUNT_MULT = 1.0; // no difficulty â€” always cozy

const CAT_COLORS = [
  {body:'#fff9f0',dark:'#ffe0cc',stroke:'#ffb3a0'},
  {body:'#ffb74d',dark:'#e65100',stroke:'#bf360c'},
  {body:'#bdbdbd',dark:'#757575',stroke:'#616161'},
  {body:'#424242',dark:'#212121',stroke:'#1a1a1a'},
  {body:'#ffcc80',dark:'#ffa000',stroke:'#ff8f00'},
  {body:'#bcaaa4',dark:'#795548',stroke:'#6d4c41'},
  {body:'#f8bbd0',dark:'#f48fb1',stroke:'#e91e63'},
];
const EYE_COLORS = ['#43a047','#1e88e5','#fb8c00','#8e24aa','het'];

let catCfg = {colorIdx:0, pattern:'solid', eyeIdx:0, accessory:'none'};
let catName = 'Mochi';
let currentLevel = 0;
let unlockedLevels = 1;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CAT DRAWING (top-down)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drawCatTopDown(ctx, x, y, cfg, t=0, facingAngle=0, moving=false, scratchAnim=0) {
  const col = CAT_COLORS[cfg.colorIdx];
  const eyeCol = cfg.eyeIdx === 4 ? null : EYE_COLORS[cfg.eyeIdx];
  const bobY = moving ? Math.sin(t * 0.28) * 1.5 : 0;
  ctx.save();
  ctx.translate(x, y + bobY);
  ctx.rotate(facingAngle);

  // Tail wag
  const tailWag = Math.sin(t * 0.12) * 18;
  ctx.strokeStyle = col.body; ctx.lineWidth = 7; ctx.lineCap = 'round';
  ctx.beginPath(); ctx.moveTo(0, 10);
  ctx.quadraticCurveTo(16 + tailWag, 24, 10 + tailWag, 36); ctx.stroke();
  ctx.strokeStyle = col.stroke; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(0, 10);
  ctx.quadraticCurveTo(16 + tailWag, 24, 10 + tailWag, 36); ctx.stroke();

  // Body
  ctx.fillStyle = col.body; ctx.strokeStyle = col.stroke; ctx.lineWidth = 2.5;
  ctx.beginPath(); ctx.ellipse(0, 4, 13, 16, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke();

  // Patterns
  if (cfg.pattern === 'tabby') {
    ctx.save(); ctx.globalAlpha = 0.35; ctx.fillStyle = col.dark;
    ctx.fillRect(-5, 0, 4, 10); ctx.fillRect(1, -4, 4, 8); ctx.fillRect(-3, 8, 6, 5); ctx.restore();
  } else if (cfg.pattern === 'spots') {
    ctx.save(); ctx.globalAlpha = 0.4; ctx.fillStyle = col.dark;
    ctx.beginPath(); ctx.arc(-5, 2, 4, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(4, 10, 3, 0, Math.PI * 2); ctx.fill(); ctx.restore();
  } else if (cfg.pattern === 'tuxedo') {
    ctx.save(); ctx.fillStyle = 'white';
    ctx.beginPath(); ctx.ellipse(0, 7, 6, 9, 0, 0, Math.PI * 2); ctx.fill(); ctx.restore();
  } else if (cfg.pattern === 'calico') {
    ctx.save(); ctx.globalAlpha = 0.5;
    ctx.fillStyle = '#e65100'; ctx.beginPath(); ctx.arc(-5, 0, 5, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#212121'; ctx.beginPath(); ctx.arc(4, 8, 4, 0, Math.PI * 2); ctx.fill(); ctx.restore();
  }

  // Head
  ctx.fillStyle = col.body; ctx.strokeStyle = col.stroke; ctx.lineWidth = 2.5;
  ctx.beginPath(); ctx.arc(0, -12, 13, 0, Math.PI * 2); ctx.fill(); ctx.stroke();

  // Ears
  ctx.fillStyle = col.body; ctx.strokeStyle = col.stroke; ctx.lineWidth = 2;
  [[-8, -22], [8, -22]].forEach(([ex, ey]) => {
    ctx.beginPath(); ctx.moveTo(ex - 6, ey + 2); ctx.lineTo(ex + 6, ey + 2); ctx.lineTo(ex, ey - 11); ctx.closePath(); ctx.fill(); ctx.stroke();
  });
  ctx.fillStyle = '#f8bbd0';
  [[-8, -22], [8, -22]].forEach(([ex, ey]) => {
    ctx.beginPath(); ctx.moveTo(ex - 3.5, ey + 1); ctx.lineTo(ex + 3.5, ey + 1); ctx.lineTo(ex, ey - 7); ctx.closePath(); ctx.fill();
  });

  // Eyes
  const blink = (Math.floor(t * 0.025) % 45 === 0);
  const eyeH = blink ? 1 : 4.5;
  [[-5, -13], [5, -13]].forEach(([ex, ey], i) => {
    ctx.fillStyle = cfg.eyeIdx === 4 ? (i === 0 ? '#1e88e5' : '#fb8c00') : eyeCol;
    ctx.beginPath(); ctx.ellipse(ex, ey, 3.5, eyeH, 0, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(ex + 1, ey - 1, 1.2, 0, Math.PI * 2); ctx.fill();
  });

  // Nose + mouth
  ctx.fillStyle = '#f48fb1'; ctx.beginPath(); ctx.arc(0, -9, 2.5, 0, Math.PI * 2); ctx.fill();
  ctx.strokeStyle = '#f48fb1'; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.moveTo(0, -7); ctx.lineTo(-3, -5); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(0, -7); ctx.lineTo(3, -5); ctx.stroke();

  // Whiskers
  ctx.strokeStyle = 'rgba(150,120,110,0.5)'; ctx.lineWidth = 1;
  [[-14, -10], [-18, -9], [-14, -8]].forEach(([wx, wy]) => { ctx.beginPath(); ctx.moveTo(-2, -9); ctx.lineTo(wx, wy); ctx.stroke(); });
  [[14, -10], [18, -9], [14, -8]].forEach(([wx, wy]) => { ctx.beginPath(); ctx.moveTo(2, -9); ctx.lineTo(wx, wy); ctx.stroke(); });

  // Blush
  ctx.fillStyle = 'rgba(255,140,140,0.2)';
  ctx.beginPath(); ctx.ellipse(-7, -11, 4, 2.5, 0, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(7, -11, 4, 2.5, 0, 0, Math.PI * 2); ctx.fill();

  // Scratch animation â€” claw arc in front
  if (scratchAnim > 0) {
    const progress = 1 - scratchAnim / SCRATCH_COOLDOWN;
    ctx.save();
    ctx.globalAlpha = (1 - progress) * 0.85;
    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2.5; ctx.lineCap = 'round';
    const sweepAngle = SCRATCH_ARC * progress;
    for (let ci = 0; ci < 3; ci++) {
      const off = (ci - 1) * 0.28;
      ctx.beginPath();
      ctx.arc(0, -12, 28 + ci * 7, -Math.PI / 2 - SCRATCH_ARC / 2 + off,
              -Math.PI / 2 - SCRATCH_ARC / 2 + sweepAngle + off);
      ctx.stroke();
    }
    // Claw sparks
    ctx.fillStyle = '#ffe082';
    for (let ci = 0; ci < 4; ci++) {
      const sa = -Math.PI / 2 - SCRATCH_ARC / 2 + sweepAngle + (ci - 1.5) * 0.2;
      const r = 34 + ci * 4;
      ctx.beginPath(); ctx.arc(Math.cos(sa) * r, -12 + Math.sin(sa) * r, 2.5, 0, Math.PI * 2); ctx.fill();
    }
    ctx.restore();
  }

  drawAccessory(ctx, cfg.accessory, t);
  ctx.restore();
}

function drawAccessory(ctx, acc, t) {
  if (acc === 'none') return;
  if (acc === 'bow') {
    ctx.fillStyle = '#f44336'; ctx.strokeStyle = '#b71c1c'; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(0, -24); ctx.bezierCurveTo(-8, -30, -12, -22, -6, -20); ctx.bezierCurveTo(-2, -18, 0, -22, 0, -24); ctx.fill(); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0, -24); ctx.bezierCurveTo(8, -30, 12, -22, 6, -20); ctx.bezierCurveTo(2, -18, 0, -22, 0, -24); ctx.fill(); ctx.stroke();
    ctx.fillStyle = '#ffcdd2'; ctx.beginPath(); ctx.arc(0, -24, 3, 0, Math.PI * 2); ctx.fill();
  } else if (acc === 'flower') {
    for (let i = 0; i < 6; i++) {
      const a = i / 6 * Math.PI * 2;
      ctx.fillStyle = i % 2 === 0 ? '#f48fb1' : '#fff';
      ctx.beginPath(); ctx.ellipse(Math.cos(a) * 6, Math.sin(a) * 6 - 24, 3.5, 3.5, a, 0, Math.PI * 2); ctx.fill();
    }
    ctx.fillStyle = '#ffe082'; ctx.beginPath(); ctx.arc(0, -24, 3.5, 0, Math.PI * 2); ctx.fill();
  } else if (acc === 'hat') {
    ctx.fillStyle = '#212121'; ctx.strokeStyle = '#424242'; ctx.lineWidth = 1.5;
    ctx.fillRect(-9, -34, 18, 10); ctx.stroke();
    ctx.fillRect(-12, -35, 24, 4); ctx.stroke();
    ctx.fillStyle = '#f48fb1'; ctx.fillRect(-9, -33, 18, 3);
  } else if (acc === 'stars') {
    const st = t * 0.05;
    [[-10, -24], [10, -24], [0, -28]].forEach(([sx, sy], i) => {
      const p = 0.8 + Math.sin(st + i) * 0.3;
      ctx.save(); ctx.translate(sx, sy); ctx.scale(p, p);
      ctx.fillStyle = ['#ffd700', '#ff6b9d', '#64dfdf'][i];
      drawStar(ctx, 0, 0, 4, 2); ctx.restore();
    });
  } else if (acc === 'crown') {
    ctx.fillStyle = '#ffd700'; ctx.strokeStyle = '#ff8f00'; ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(-10, -26); ctx.lineTo(-10, -34); ctx.lineTo(-6, -30);
    ctx.lineTo(0, -36); ctx.lineTo(6, -30); ctx.lineTo(10, -34); ctx.lineTo(10, -26); ctx.closePath();
    ctx.fill(); ctx.stroke();
    ['#e53935', '#1e88e5', '#43a047'].forEach((c, i) => {
      ctx.fillStyle = c; ctx.beginPath(); ctx.arc(-5 + i * 5, -28, 1.8, 0, Math.PI * 2); ctx.fill();
    });
  }
}

function drawStar(ctx, cx, cy, r1, r2) {
  ctx.beginPath();
  for (let i = 0; i < 10; i++) {
    const a = i / 10 * Math.PI * 2 - Math.PI / 2;
    const r = i % 2 === 0 ? r1 : r2;
    i === 0 ? ctx.moveTo(cx + Math.cos(a) * r, cy + Math.sin(a) * r)
            : ctx.lineTo(cx + Math.cos(a) * r, cy + Math.sin(a) * r);
  }
  ctx.closePath(); ctx.fill();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UI
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let previewAnimId = null;

function updatePreview() {
  clearTimeout(updatePreview._t);
  updatePreview._t = setTimeout(() => {
    renderCatPreview('previewCanvas', 90, 90);
    renderCatPreview('titleCatCanvas', 130, 130);
  }, 16);
}

function renderCatPreview(id, w, h) {
  const c = document.getElementById(id); if (!c) return;
  const cx = c.getContext('2d');
  cx.clearRect(0, 0, w, h);
  drawCatTopDown(cx, w / 2, h / 2 + 8, catCfg, Date.now() * 0.016, 0, false, 0);
}

function setCatProp(prop, val) {
  catCfg[prop] = val;
  if (prop === 'colorIdx') document.querySelectorAll('#color-swatches .swatch').forEach(s => s.classList.toggle('selected', +s.dataset.idx === val));
  else if (prop === 'eyeIdx') document.querySelectorAll('#eye-swatches .swatch').forEach(s => s.classList.toggle('selected', +s.dataset.idx === val));
  else if (prop === 'pattern') document.querySelectorAll('#pattern-opts .opt-btn').forEach(s => s.classList.toggle('selected', s.dataset.val === val));
  else if (prop === 'accessory') document.querySelectorAll('#acc-opts .opt-btn').forEach(s => s.classList.toggle('selected', s.dataset.val === val));
  updatePreview();
}


function showScreen(id) {
  document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
  const el = document.getElementById(id); if (el) el.classList.remove('hidden');
  document.getElementById('hud').style.display = 'none';
  document.getElementById('game-canvas-wrap').style.display = 'none';
  if (id === 'custom-screen') { updatePreview(); startPreviewAnim(); }
  else if (id === 'title-screen') startPreviewAnim();
  else stopPreviewAnim();
}

function startPreviewAnim() {
  stopPreviewAnim();
  if (musicEnabled && !musicPlaying) startMusic();
  function frame() {
    renderCatPreview('previewCanvas', 90, 90);
    renderCatPreview('titleCatCanvas', 130, 130);
    previewAnimId = requestAnimationFrame(frame);
  }
  previewAnimId = requestAnimationFrame(frame);
}
function stopPreviewAnim() { if (previewAnimId) { cancelAnimationFrame(previewAnimId); previewAnimId = null; } }

function stopAllGames() {
  if (soccerRaf)  { cancelAnimationFrame(soccerRaf);  soccerRaf=null;  }
  if (zenRaf)     { cancelAnimationFrame(zenRaf);     zenRaf=null;     }
  if (fishRaf)    { cancelAnimationFrame(fishRaf);    fishRaf=null;    }
  if (yarnRaf)    { cancelAnimationFrame(yarnRaf);    yarnRaf=null;    }
  if (gardenRaf)  { cancelAnimationFrame(gardenRaf);  gardenRaf=null;  }
  if (topiaryRaf) { cancelAnimationFrame(topiaryRaf); topiaryRaf=null; }
  if (raf)        { cancelAnimationFrame(raf);        raf=null;        }
  soccerState=null; zenState=null; fishState=null; yarnState=null; gardenState=null; topiaryState=null; gs=null;
}
function goLevelSelect() {
  stopAllGames();
  catName = document.getElementById('cat-name-input')?.value.trim() || 'Mochi';
  document.getElementById('hud').style.display='none';
  document.getElementById('game-canvas-wrap').style.display='none';
  showScreen('level-screen');
}
function quickPlay() { catName = document.getElementById('cat-name-input')?.value.trim() || 'Mochi'; showScreen('level-screen'); }
function retryLevel() { goLevelSelect(); }
function nextLevel() { goLevelSelect(); }


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// âš½ CAT SOCCER â€” LEVEL 4
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Field dimensions (in pixels, no tile system â€” rendered directly)
const SF = {
  W: 420, H: 660,        // full canvas
  FX: 30, FY: 60,        // field left/top
  FW: 360, FH: 520,      // field width/height
  GW: 90, GD: 22,        // goal width, goal depth
  GOALS_TO_WIN: 7,
};
// Derived
SF.GX = SF.FX + SF.FW/2 - SF.GW/2; // goal X (centred)
SF.TOP_GY    = SF.FY - SF.GD;       // top goal Y
SF.BOTTOM_GY = SF.FY + SF.FH;       // bottom goal mouth Y

let soccerState = null; // null = not playing soccer


function setHudMode(mode) {
  // mode: 'rpg' | 'minigame' | 'hidden'
  const back     = document.getElementById('games-back-btn');
  const keyPill  = document.getElementById('key-indicator-pill');
  const happyPill= document.getElementById('happy-hud');
  const waterPill= document.getElementById('watering-hud');
  const dayPill  = document.getElementById('daytime-hud');
  const tc       = document.getElementById('touch-controls');
  const hud      = document.getElementById('hud');

  if (mode === 'hidden') {
    hud.style.display = 'none';
    tc.classList.add('hidden-all');
    return;
  }

  hud.style.display = 'block';
  back.style.display      = mode === 'minigame' ? 'flex' : 'none';
  keyPill.style.display   = mode === 'rpg'      ? 'flex'  : 'none';
  happyPill.style.display = 'none'; // managed by updateHUD
  waterPill.style.display = 'none'; // managed by updateHUD
  dayPill.style.display   = mode === 'rpg'      ? 'flex'  : 'none';

  // Touch controls: RPG gets full joystick+scratch; soccer gets scratch only (for kickoff);
  // other mini-games hide all touch controls (they use canvas tap/swipe directly)
  tc.classList.remove('hidden-all', 'hide-joystick');
  if (mode === 'soccer') {
    tc.classList.add('hide-joystick'); // scratch-btn stays for kickoff
  } else if (mode === 'minigame') {
    tc.classList.add('hidden-all'); // mini-games use canvas input only
  }
  // RPG: full controls shown via media query (no class modification)
}

function beginSoccer() {
  stopAllGames();
  stopMusic();
  setHudMode('soccer');
  document.getElementById('game-canvas-wrap').style.display = 'block';
  document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));

  const catColors = [2, 1, 3, 6, 4]; // grey, orange, black, pink, cream
  soccerState = {
    running: false,  // starts paused until kickoff button
    kickedOff: false,
    time: 0,
    playerScore: 0,
    aiScore: 0,
    celebration: 0,       // countdown after a goal
    celebrationMsg: '',
    celebrationColor: '',
    winner: null,          // 'player' | 'ai' | null
    lastScorer: null,

    ball: {
      x: SF.FX + SF.FW/2,
      y: SF.FY + SF.FH/2,
      vx: 0, vy: 0,
      r: 11,
    },

    // Player cat
    player: {
      x: SF.FX + SF.FW/2,
      y: SF.FY + SF.FH * 0.78,
      vx: 0, vy: 0,
      r: 14,
      facingAngle: Math.PI,
      moving: false,
      dashFrames: 0, dashCooldown: 0, dashDx: 0, dashDy: 0,
      cfg: { colorIdx: catCfg.colorIdx, pattern: catCfg.pattern, eyeIdx: catCfg.eyeIdx, accessory: catCfg.accessory },
      isPlayer: true,
    },

    // Single opponent cat â€” roams whole field
    aiCats: [
      { x: SF.FX + SF.FW*0.5, y: SF.FY + SF.FH*0.22, vx:0, vy:0, r:14,
        facingAngle:0, moving:false, dashFrames:0, dashCooldown:0,
        cfg:{colorIdx:1,pattern:'tabby',eyeIdx:2,accessory:'none'},
        role:'roamer', thinkTimer:0, name:'Mikan', team:'enemy' },
    ],
    teammate: null,

    particles: [],
    joystick: {active:false, dx:0, dy:0},
    scratchPressed: false,
  };

  if (musicEnabled) startMusic();
  if (raf) cancelAnimationFrame(raf);
  soccerLoop();
}

function resetSoccerPositions(scoredTeam) {
  const ss = soccerState;
  ss.ball.x = SF.FX + SF.FW/2;
  ss.ball.y = SF.FY + SF.FH/2;
  ss.ball.vx = (Math.random()-0.5)*1.5;
  ss.ball.vy = scoredTeam === 'player' ? -1.5 : 1.5;

  ss.player.x = SF.FX + SF.FW/2;
  ss.player.y = SF.FY + SF.FH*0.78;
  ss.player.vx = ss.player.vy = 0;
  ss.player.dashFrames = 0;

  const ai0 = ss.aiCats[0];
  ai0.x = SF.FX+SF.FW*0.5; ai0.y = SF.FY+SF.FH*0.22;
  ai0.vx = ai0.vy = 0; ai0.dashFrames = 0;
  // Pause for kickoff button after each goal
  ss.running = false;
  ss.kickedOff = false;
}

// â”€â”€ Soccer physics update â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateSoccer() {
  const ss = soccerState;
  if (!ss || !ss.running) return;
  ss.time++;

  // Kickoff pause â€” wait for button press
  if (!ss.running) return;

  // Celebration pause after goal
  if (ss.celebration > 0) {
    ss.celebration--;
    if (ss.celebration === 0) {
      if (ss.winner) { endSoccer(); return; }
      resetSoccerPositions(ss.lastScorer);
    }
    updateSoccerParticles();
    return;
  }

  // â”€â”€ Player input â”€â”€
  const p = ss.player;
  let ix=0, iy=0;
  if (keys['ArrowLeft']||keys['KeyA']) ix-=1;
  if (keys['ArrowRight']||keys['KeyD']) ix+=1;
  if (keys['ArrowUp']||keys['KeyW']) iy-=1;
  if (keys['ArrowDown']||keys['KeyS']) iy+=1;
  if (ss.joystick.active) { ix+=ss.joystick.dx; iy+=ss.joystick.dy; }
  const ilen = Math.hypot(ix,iy); if (ilen>1){ix/=ilen;iy/=ilen;}
  p.moving = ilen>0.1;

  const PLAYER_SPEED = 4.2;
  if (p.dashFrames > 0) {
    p.dashFrames--;
    p.x += p.dashDx * 8.5;
    p.y += p.dashDy * 8.5;
  } else {
    p.x += ix * PLAYER_SPEED;
    p.y += iy * PLAYER_SPEED;
  }
  if (p.dashCooldown > 0) p.dashCooldown--;
  if (p.moving) p.facingAngle = Math.atan2(iy,ix)+Math.PI/2;

  // Clamp player to full field
  p.x = Math.max(SF.FX+p.r, Math.min(SF.FX+SF.FW-p.r, p.x));
  p.y = Math.max(SF.FY+p.r, Math.min(SF.FY+SF.FH-p.r, p.y));

  // â”€â”€ AI cats â”€â”€
  ss.aiCats.forEach(ai => updateSoccerAI(ai, ss));

  // â”€â”€ Ball physics â”€â”€
  const b = ss.ball;
  const FRICTION = 0.991;
  b.x += b.vx; b.y += b.vy;
  b.vx *= FRICTION; b.vy *= FRICTION;

  // Ball wall bounce (field edges, excluding goals)
  // Left/right walls
  if (b.x - b.r < SF.FX)  { b.x = SF.FX+b.r;         b.vx = Math.abs(b.vx)*0.92; playSoccerBounce(); }
  if (b.x + b.r > SF.FX+SF.FW) { b.x = SF.FX+SF.FW-b.r; b.vx = -Math.abs(b.vx)*0.92; playSoccerBounce(); }

  // Top wall â€” but allow through goal opening
  if (b.y - b.r < SF.FY) {
    const inGoal = b.x > SF.GX && b.x < SF.GX+SF.GW;
    if (inGoal) {
      // GOAL for player!
      if (b.y - b.r < SF.TOP_GY - b.r) {
        soccerGoal('player');
        return;
      }
    } else {
      b.y = SF.FY+b.r; b.vy = Math.abs(b.vy)*0.92; playSoccerBounce();
    }
  }
  // Bottom wall â€” allow through goal opening
  if (b.y + b.r > SF.FY+SF.FH) {
    const inGoal = b.x > SF.GX && b.x < SF.GX+SF.GW;
    if (inGoal) {
      if (b.y + b.r > SF.BOTTOM_GY + SF.GD + b.r) {
        soccerGoal('ai');
        return;
      }
    } else {
      b.y = SF.FY+SF.FH-b.r; b.vy = -Math.abs(b.vy)*0.92; playSoccerBounce();
    }
  }

  // â”€â”€ Ball-cat collisions â”€â”€
  [p, ...ss.aiCats].forEach(cat => {
    const dx = b.x-cat.x, dy = b.y-cat.y;
    const dist = Math.hypot(dx,dy);
    const minDist = b.r + cat.r;
    if (dist < minDist && dist > 0.1) {
      const nx = dx/dist, ny = dy/dist;
      b.x = cat.x + nx*minDist;
      b.y = cat.y + ny*minDist;
      const isDashing = cat.dashFrames > 0 || cat.justDashed;
      const catSpd = cat.isPlayer ? Math.hypot(ix,iy)*PLAYER_SPEED : Math.hypot(cat.vx,cat.vy);
      const kickPow = isDashing ? 15 : catSpd*0.8 + 2.5;
      const existingDot = b.vx*nx + b.vy*ny;
      if (existingDot < kickPow) {
        b.vx += (kickPow - existingDot) * nx;
        b.vy += (kickPow - existingDot) * ny;
      }
      playSoccerKick();
    }
    // Clear justDashed after collision check so it lasts exactly one frame
    cat.justDashed = false;
  });

  // Speed cap on ball
  const bspd = Math.hypot(b.vx,b.vy);
  if (bspd > 22) { b.vx = b.vx/bspd*22; b.vy = b.vy/bspd*22; }

  updateSoccerParticles();
}

function updateSoccerAI(ai, ss) {
  // Smart AI: positions BEHIND the ball relative to player goal, then kicks
  const b = ss.ball;
  const AI_SPEED = 2.5;

  // Player goal is at the BOTTOM â€” so AI wants to be north of the ball
  // to kick it southward into the goal.
  const GOAL_GX = SF.FX + SF.FW/2;   // goal centre x
  const GOAL_GY = SF.FY + SF.FH;     // goal mouth y (bottom)

  // Vector from ball toward player goal
  const toBallGoalDx = GOAL_GX - b.x;
  const toBallGoalDy = GOAL_GY - b.y;
  const toBallGoalLen = Math.hypot(toBallGoalDx, toBallGoalDy) || 1;
  const toBallGoalNx = toBallGoalDx / toBallGoalLen;
  const toBallGoalNy = toBallGoalDy / toBallGoalLen;

  // Ideal approach position: stand 32px BEHIND the ball (opposite to goal)
  const APPROACH_DIST = 34;
  const approachX = b.x - toBallGoalNx * APPROACH_DIST;
  const approachY = b.y - toBallGoalNy * APPROACH_DIST;

  const bdist = Math.hypot(b.x - ai.x, b.y - ai.y);
  const approachDist = Math.hypot(approachX - ai.x, approachY - ai.y);

  let targetX, targetY;

  if (approachDist > 20 && bdist > 40) {
    // Far from ball â€” move toward approach position
    targetX = approachX;
    targetY = approachY;
  } else if (approachDist > 12) {
    // Getting close â€” blend between approach pos and ball
    const t = 1 - approachDist / 20;
    targetX = approachX * (1-t) + b.x * t;
    targetY = approachY * (1-t) + b.y * t;
  } else {
    // In position â€” drive through the ball toward goal
    targetX = GOAL_GX;
    targetY = GOAL_GY;
  }

  moveSoccerCat(ai, targetX, targetY, AI_SPEED);

  // Dash kick: only when well-positioned behind ball (approach dist small)
  // and lined up toward goal
  if (bdist < 36 && approachDist < 28 && ai.dashCooldown === 0) {
    // Kick direction: from AI toward goal (not from AI toward ball centre)
    const kdx = GOAL_GX - ai.x;
    const kdy = GOAL_GY - ai.y;
    const klen = Math.hypot(kdx, kdy) || 1;
    ai.dashDx = kdx / klen;
    ai.dashDy = kdy / klen;
    ai.dashFrames = 10;
    ai.dashCooldown = 90;
    ai.justDashed = true;
  }
  applyDash(ai);

  // Clamp to full field
  ai.x = Math.max(SF.FX + ai.r, Math.min(SF.FX + SF.FW - ai.r, ai.x));
  ai.y = Math.max(SF.FY + ai.r, Math.min(SF.FY + SF.FH - ai.r, ai.y));
}


function moveSoccerCat(cat, targetX, targetY, speed) {
  const dx = targetX-cat.x, dy = targetY-cat.y;
  const dist = Math.hypot(dx,dy);
  if (dist > 5) {
    const nx=dx/dist, ny=dy/dist;
    cat.vx=nx*speed; cat.vy=ny*speed;
    cat.x+=cat.vx; cat.y+=cat.vy;
    cat.facingAngle=Math.atan2(ny,nx)+Math.PI/2;
    cat.moving=true;
  } else {
    cat.moving=false;
  }
}

function applyDash(cat) {
  if (cat.dashFrames > 0) {
    cat.dashFrames--;
    cat.x += cat.dashDx*7; cat.y += cat.dashDy*7;
  }
  if (cat.dashCooldown > 0) cat.dashCooldown--;
}

function soccerGoal(scorer) {
  const ss = soccerState;
  ss.ball.vx = ss.ball.vy = 0;

  if (scorer === 'player') {
    ss.playerScore++;
    ss.celebrationMsg = `âš½ GOAL! ${ss.playerScore}â€“${ss.aiScore}`;
    ss.celebrationColor = '#4caf50';
    spawnSoccerParticles(ss.ball.x, ss.ball.y, ['âš½','ğŸ‰','âœ¨','ğŸ’š','â­']);
    playSoccerGoal();
  } else {
    ss.aiScore++;
    ss.celebrationMsg = `ğŸ˜¿ They scored! ${ss.playerScore}â€“${ss.aiScore}`;
    ss.celebrationColor = '#ef5350';
    spawnSoccerParticles(ss.ball.x, ss.ball.y, ['ğŸ˜¹','âš½','ğŸ’¨']);
    playSoccerGoal(false);
  }
  ss.lastScorer = scorer;
  ss.celebration = 120;

  // Check win condition
  if (ss.playerScore >= SF.GOALS_TO_WIN) { ss.winner = 'player'; ss.celebration = 160; }
  else if (ss.aiScore >= SF.GOALS_TO_WIN) { ss.winner = 'ai';     ss.celebration = 160; }
}

function endSoccer() {
  const ss = soccerState;
  ss.running = false;
  stopMusic();
  if (ss.winner === 'player') {
    // Use level complete screen
    document.getElementById('lc-emoji').textContent = 'ğŸ†';
    document.getElementById('lc-title').textContent = 'You Win! ğŸ±âš½';
    document.getElementById('lc-desc').textContent = `${catName} beat Mikan ${ss.playerScore}â€“${ss.aiScore}! Purrfect!`;
    document.getElementById('lc-next-btn').style.display = 'none';
    setHudMode('hidden');
    document.getElementById('game-canvas-wrap').style.display='none';
    showScreen('levelcomplete-screen');
    spawnSoccerParticles(SF.FX+SF.FW/2, SF.FY+SF.FH/2, ['ğŸ†','âš½','ğŸ‰','âœ¨','ğŸŒŸ','ğŸ’›']);
  } else {
    document.getElementById('go-name').textContent = `Final score: ${ss.playerScore}â€“${ss.aiScore} ğŸ˜¿`;
    setHudMode('hidden');
    document.getElementById('game-canvas-wrap').style.display='none';
    showScreen('gameover-screen');
  }
}

// â”€â”€ Soccer sounds â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function playSoccerKick() {
  try {
    const ac = getAudio(), t = ac.currentTime;
    const o = ac.createOscillator(), g = ac.createGain();
    o.type='square'; o.frequency.setValueAtTime(180,t); o.frequency.exponentialRampToValueAtTime(90,t+0.07);
    g.gain.setValueAtTime(0.12,t); g.gain.exponentialRampToValueAtTime(0.001,t+0.09);
    o.connect(g); g.connect(ac.destination); o.start(t); o.stop(t+0.1);
  } catch(e){}
}
function playSoccerBounce() {
  try {
    const ac = getAudio(), t = ac.currentTime;
    const o = ac.createOscillator(), g = ac.createGain();
    o.type='sine'; o.frequency.setValueAtTime(300,t); o.frequency.exponentialRampToValueAtTime(180,t+0.06);
    g.gain.setValueAtTime(0.08,t); g.gain.exponentialRampToValueAtTime(0.001,t+0.07);
    o.connect(g); g.connect(ac.destination); o.start(t); o.stop(t+0.08);
  } catch(e){}
}
function playSoccerGoal(isPlayer=true) {
  try {
    const ac = getAudio(), t = ac.currentTime;
    const notes = isPlayer ? [523,659,784,1047] : [392,330,262];
    notes.forEach((freq,i) => {
      const o = ac.createOscillator(), g = ac.createGain();
      o.type='triangle'; o.frequency.value=freq;
      g.gain.setValueAtTime(0,t+i*0.12); g.gain.linearRampToValueAtTime(0.18,t+i*0.12+0.04);
      g.gain.exponentialRampToValueAtTime(0.001,t+i*0.12+0.4);
      o.connect(g); g.connect(ac.destination); o.start(t+i*0.12); o.stop(t+i*0.12+0.45);
    });
  } catch(e){}
}

// â”€â”€ Soccer particles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnSoccerParticles(x, y, emojis) {
  if (!soccerState) return;
  for (let i=0; i<12; i++) {
    const a = Math.random()*Math.PI*2;
    const spd = 2+Math.random()*5;
    soccerState.particles.push({
      x, y, vx:Math.cos(a)*spd, vy:Math.sin(a)*spd,
      emoji: emojis[Math.floor(Math.random()*emojis.length)],
      life:1, size:16+Math.random()*10,
    });
  }
}
function updateSoccerParticles() {
  if (!soccerState) return;
  soccerState.particles = soccerState.particles.filter(p=>p.life>0);
  for (const p of soccerState.particles) {
    p.x+=p.vx; p.y+=p.vy; p.vy+=0.12; p.life-=0.022;
  }
}

// â”€â”€ Soccer render â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderSoccer() {
  if (!soccerState) return;
  const ss = soccerState;
  const t = ss.time;
  ctx.clearRect(0,0,CW,CH);

  // â”€â”€ Pitch â”€â”€
  // Grass background
  ctx.fillStyle='#388e3c';
  ctx.fillRect(0,0,CW,CH);

  // Grass stripes
  for (let s=0; s<6; s++) {
    ctx.fillStyle = s%2===0 ? 'rgba(0,0,0,0.04)' : 'rgba(255,255,255,0.04)';
    ctx.fillRect(SF.FX, SF.FY + s*(SF.FH/6), SF.FW, SF.FH/6);
  }

  // Field border
  ctx.strokeStyle='rgba(255,255,255,0.9)'; ctx.lineWidth=3;
  ctx.strokeRect(SF.FX, SF.FY, SF.FW, SF.FH);

  // Centre line
  ctx.beginPath(); ctx.moveTo(SF.FX, SF.FY+SF.FH/2); ctx.lineTo(SF.FX+SF.FW, SF.FY+SF.FH/2); ctx.stroke();

  // Centre circle
  ctx.beginPath(); ctx.arc(SF.FX+SF.FW/2, SF.FY+SF.FH/2, 46, 0, Math.PI*2); ctx.stroke();
  ctx.fillStyle='rgba(255,255,255,0.08)'; ctx.fill();

  // Centre dot
  ctx.fillStyle='rgba(255,255,255,0.8)';
  ctx.beginPath(); ctx.arc(SF.FX+SF.FW/2, SF.FY+SF.FH/2, 4, 0, Math.PI*2); ctx.fill();

  // Penalty arcs (top and bottom)
  ctx.strokeStyle='rgba(255,255,255,0.6)'; ctx.lineWidth=2;
  ctx.fillStyle='rgba(255,255,255,0.04)';
  // Top penalty box
  ctx.beginPath(); ctx.rect(SF.FX+SF.FW*0.25, SF.FY, SF.FW*0.5, SF.FH*0.16); ctx.fill(); ctx.stroke();
  // Bottom penalty box
  ctx.beginPath(); ctx.rect(SF.FX+SF.FW*0.25, SF.FY+SF.FH*0.84, SF.FW*0.5, SF.FH*0.16); ctx.fill(); ctx.stroke();

  // â”€â”€ Goals â”€â”€
  // Top goal (AI scores here â†’ bad, player attacks here)
  drawSoccerGoal(SF.GX, SF.TOP_GY, SF.GW, SF.GD, '#ef5350', true);
  // Bottom goal (AI scores in player's goal)
  drawSoccerGoal(SF.GX, SF.BOTTOM_GY, SF.GW, SF.GD, '#4caf50', false);

  // Goal labels
  ctx.font='bold 11px Nunito,sans-serif'; ctx.textAlign='center';
  ctx.fillStyle='rgba(255,255,255,0.7)';
  ctx.fillText('ğŸ¯ Attack!', SF.FX+SF.FW/2, SF.FY-SF.GD-8);
  ctx.fillStyle='rgba(255,255,255,0.5)';
  ctx.fillText('ğŸ›¡ï¸ Defend!', SF.FX+SF.FW/2, SF.BOTTOM_GY+SF.GD+18);

  // â”€â”€ Opponent cat â”€â”€
  for (const ai of ss.aiCats) {
    drawCatTopDown(ctx, ai.x, ai.y, ai.cfg, t, ai.facingAngle, ai.moving, 0);
    drawSoccerNameTag(ai.x, ai.y, ai.name, '#ef9a9a');
  }



  // â”€â”€ Player cat â”€â”€
  const p = ss.player;
  // Rainbow glow during dash
  if (p.dashFrames > 0) {
    for (let i=0;i<3;i++) {
      const hue = (t*4+i*120)%360;
      ctx.save(); ctx.globalAlpha=0.35; ctx.strokeStyle=`hsl(${hue},100%,60%)`;
      ctx.lineWidth=3; ctx.beginPath(); ctx.arc(p.x,p.y,20+i*5,0,Math.PI*2); ctx.stroke(); ctx.restore();
    }
  }
  drawCatTopDown(ctx, p.x, p.y, p.cfg, t, p.facingAngle, p.moving, 0);

  // â”€â”€ Ball â”€â”€
  const b = ss.ball;
  const ballSpd = Math.hypot(b.vx,b.vy);
  // Shadow
  ctx.fillStyle='rgba(0,0,0,0.2)';
  ctx.beginPath(); ctx.ellipse(b.x+3, b.y+4, b.r*0.85, b.r*0.5, 0, 0, Math.PI*2); ctx.fill();
  // Ball glow when moving fast
  if (ballSpd > 5) {
    ctx.save(); ctx.globalAlpha=0.3;
    ctx.fillStyle='rgba(255,255,100,0.5)';
    ctx.beginPath(); ctx.arc(b.x, b.y, b.r+5, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }
  // Ball spin indicator
  const spinAngle = (b.x + b.y) * 0.06;
  ctx.save(); ctx.translate(b.x, b.y); ctx.rotate(spinAngle);
  // White ball base
  ctx.fillStyle='white'; ctx.shadowColor='rgba(0,0,0,0.3)'; ctx.shadowBlur=4;
  ctx.beginPath(); ctx.arc(0,0,b.r,0,Math.PI*2); ctx.fill();
  ctx.shadowBlur=0;
  // Classic soccer pattern (pentagons approximated)
  ctx.fillStyle='#222';
  const pts=[[0,-7],[6,5],[-6,5]]; // simple 3-point star pattern
  ctx.beginPath();
  for(const [px2,py2] of pts){
    ctx.moveTo(px2,py2); ctx.arc(px2,py2,2.8,0,Math.PI*2);
  }
  ctx.fill();
  ctx.restore();

  // â”€â”€ Particles â”€â”€
  for (const p2 of ss.particles) {
    ctx.save(); ctx.globalAlpha=p2.life;
    ctx.font=p2.size+'px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(p2.emoji, p2.x, p2.y); ctx.restore();
  }

  // â”€â”€ Scoreboard â”€â”€
  drawSoccerHUD(ss, t);

  // â”€â”€ Celebration overlay â”€â”€
  if (ss.celebration > 0 && !ss.winner) {
    const alpha = Math.min(1, ss.celebration/30) * Math.min(1, ss.celebration/30);
    ctx.save(); ctx.globalAlpha=alpha*0.85;
    ctx.fillStyle='rgba(0,0,0,0.45)'; ctx.fillRect(0,0,CW,CH);
    ctx.globalAlpha=alpha;
    ctx.font='bold 28px Nunito,sans-serif'; ctx.textAlign='center';
    ctx.fillStyle=ss.celebrationColor;
    ctx.shadowColor='rgba(0,0,0,0.6)'; ctx.shadowBlur=12;
    ctx.fillText(ss.celebrationMsg, CW/2, CH/2);
    ctx.restore();
  }

  // â”€â”€ Winner overlay â”€â”€
  if (ss.winner && ss.celebration > 0) {
    const alpha = Math.min(1, (160-ss.celebration)/30);
    ctx.save(); ctx.globalAlpha=alpha;
    ctx.fillStyle='rgba(0,0,0,0.55)'; ctx.fillRect(0,0,CW,CH);
    ctx.font='bold 34px Nunito,sans-serif'; ctx.textAlign='center';
    ctx.fillStyle = ss.winner==='player' ? '#ffd700' : '#ef9a9a';
    ctx.shadowColor='rgba(0,0,0,0.7)'; ctx.shadowBlur=16;
    ctx.fillText(ss.winner==='player' ? 'ğŸ† You Win!' : 'ğŸ˜¿ They Win!', CW/2, CH/2-20);
    ctx.font='18px Nunito,sans-serif';
    ctx.fillStyle='white'; ctx.shadowBlur=8;
    ctx.fillText(`${ss.playerScore} â€“ ${ss.aiScore}`, CW/2, CH/2+24);
    ctx.restore();
  }

  // â”€â”€ Kickoff overlay â”€â”€
  if (!ss.running && !ss.winner) {
    const isFirst = ss.playerScore === 0 && ss.aiScore === 0;
    // Dim
    ctx.fillStyle = 'rgba(0,0,0,0.52)';
    ctx.fillRect(0, 0, CW, CH);
    // Card
    const cw = 240, ch = isFirst ? 170 : 130;
    const cx2 = (CW-cw)/2, cy2 = (CH-ch)/2 - 20;
    ctx.fillStyle = '#fff9f0';
    ctx.beginPath(); ctx.roundRect(cx2, cy2, cw, ch, 14); ctx.fill();
    ctx.strokeStyle = '#d4a574'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.roundRect(cx2, cy2, cw, ch, 14); ctx.stroke();
    // Emoji + title
    ctx.textAlign = 'center';
    if (isFirst) {
      ctx.font = '32px serif'; ctx.fillText('âš½', CW/2, cy2+44);
      ctx.font = 'bold 16px Nunito,sans-serif'; ctx.fillStyle = '#5d3a1a';
      ctx.fillText('Cat Soccer!', CW/2, cy2+70);
      ctx.font = '10px Nunito,sans-serif'; ctx.fillStyle = '#a08060';
      ctx.fillText('Dash toward the ball to kick hard', CW/2, cy2+90);
      ctx.fillText(`Score ${SF.GOALS_TO_WIN} goals to win`, CW/2, cy2+106);
    } else {
      const lastMsg = ss.lastScorer === 'player'
        ? `âš½ You scored! ${ss.playerScore}â€“${ss.aiScore}`
        : `ğŸ˜¿ Mikan scored! ${ss.playerScore}â€“${ss.aiScore}`;
      ctx.font = 'bold 14px Nunito,sans-serif'; ctx.fillStyle = '#5d3a1a';
      ctx.fillText(lastMsg, CW/2, cy2+44);
      ctx.font = '10px Nunito,sans-serif'; ctx.fillStyle = '#a08060';
      ctx.fillText('Positions reset â€” ready?', CW/2, cy2+64);
    }
    // Kickoff button
    const btnW = 140, btnH = 36;
    const btnX = (CW-btnW)/2, btnY = cy2+ch-52;
    const pulse = 0.85 + Math.sin(ss.time*0.12)*0.15;
    ctx.save(); ctx.translate(CW/2, btnY+btnH/2); ctx.scale(pulse,pulse); ctx.translate(-CW/2, -(btnY+btnH/2));
    ctx.fillStyle = '#66bb6a';
    ctx.beginPath(); ctx.roundRect(btnX, btnY, btnW, btnH, 10); ctx.fill();
    ctx.strokeStyle = '#43a047'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.roundRect(btnX, btnY, btnW, btnH, 10); ctx.stroke();
    ctx.font = 'bold 14px Nunito,sans-serif'; ctx.fillStyle = 'white';
    ctx.fillText(isFirst ? 'ğŸŸ¢ Kick Off!' : 'ğŸŸ¢ Play!', CW/2, btnY+24);
    ctx.restore();
    // Store button bounds for click detection
    renderSoccer._kickBtnY = btnY; renderSoccer._kickBtnH = btnH;
    renderSoccer._kickBtnX = btnX; renderSoccer._kickBtnW = btnW;
  }

  drawPhotoFlash();
  drawHelp(t);
}

function drawSoccerNameTag(x, y, name, color) {
  ctx.save();
  ctx.fillStyle=color+'cc';
  ctx.beginPath(); ctx.roundRect(x-16, y-30, 32, 13, 3); ctx.fill();
  ctx.font='bold 8px Nunito,sans-serif'; ctx.textAlign='center';
  ctx.fillStyle='white';
  ctx.fillText(name, x, y-20);
  ctx.restore();
}

function drawSoccerGoal(gx, gy, gw, gd, color, isTop) {
  // Goal frame
  ctx.strokeStyle=color; ctx.lineWidth=4;
  ctx.fillStyle=`${color}22`;
  if (isTop) {
    ctx.beginPath();
    ctx.moveTo(gx, gy+gd);
    ctx.lineTo(gx, gy);
    ctx.lineTo(gx+gw, gy);
    ctx.lineTo(gx+gw, gy+gd);
    ctx.closePath(); ctx.fill(); ctx.stroke();
  } else {
    ctx.beginPath();
    ctx.moveTo(gx, gy);
    ctx.lineTo(gx, gy+gd);
    ctx.lineTo(gx+gw, gy+gd);
    ctx.lineTo(gx+gw, gy);
    ctx.closePath(); ctx.fill(); ctx.stroke();
  }
  // Net lines
  ctx.strokeStyle=`${color}44`; ctx.lineWidth=1;
  for (let i=1; i<4; i++) {
    ctx.beginPath();
    ctx.moveTo(gx+gw/4*i, gy);
    ctx.lineTo(gx+gw/4*i, isTop ? gy+gd : gy+gd);
    ctx.stroke();
  }
  const netY1 = isTop ? gy : gy+gd/3;
  ctx.beginPath(); ctx.moveTo(gx, netY1); ctx.lineTo(gx+gw, netY1); ctx.stroke();
}

function drawSoccerHUD(ss, t) {
  // Top bar
  ctx.fillStyle='rgba(0,0,0,0.65)';
  ctx.beginPath(); ctx.roundRect(SF.FX+SF.FW/2-90, 8, 180, 44, 10); ctx.fill();

  ctx.textAlign='center';
  // Score
  ctx.font='bold 26px Nunito,sans-serif';
  ctx.fillStyle='white';
  ctx.fillText(`${ss.playerScore}`, SF.FX+SF.FW/2-30, 42);
  ctx.fillStyle='rgba(255,255,255,0.5)';
  ctx.font='18px Nunito,sans-serif';
  ctx.fillText('â€“', SF.FX+SF.FW/2, 42);
  ctx.font='bold 26px Nunito,sans-serif';
  ctx.fillStyle='white';
  ctx.fillText(`${ss.aiScore}`, SF.FX+SF.FW/2+30, 42);

  // "You" and "Cats" labels
  ctx.font='bold 8px Nunito,sans-serif';
  ctx.fillStyle='#a5d6a7';
  ctx.fillText(catName.toUpperCase(), SF.FX+SF.FW/2-32, 20);
  ctx.fillStyle='#ef9a9a';
  ctx.fillText('MIKAN', SF.FX+SF.FW/2+32, 20);

  // Goal target
  ctx.font='10px Nunito,sans-serif'; ctx.fillStyle='rgba(255,255,255,0.5)';
  ctx.fillText(`First to ${SF.GOALS_TO_WIN}`, SF.FX+SF.FW/2, 60);

  // Dash cooldown bar (bottom right)
  const p = ss.player;
  if (p.dashCooldown > 0) {
    const barW = 80, barH = 8;
    const bx = SF.FX+SF.FW-barW-8, by = SF.FY+SF.FH+10;
    ctx.fillStyle='rgba(0,0,0,0.4)';
    ctx.beginPath(); ctx.roundRect(bx,by,barW,barH,4); ctx.fill();
    const pct = 1 - p.dashCooldown/90;
    ctx.fillStyle='#80deea';
    ctx.beginPath(); ctx.roundRect(bx,by,barW*pct,barH,4); ctx.fill();
    ctx.font='8px Nunito,sans-serif'; ctx.fillStyle='white'; ctx.textAlign='right';
    ctx.fillText('âš¡ Dash', bx+barW, by-2);
  }
}

// â”€â”€ Soccer game loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let soccerRaf=null, zenRaf=null, fishRaf=null, yarnRaf=null, gardenRaf=null, topiaryRaf=null;
let zenState=null, fishState=null, yarnState=null, gardenState=null, topiaryState=null;
function kickOff() {
  if (!soccerState) return;
  soccerState.running = true;
  soccerState.kickedOff = true;
  // Give ball a gentle random nudge to start
  const angle = Math.PI/2 + (Math.random()-0.5)*0.8;
  const side = Math.random() > 0.5 ? 1 : -1;
  soccerState.ball.vx = Math.cos(angle)*side*2;
  soccerState.ball.vy = Math.sin(angle)*2.5;
}

function soccerLoop() {
  soccerRaf = requestAnimationFrame(soccerLoop);
  updateSoccer();
  renderSoccer();
}

// (soccer dash handled inside triggerDash below)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// END CAT SOCCER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸª¨ ZEN GARDEN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const ZEN = { DECAY:0.0022 }; // ~400 frames = ~7s full fade at 60fps

function beginZenGarden() {
  stopAllGames();
  setHudMode('minigame');
  document.getElementById('game-canvas-wrap').style.display='block';
  document.querySelectorAll('.screen').forEach(s=>s.classList.add('hidden'));
  const rng = ()=>Math.random();
  // Random rocks
  const rocks=[];
  for(let i=0;i<5;i++) rocks.push({
    x:60+rng()*(CW-120), y:80+rng()*(CH-160),
    rx:14+rng()*18, ry:10+rng()*14, angle:rng()*Math.PI,
    shade: Math.floor(rng()*3), // 0=grey,1=dark,2=mossy
  });
  // Leaves scattered
  const leaves=[];
  for(let i=0;i<8;i++) leaves.push({x:rng()*CW,y:rng()*CH,angle:rng()*Math.PI*2,size:7+rng()*5});
  zenState = {
    running:true, time:0,
    strokes:[],   // {pts:[{x,y}], tool, alpha}
    currentStroke:null,
    rocks, leaves,
    rakeSize:1,
    rakeTools:[{name:'Fine',lines:3,gap:5},{name:'Medium',lines:5,gap:7},{name:'Wide',lines:7,gap:9}],
    lastPt:null, isDrawing:false,
    particles:[],
  };
  if(musicEnabled) startMusic();
  zenLoop();
}

function updateZen() {
  const z=zenState; if(!z||!z.running) return;
  z.time++;
  // Per-point alpha decay â€” start fades first, end stays bright
  for(const s of z.strokes) {
    const n = s.pts.length;
    for(let i=0; i<n; i++){
      // Points near start decay faster, near end decay slower
      const ageFactor = 1 - (i / Math.max(n-1, 1)) * 0.6; // 1.0 at start â†’ 0.4 at end
      s.pts[i].a = Math.max(0, s.pts[i].a - ZEN.DECAY * ageFactor);
    }
  }
  // Remove strokes where all points are invisible
  z.strokes = z.strokes.filter(s => s.pts.some(p => p.a > 0.008));
  // Particles
  z.particles=z.particles.filter(p=>p.life>0);
  z.particles.forEach(p=>{p.x+=p.vx;p.y+=p.vy;p.life-=0.04;p.vy+=0.05;});
}

function drawZenRakeStroke(z, x, y) {
  if (!z.currentStroke) {
    z.currentStroke = { pts:[{x, y, a:0.88}], tool:z.rakeTools[z.rakeSize] };
    z.strokes.push(z.currentStroke);
  } else {
    const last = z.currentStroke.pts[z.currentStroke.pts.length-1];
    if (Math.hypot(x-last.x, y-last.y) > 2) {
      z.currentStroke.pts.push({x, y, a:0.88});
    }
  }
}

function renderZenStroke(stroke) {
  if (stroke.pts.length < 2) return;
  const tool = stroke.tool;
  const pts = stroke.pts;
  ctx.save();
  ctx.lineCap='round'; ctx.lineJoin='round'; ctx.lineWidth=1.8;

  for (let li=0; li<tool.lines; li++) {
    const off=(li-(tool.lines-1)/2)*tool.gap;
    // Draw segment by segment so each can have its own alpha
    for (let i=1; i<pts.length; i++) {
      const a = (pts[i-1].a + pts[i].a) * 0.5; // avg alpha of the two endpoints
      if (a < 0.008) continue;
      const p0=pts[i-1], p1=pts[i];
      // Perpendicular offset for p0
      const nx0 = getPerp(pts, i-1);
      const nx1 = getPerp(pts, i);
      ctx.globalAlpha = a;
      ctx.strokeStyle = 'rgba(110,82,48,0.95)';
      ctx.beginPath();
      ctx.moveTo(p0.x + nx0.x*off, p0.y + nx0.y*off);
      ctx.lineTo(p1.x + nx1.x*off, p1.y + nx1.y*off);
      ctx.stroke();
    }
  }
  ctx.restore();
}

function getPerp(pts, i) {
  const prev=pts[Math.max(0,i-1)], next=pts[Math.min(pts.length-1,i+1)];
  const dx=next.x-prev.x, dy=next.y-prev.y, len=Math.hypot(dx,dy)||1;
  return {x: dy/len, y: -dx/len};
}

function renderZen() {
  const z=zenState; if(!z) return;
  const t=z.time;
  ctx.clearRect(0,0,CW,CH);
  // Sand base â€” drawn every frame
  const sandG=ctx.createLinearGradient(0,0,CW,CH);
  sandG.addColorStop(0,'#ede0c8'); sandG.addColorStop(0.5,'#e8d8b8'); sandG.addColorStop(1,'#ddd0b0');
  ctx.fillStyle=sandG; ctx.fillRect(0,0,CW,CH);
  // Fine sand texture
  ctx.save(); ctx.globalAlpha=0.045;
  for(let i=0;i<120;i++){
    ctx.fillStyle=i%3===0?'#c8a87a':'#b89060';
    const sx=(Math.sin(i*73.1)*0.5+0.5)*CW, sy=(Math.cos(i*47.3)*0.5+0.5)*CH;
    ctx.fillRect(sx,sy,i%2+1,1);
  }
  ctx.restore();
  // All strokes
  for(const s of z.strokes) renderZenStroke(s);
  // Rocks
  for(const r of z.rocks) {
    const colors=['#9e9e9e','#616161','#558b2f'];
    ctx.save(); ctx.translate(r.x,r.y); ctx.rotate(r.angle);
    const rg=ctx.createRadialGradient(-r.rx*0.3,-r.ry*0.3,1,0,0,Math.max(r.rx,r.ry));
    rg.addColorStop(0,'#bdbdbd'); rg.addColorStop(0.6,colors[r.shade]); rg.addColorStop(1,'#37474f');
    ctx.fillStyle=rg;
    ctx.shadowColor='rgba(0,0,0,0.35)'; ctx.shadowBlur=8; ctx.shadowOffsetY=4;
    ctx.beginPath(); ctx.ellipse(0,0,r.rx,r.ry,0,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
  // Leaves
  for(const l of z.leaves) {
    ctx.save(); ctx.translate(l.x,l.y); ctx.rotate(l.angle+t*0.002);
    ctx.font=l.size*1.8+'px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.globalAlpha=0.8; ctx.fillText('ğŸ‚',0,0); ctx.restore();
  }
  // Cat paw cursor hint (keep away from top HUD area)
  if(z.lastPt && t-z.lastDrawTime<60 && z.lastPt.y>80) {
    ctx.save(); ctx.globalAlpha=0.4+(Math.sin(t*0.2)*0.2);
    ctx.font='18px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText('ğŸ¾',z.lastPt.x,z.lastPt.y-22); ctx.restore();
  }
  // Particles
  for(const p of z.particles){
    ctx.save(); ctx.globalAlpha=p.life*0.7;
    ctx.fillStyle='#a08060'; ctx.beginPath(); ctx.arc(p.x,p.y,2,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
  // Tool selector HUD
  drawZenHUD(z,t);
  drawHelp(t);
}

function drawZenHUD(z,t) {
  // Tool pills at bottom
  const tools=z.rakeTools; const sel=z.rakeSize;
  const totalW=tools.length*90+16; const startX=(CW-totalW)/2;
  const by=CH-50;
  ctx.fillStyle='rgba(0,0,0,0.35)';
  ctx.beginPath(); ctx.roundRect(startX,by-4,totalW,48,10); ctx.fill();
  tools.forEach((tool,i)=>{
    const tx=startX+8+i*90, tw=82, th=40;
    ctx.fillStyle=i===sel?'rgba(255,220,160,0.9)':'rgba(255,255,255,0.15)';
    ctx.beginPath(); ctx.roundRect(tx,by,tw,th,8); ctx.fill();
    if(i===sel){ctx.strokeStyle='#d4a574';ctx.lineWidth=1.5;ctx.beginPath();ctx.roundRect(tx,by,tw,th,8);ctx.stroke();}
    ctx.font='bold 11px Nunito,sans-serif'; ctx.textAlign='center';
    ctx.fillStyle=i===sel?'#5d3a1a':'rgba(255,255,255,0.7)';
    ctx.fillText(tool.name,tx+tw/2,by+24);
  });
}

// Input handling for zen garden
let zenPointer=null;
function zenHandleStart(x,y){
  const z=zenState; if(!z||!z.running) return;
  const tools=z.rakeTools; const totalW=tools.length*90+16;
  const startX=(CW-totalW)/2; const by=CH-50;
  for(let i=0;i<tools.length;i++){
    const tx=startX+8+i*90;
    if(x>=tx&&x<=tx+82&&y>=by&&y<=by+40){z.rakeSize=i;return;}
  }
  z.isDrawing=true; z.lastPt={x,y}; z.lastDrawTime=z.time;
  z.currentStroke=null; // will be created on first move
  drawZenRakeStroke(z,x,y); // seed the stroke at start point
}
function zenHandleMove(x,y){
  const z=zenState; if(!z||!z.running||!z.isDrawing) return;
  drawZenRakeStroke(z,x,y);
  if(Math.random()<0.25) z.particles.push({x,y,vx:(Math.random()-0.5)*1.5,vy:-Math.random()*1.5,life:1});
  z.lastPt={x,y}; z.lastDrawTime=z.time;
}
function zenHandleEnd(){const z=zenState;if(z){z.isDrawing=false;z.lastPt=null;z.currentStroke=null;}}

function zenLoop(){
  zenRaf=requestAnimationFrame(zenLoop);
  updateZen(); renderZen();
}
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// END ZEN GARDEN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ£ FISHING HOLE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function beginFishing() {
  stopAllGames();
  setHudMode('minigame');
  document.getElementById('game-canvas-wrap').style.display='block';
  document.querySelectorAll('.screen').forEach(s=>s.classList.add('hidden'));
  const rng=()=>Math.random();
  fishState={
    running:true, time:0,
    phase:'idle', // idle|casting|waiting|nibble|reel|catch|miss
    lineX:CW/2, lineY:0, bobX:0, bobY:0, bobAngle:0,
    nibbleTimer:0, nibbleIntensity:0,
    catchTimer:0, missTimer:0,
    catchList:[], recentCatch:null,
    reelClicks:0, reelNeeded:0,
    ripples:[], particles:[],
    fish:[
      {emoji:'ğŸŸ',name:'Little Fish',weight:'0.2kg',rarity:0.5},
      {emoji:'ğŸ ',name:'Tropical Fish',weight:'0.4kg',rarity:0.3},
      {emoji:'ğŸ¡',name:'Pufferfish',weight:'0.6kg',rarity:0.15},
      {emoji:'ğŸ¦ˆ',name:'Tiny Shark',weight:'1.2kg',rarity:0.04},
      {emoji:'ğŸ™',name:'Octopus',weight:'0.8kg',rarity:0.01},
    ],
    // Lily pads
    lilypads:[
      {x:80+rng()*60,y:CH*0.45+rng()*30,r:18+rng()*10},
      {x:CW-80-rng()*60,y:CH*0.5+rng()*20,r:14+rng()*10},
      {x:CW*0.5+rng()*40-20,y:CH*0.6+rng()*20,r:16+rng()*8},
    ],
  };
  if(musicEnabled) startMusic();
  fishLoop();
}

function updateFishing() {
  const f=fishState; if(!f||!f.running) return;
  f.time++;
  const t=f.time;
  // Ripples
  f.ripples=f.ripples.filter(r=>r.life>0);
  f.ripples.forEach(r=>{r.r+=1.5;r.life-=0.03;});
  // Particles
  f.particles=f.particles.filter(p=>p.life>0);
  f.particles.forEach(p=>{p.x+=p.vx;p.y+=p.vy;p.life-=0.03;p.vy+=0.1;});

  if(f.phase==='waiting') {
    f.bobAngle+=0.08;
    // Bob moves gently
    f.bobY=f.lineY+Math.sin(f.bobAngle)*4;
    // Random nibble trigger
    if(Math.random()<0.003) { f.phase='nibble'; f.nibbleTimer=180+Math.random()*120; }
  }
  if(f.phase==='nibble') {
    f.nibbleIntensity=Math.min(1,f.nibbleIntensity+0.05);
    f.bobAngle+=0.25; f.bobY=f.lineY+Math.sin(f.bobAngle)*8*f.nibbleIntensity;
    f.nibbleTimer--;
    if(f.nibbleTimer<=0){ f.phase='miss'; f.missTimer=90; f.nibbleIntensity=0; f.reelClicks=0; f.reelNeeded=0; f.recentCatch=null; }
    // Play nibble sound
    if(f.nibbleTimer%15===0) playNibble();
  }
  if(f.phase==='miss'){ f.missTimer--; if(f.missTimer<=0) f.phase='waiting'; }
  if(f.phase==='catch'){
    f.catchTimer--; if(f.catchTimer<=0){ f.phase='idle'; f.recentCatch=null; }
  }
  // Lily pad sway
  f.lilypads.forEach((lp,i)=>{ lp.sway=Math.sin(t*0.02+i*1.3)*3; });
}

function renderFishing() {
  const f=fishState; if(!f) return;
  const t=f.time;
  ctx.clearRect(0,0,CW,CH);
  // Sky gradient
  const sky=ctx.createLinearGradient(0,0,0,CH*0.35);
  sky.addColorStop(0,'#b3e5fc'); sky.addColorStop(1,'#e1f5fe');
  ctx.fillStyle=sky; ctx.fillRect(0,0,CW,CH*0.35);
  // Distant trees
  for(let i=0;i<8;i++){
    const tx=i*(CW/7)-20; const th=50+Math.sin(i*1.7)*20;
    ctx.fillStyle=`hsl(${130+i*5},45%,${35+i*2}%)`;
    ctx.beginPath(); ctx.ellipse(tx+20,CH*0.35-th/2,18,th/2,0,0,Math.PI*2); ctx.fill();
  }
  // Pond
  const pondG=ctx.createLinearGradient(0,CH*0.35,0,CH);
  pondG.addColorStop(0,'#4fc3f7'); pondG.addColorStop(0.4,'#0288d1'); pondG.addColorStop(1,'#01579b');
  ctx.fillStyle=pondG; ctx.fillRect(0,CH*0.35,CW,CH);
  // Water shimmer
  ctx.save(); ctx.globalAlpha=0.06;
  for(let i=0;i<12;i++){
    const wy=CH*0.4+i*28+Math.sin(t*0.04+i*0.7)*6;
    ctx.fillStyle='white';
    ctx.fillRect(0,wy,CW,3);
  }
  ctx.restore();
  // Ripples
  ctx.save();
  f.ripples.forEach(r=>{
    ctx.globalAlpha=r.life*0.4; ctx.strokeStyle='white'; ctx.lineWidth=1.5;
    ctx.beginPath(); ctx.ellipse(r.x,r.y,r.r,r.r*0.4,0,0,Math.PI*2); ctx.stroke();
  });
  ctx.restore();
  // Lily pads
  f.lilypads.forEach(lp=>{
    ctx.save(); ctx.translate(lp.x,lp.y+lp.sway);
    ctx.fillStyle='#558b2f'; ctx.beginPath(); ctx.arc(0,0,lp.r,0.2,Math.PI*2-0.2); ctx.fill();
    if(Math.random()<0.01) ctx.fillText('ğŸŒ¸',0,0);
    ctx.restore();
  });
  // Cat on bank (left side)
  ctx.save(); ctx.translate(55,CH*0.35-10);
  // Simple paw holding rod
  drawCatTopDown(ctx,0,0,catCfg,t,Math.PI/2+0.2,false,0);
  ctx.restore();
  // Fishing rod + line
  if(f.phase!=='idle') {
    const rodTip={x:75,y:CH*0.35-28};
    ctx.strokeStyle='#795548'; ctx.lineWidth=3;
    ctx.beginPath(); ctx.moveTo(55,CH*0.35); ctx.lineTo(rodTip.x,rodTip.y); ctx.stroke();
    // Line
    ctx.strokeStyle='rgba(255,255,255,0.6)'; ctx.lineWidth=1;
    ctx.beginPath(); ctx.moveTo(rodTip.x,rodTip.y); ctx.lineTo(f.bobX,f.bobY); ctx.stroke();
    // Bob
    const bobOff= f.phase==='nibble' ? Math.sin(f.bobAngle)*6 : Math.sin(f.bobAngle)*3;
    ctx.fillStyle='#ef5350'; ctx.strokeStyle='white'; ctx.lineWidth=1.5;
    ctx.beginPath(); ctx.arc(f.bobX,f.bobY+bobOff,6,0,Math.PI*2); ctx.fill(); ctx.stroke();
    // Half white (classic float)
    ctx.fillStyle='white';
    ctx.beginPath(); ctx.arc(f.bobX,f.bobY+bobOff,6,Math.PI,Math.PI*2); ctx.fill();
  }
  // Particles
  f.particles.forEach(p=>{
    ctx.save(); ctx.globalAlpha=p.life;
    ctx.font='16px serif'; ctx.textAlign='center'; ctx.fillText(p.emoji,p.x,p.y); ctx.restore();
  });
  // Catch display
  if(f.phase==='catch' && f.recentCatch) {
    const prog=f.catchTimer/120;
    ctx.save(); ctx.globalAlpha=Math.min(1,prog*3);
    const cy=CH*0.3-Math.sin(prog*Math.PI)*40;
    ctx.font='40px serif'; ctx.textAlign='center'; ctx.fillText(f.recentCatch.emoji,CW/2,cy);
    ctx.font='bold 14px Nunito,sans-serif'; ctx.fillStyle='white';
    ctx.shadowColor='rgba(0,0,0,0.5)'; ctx.shadowBlur=6;
    ctx.fillText(f.recentCatch.name,CW/2,cy+32);
    ctx.font='11px Nunito,sans-serif'; ctx.fillStyle='#fff9c4';
    ctx.fillText(f.recentCatch.weight,CW/2,cy+48);
    ctx.restore();
  }
  // Recent catch list (top right)
  if(f.catchList.length>0){
    ctx.fillStyle='rgba(0,0,0,0.35)';
    ctx.beginPath(); ctx.roundRect(CW-90,8,82,Math.min(f.catchList.length,5)*24+12,8); ctx.fill();
    ctx.font='11px serif'; ctx.textAlign='left';
    f.catchList.slice(-5).forEach((fc,i)=>{
      ctx.fillText(fc.emoji+' '+fc.name,CW-82,32+i*24);
    });
  }
  // HUD
  drawFishHUD(f,t);
  drawHelp(t);
}

function drawFishHUD(f,t) {
  if(f.phase==='idle') {
    const bw=190,bh=52,bx=(CW-bw)/2,by=CH-74;
    const pulse=0.9+Math.sin(t*0.1)*0.1;
    ctx.save(); ctx.translate(CW/2,by+bh/2); ctx.scale(pulse,pulse); ctx.translate(-CW/2,-(by+bh/2));
    ctx.fillStyle='#0288d1'; ctx.beginPath(); ctx.roundRect(bx,by,bw,bh,12); ctx.fill();
    ctx.font='bold 16px Nunito,sans-serif'; ctx.fillStyle='white'; ctx.textAlign='center';
    ctx.fillText('ğŸ£ Cast Line!',CW/2,by+29); ctx.restore();
    fishState._castBtn={x:bx,y:by,w:bw,h:bh};
  } else if(f.phase==='nibble') {
    const bw=190,bh=52,bx=(CW-bw)/2,by=CH-74;
    const pulse=0.85+Math.sin(t*0.3)*0.15;
    ctx.save(); ctx.translate(CW/2,by+bh/2); ctx.scale(pulse,pulse); ctx.translate(-CW/2,-(by+bh/2));
    ctx.fillStyle='#f57f17'; ctx.beginPath(); ctx.roundRect(bx,by,bw,bh,12); ctx.fill();
    ctx.font='bold 16px Nunito,sans-serif'; ctx.fillStyle='white'; ctx.textAlign='center';
    ctx.fillText('ğŸ£ Reel In!',CW/2,by+28); ctx.restore();
    fishState._reelBtn={x:bx,y:by,w:bw,h:bh};
  } else if(f.phase==='reeling') {
    const bw=190,bh=52,bx=(CW-bw)/2,by=CH-74;
    // Reel button â€” pulses faster as you get closer
    const urgency=0.3+0.7*(f.reelClicks/f.reelNeeded);
    const pulse=0.88+Math.sin(f.time*(0.25+urgency*0.4))*0.12;
    ctx.save(); ctx.translate(CW/2,by+bh/2); ctx.scale(pulse,pulse); ctx.translate(-CW/2,-(by+bh/2));
    ctx.fillStyle='#2e7d32'; ctx.beginPath(); ctx.roundRect(bx,by,bw,bh,12); ctx.fill();
    ctx.font='bold 15px Nunito,sans-serif'; ctx.fillStyle='white'; ctx.textAlign='center';
    ctx.fillText(`ğŸ£ Reel! (${f.reelClicks}/${f.reelNeeded})`,CW/2,by+30); ctx.restore();
    fishState._reelBtn={x:bx,y:by,w:bw,h:bh};
    // Progress bar
    const pbw=140,pbh=8,pbx=(CW-pbw)/2,pby=by-16;
    ctx.fillStyle='rgba(0,0,0,0.3)'; ctx.beginPath(); ctx.roundRect(pbx,pby,pbw,pbh,4); ctx.fill();
    ctx.fillStyle='#66bb6a'; ctx.beginPath(); ctx.roundRect(pbx,pby,pbw*(f.reelClicks/f.reelNeeded),pbh,4); ctx.fill();
  } else if(f.phase==='waiting') {
    ctx.font='bold 12px Nunito,sans-serif'; ctx.fillStyle='rgba(255,255,255,0.6)';
    ctx.textAlign='center'; ctx.fillText('Waiting for a biteâ€¦ ğŸŸ',CW/2,CH-30);
  } else if(f.phase==='miss') {
    ctx.font='bold 16px Nunito,sans-serif'; ctx.fillStyle='rgba(255,255,255,0.8)';
    ctx.textAlign='center'; ctx.fillText('One got awayâ€¦ ğŸ˜¿',CW/2,CH-48);
  }
}

function fishHandleTap(x,y) {
  const f=fishState; if(!f||!f.running) return;
  if(f.phase==='idle' && f._castBtn && x>=f._castBtn.x&&x<=f._castBtn.x+f._castBtn.w&&y>=f._castBtn.y&&y<=f._castBtn.y+f._castBtn.h) {
    f.phase='waiting';
    f.bobX=CW*0.3+Math.random()*CW*0.4;
    f.bobY=CH*0.5+Math.random()*CH*0.15;
    f.lineY=f.bobY; f.bobAngle=0;
    f.ripples.push({x:f.bobX,y:f.bobY,r:4,life:1});
    playCast();
    return;
  }
  if((f.phase==='nibble'||f.phase==='reeling') && f._reelBtn &&
      x>=f._reelBtn.x&&x<=f._reelBtn.x+f._reelBtn.w&&y>=f._reelBtn.y&&y<=f._reelBtn.y+f._reelBtn.h) {
    reelIn(); return;
  }
}

function reelIn() {
  const f=fishState;
  if(f.phase!=='nibble' && f.phase!=='reeling') return;

  if(f.phase==='nibble') {
    // First click â€” pick fish, set reel count
    let r=Math.random(), cumul=0, caught=f.fish[0];
    for(const fish of f.fish){ cumul+=fish.rarity; if(r<cumul){caught=fish;break;} }
    f.recentCatch=caught;
    // Clicks needed scales with rarity (rarer = harder):
    // rarity 0.5 â†’ 2 clicks, 0.3 â†’ 3, 0.15 â†’ 5, 0.04 â†’ 8, 0.01 â†’ 12
    f.reelNeeded = Math.round(1 / caught.rarity * 0.6 + 1.5);
    f.reelClicks = 1;
    f.phase='reeling';
    f.ripples.push({x:f.bobX,y:f.bobY,r:6,life:1});
    playReel();
    return;
  }

  if(f.phase==='reeling') {
    f.reelClicks++;
    f.ripples.push({x:f.bobX,y:f.bobY,r:4+f.reelClicks*2,life:1});
    playReel();
    if(f.reelClicks >= f.reelNeeded) {
      // Done â€” land the fish
      const caught=f.recentCatch;
      f.catchList.push(caught);
      f.phase='catch'; f.catchTimer=150; f.reelClicks=0; f.reelNeeded=0;
      f.particles.push(...Array.from({length:10},(_,i)=>({
        emoji:caught.emoji,
        x:f.bobX,y:f.bobY,
        vx:Math.cos(i/10*Math.PI*2)*3.5,vy:-3.5-Math.random()*3,
        life:1,
      })));
      playCatch();
    }
  }
}

function playReel(){
  try{const ac=getAudio(),t=ac.currentTime;
    const o=ac.createOscillator(),g=ac.createGain();
    o.type='sawtooth';o.frequency.setValueAtTime(200,t);o.frequency.exponentialRampToValueAtTime(350,t+0.12);
    g.gain.setValueAtTime(0.09,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.15);
    o.connect(g);g.connect(ac.destination);o.start(t);o.stop(t+0.18);
  }catch(e){}
}
function playNibble(){
  try{const ac=getAudio(),t=ac.currentTime;
    const o=ac.createOscillator(),g=ac.createGain();
    o.type='sine';o.frequency.setValueAtTime(800,t);o.frequency.exponentialRampToValueAtTime(400,t+0.05);
    g.gain.setValueAtTime(0.06,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.06);
    o.connect(g);g.connect(ac.destination);o.start(t);o.stop(t+0.07);
  }catch(e){}
}
function playCast(){
  try{const ac=getAudio(),t=ac.currentTime;
    const o=ac.createOscillator(),g=ac.createGain();
    o.type='sine';o.frequency.setValueAtTime(600,t);o.frequency.exponentialRampToValueAtTime(200,t+0.3);
    g.gain.setValueAtTime(0.1,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.35);
    o.connect(g);g.connect(ac.destination);o.start(t);o.stop(t+0.4);
  }catch(e){}
}
function playCatch(){
  try{const ac=getAudio(),t=ac.currentTime;
    [523,659,784,1047].forEach((f,i)=>{
      const o=ac.createOscillator(),g=ac.createGain();
      o.type='triangle';o.frequency.value=f;
      g.gain.setValueAtTime(0,t+i*0.1);g.gain.linearRampToValueAtTime(0.15,t+i*0.1+0.05);
      g.gain.exponentialRampToValueAtTime(0.001,t+i*0.1+0.35);
      o.connect(g);g.connect(ac.destination);o.start(t+i*0.1);o.stop(t+i*0.1+0.4);
    });
  }catch(e){}
}

function fishLoop(){
  fishRaf=requestAnimationFrame(fishLoop);
  updateFishing(); renderFishing();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ§¶ YARN BAT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function beginYarnBat() {
  stopAllGames();
  setHudMode('minigame');
  document.getElementById('game-canvas-wrap').style.display='block';
  document.querySelectorAll('.screen').forEach(s=>s.classList.add('hidden'));
  // Place basket in a random-ish corner of the room (avoiding cat corner)
  const bSide = Math.random()>0.5 ? 'right' : 'top';
  const basket = {
    x: bSide==='right' ? CW-52 : 60+Math.random()*(CW-120),
    y: bSide==='right' ? CH-90-Math.random()*60 : 100+Math.random()*80,
    w:48, h:38, scored:0,
  };
  yarnState={
    running:true, time:0,
    yarn:{ x:CW/2,y:CH*0.4,vx:2,vy:-3,r:22,trail:[] },
    basket,
    celebrate:0,  // countdown for celebration
    tangles:[],
    particles:[],
    batCooldown:0,
  };
  if(musicEnabled) startMusic();
  yarnLoop();
}

function updateYarnBat() {
  const y=yarnState; if(!y||!y.running) return;
  y.time++;
  const b=y.yarn;
  const FRICTION=0.995;
  b.x+=b.vx; b.y+=b.vy;
  b.vx*=FRICTION; b.vy*=FRICTION;
  b.vy+=0.05; // gravity
  // Bounce walls
  if(b.x-b.r<0){b.x=b.r;b.vx=Math.abs(b.vx)*0.85;playYarnBounce();}
  if(b.x+b.r>CW){b.x=CW-b.r;b.vx=-Math.abs(b.vx)*0.85;playYarnBounce();}
  if(b.y-b.r<60){b.y=60+b.r;b.vy=Math.abs(b.vy)*0.8;playYarnBounce();}
  if(b.y+b.r>CH-60){b.y=CH-60-b.r;b.vy=-Math.abs(b.vy)*0.8;playYarnBounce();}
  // Trail
  b.trail.push({x:b.x,y:b.y,t:y.time});
  if(b.trail.length>180) b.trail.shift();
  // Particles
  y.particles=y.particles.filter(p=>p.life>0);
  y.particles.forEach(p=>{p.x+=p.vx;p.y+=p.vy;p.life-=0.025;p.vy+=0.15;});
  if(y.batCooldown>0) y.batCooldown--;

  // Celebrate countdown
  if(y.celebrate>0){
    y.celebrate--;
    if(y.celebrate===0){
      // Respawn yarn
      y.yarn.x=CW/2; y.yarn.y=CH*0.35;
      y.yarn.vx=(Math.random()-0.5)*6; y.yarn.vy=-4-Math.random()*3;
      y.yarn.trail=[];
    }
    return; // freeze physics during celebration
  }

  // Basket collision â€” check if ball centre is inside basket opening
  const bk=y.basket;
  const inBasketX = b.x > bk.x && b.x < bk.x+bk.w;
  const inBasketY = b.y+b.r > bk.y+4 && b.y < bk.y+bk.h-4;
  if(inBasketX && inBasketY && Math.hypot(b.vx,b.vy)>1.5){
    bk.scored++;
    y.celebrate=120;
    // Burst particles
    for(let i=0;i<18;i++) y.particles.push({
      x:bk.x+bk.w/2, y:bk.y,
      vx:(Math.random()-0.5)*9, vy:-4-Math.random()*6,
      emoji:['âœ¨','ğŸ‰','â­','ğŸ§¶','ğŸ’›'][Math.floor(Math.random()*5)],
      size:14+Math.random()*10, life:1,
    });
    playBasketScore();
    b.vx=0; b.vy=0; b.x=bk.x+bk.w/2; b.y=bk.y;
  }
}

function renderYarnBat() {
  const y=yarnState; if(!y) return;
  const t=y.time;
  ctx.clearRect(0,0,CW,CH);
  // Cosy room bg
  ctx.fillStyle='#efebe9'; ctx.fillRect(0,0,CW,CH);
  // Floor
  ctx.fillStyle='#d7ccc8'; ctx.fillRect(0,CH-60,CW,60);
  ctx.fillStyle='#bcaaa4'; ctx.fillRect(0,CH-62,CW,3);
  // Yarn trail (tangles)
  if(y.yarn.trail.length>1) {
    ctx.save(); ctx.lineCap='round'; ctx.lineJoin='round';
    for(let i=1;i<y.yarn.trail.length;i++){
      const age=(t-y.yarn.trail[i].t)/180;
      const alpha=Math.max(0,1-age)*0.7;
      const hue=i%2===0?0:10;
      ctx.strokeStyle=`hsla(${hue},80%,55%,${alpha})`;
      ctx.lineWidth=3;
      ctx.beginPath();
      ctx.moveTo(y.yarn.trail[i-1].x,y.yarn.trail[i-1].y);
      ctx.lineTo(y.yarn.trail[i].x,y.yarn.trail[i].y);
      ctx.stroke();
    }
    ctx.restore();
  }
  // Basket
  const bk=y.basket;
  // Shadow
  ctx.fillStyle='rgba(0,0,0,0.1)';
  ctx.beginPath(); ctx.ellipse(bk.x+bk.w/2,bk.y+bk.h+4,bk.w*0.55,6,0,0,Math.PI*2); ctx.fill();
  // Basket body
  const bkG=ctx.createLinearGradient(bk.x,bk.y,bk.x,bk.y+bk.h);
  bkG.addColorStop(0,'#d4a96a'); bkG.addColorStop(1,'#a0724a');
  ctx.fillStyle=bkG;
  ctx.beginPath(); ctx.roundRect(bk.x,bk.y+8,bk.w,bk.h-4,4); ctx.fill();
  // Weave lines
  ctx.strokeStyle='rgba(120,80,40,0.35)'; ctx.lineWidth=1.5;
  for(let i=0;i<4;i++){
    ctx.beginPath(); ctx.moveTo(bk.x,bk.y+8+i*7); ctx.lineTo(bk.x+bk.w,bk.y+8+i*7); ctx.stroke();
  }
  // Basket rim
  ctx.strokeStyle='#8d6e63'; ctx.lineWidth=3; ctx.fillStyle='#bcaaa4';
  ctx.beginPath();
  ctx.moveTo(bk.x-3,bk.y+10); ctx.lineTo(bk.x+2,bk.y+2);
  ctx.lineTo(bk.x+bk.w-2,bk.y+2); ctx.lineTo(bk.x+bk.w+3,bk.y+10);
  ctx.stroke();
  // Score counter on basket
  if(bk.scored>0){
    ctx.font='bold 11px Nunito,sans-serif'; ctx.fillStyle='#4a2e0a'; ctx.textAlign='center';
    ctx.fillText('Ã—'+bk.scored,bk.x+bk.w/2,bk.y-4);
  }
  // Highlight when ball is near
  const ballNear=Math.hypot(y.yarn.x-(bk.x+bk.w/2),y.yarn.y-(bk.y+bk.h/2))<80;
  if(ballNear){
    ctx.save(); ctx.globalAlpha=0.3+Math.sin(y.time*0.15)*0.2;
    ctx.strokeStyle='#ffd54f'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.roundRect(bk.x-4,bk.y-2,bk.w+8,bk.h+8,6); ctx.stroke();
    ctx.restore();
  }

  // Cat in corner watching
  ctx.save(); ctx.translate(30,CH-75);
  drawCatTopDown(ctx,0,0,catCfg,t,0,false,0);
  ctx.restore();
  // Yarn ball
  const b=y.yarn;
  const spd=Math.hypot(b.vx,b.vy);
  // Shadow
  ctx.fillStyle='rgba(0,0,0,0.12)'; ctx.beginPath(); ctx.ellipse(b.x+4,b.y+6,b.r*0.9,b.r*0.45,0,0,Math.PI*2); ctx.fill();
  // Ball
  const yg=ctx.createRadialGradient(b.x-b.r*0.3,b.y-b.r*0.3,2,b.x,b.y,b.r);
  yg.addColorStop(0,'#ff8a65'); yg.addColorStop(0.6,'#e64a19'); yg.addColorStop(1,'#bf360c');
  ctx.fillStyle=yg; ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill();
  // Wind lines for speed
  ctx.save(); ctx.strokeStyle='rgba(255,140,100,0.5)'; ctx.lineWidth=2;
  for(let i=0;i<3;i++){
    const len=spd*(2+i*1.5);
    ctx.beginPath();
    ctx.moveTo(b.x,b.y);
    ctx.lineTo(b.x-b.vx/spd*len*(0.5+i*0.25),b.y-b.vy/spd*len*(0.5+i*0.25));
    ctx.stroke();
  }
  ctx.restore();
  // Particles
  y.particles.forEach(p=>{
    ctx.save(); ctx.globalAlpha=p.life;
    if(p.emoji){
      ctx.font=(p.size||14)+'px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(p.emoji,p.x,p.y);
    } else {
      ctx.fillStyle=`hsl(${10+Math.random()*20},80%,55%)`;
      ctx.beginPath(); ctx.arc(p.x,p.y,3,0,Math.PI*2); ctx.fill();
    }
    ctx.restore();
  });
  // Celebration overlay
  if(y.celebrate>0){
    const prog=y.celebrate/120;
    const alpha=prog<0.25 ? prog/0.25 : prog>0.75 ? (prog-0.75)/0.25 : 1;
    ctx.save(); ctx.globalAlpha=alpha*0.75;
    ctx.fillStyle='rgba(0,0,0,0.4)'; ctx.fillRect(0,0,CW,CH);
    ctx.globalAlpha=alpha;
    const scale=1+Math.sin((1-prog)*Math.PI)*0.3;
    ctx.translate(CW/2,CH/2); ctx.scale(scale,scale); ctx.translate(-CW/2,-CH/2);
    ctx.font='52px serif'; ctx.textAlign='center';
    ctx.fillText('ğŸ‰',CW/2,CH/2-30);
    ctx.font='bold 22px Nunito,sans-serif'; ctx.fillStyle='#ffd700';
    ctx.shadowColor='rgba(0,0,0,0.5)'; ctx.shadowBlur=8;
    ctx.fillText('Basket!',CW/2,CH/2+20);
    ctx.font='14px Nunito,sans-serif'; ctx.fillStyle='white'; ctx.shadowBlur=4;
    ctx.fillText(`${y.basket.scored} in a row!`,CW/2,CH/2+46);
    ctx.restore();
  } else {
    // Tap hint only when not celebrating
    ctx.font='bold 11px Nunito,sans-serif'; ctx.fillStyle='rgba(100,70,60,0.6)';
    ctx.textAlign='center'; ctx.fillText('Tap to bat Â· aim for the basket! ğŸ§¶',CW/2,46);
  }
  drawHelp(t);
}

function yarnHandleTap(x,y) {
  const ys=yarnState; if(!ys||!ys.running) return;
  if(ys.batCooldown>0) return;
  const b=ys.yarn;
  const dx=b.x-x, dy=b.y-y, dist=Math.hypot(dx,dy)||1;
  const power=10+Math.random()*5;
  b.vx=dx/dist*power; b.vy=dy/dist*power;
  ys.batCooldown=8;
  for(let i=0;i<6;i++) ys.particles.push({x:b.x,y:b.y,vx:(Math.random()-0.5)*6,vy:-Math.random()*5,life:1});
  playYarnBat_sound();
}

function playBasketScore(){
  try{const ac=getAudio(),t=ac.currentTime;
    [523,784,1047,1319].forEach((f,i)=>{
      const o=ac.createOscillator(),g=ac.createGain();
      o.type='triangle';o.frequency.value=f;
      g.gain.setValueAtTime(0,t+i*0.07); g.gain.linearRampToValueAtTime(0.18,t+i*0.07+0.03);
      g.gain.exponentialRampToValueAtTime(0.001,t+i*0.07+0.35);
      o.connect(g);g.connect(ac.destination);o.start(t+i*0.07);o.stop(t+i*0.07+0.4);
    });
  }catch(e){}
}
function playYarnBounce(){
  try{const ac=getAudio(),t=ac.currentTime;
    const o=ac.createOscillator(),g=ac.createGain();
    o.type='sine';o.frequency.setValueAtTime(300+Math.random()*200,t);
    g.gain.setValueAtTime(0.08,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.1);
    o.connect(g);g.connect(ac.destination);o.start(t);o.stop(t+0.12);
  }catch(e){}
}
function playYarnBat_sound(){
  try{const ac=getAudio(),t=ac.currentTime;
    const o=ac.createOscillator(),g=ac.createGain();
    o.type='triangle';o.frequency.setValueAtTime(500,t);o.frequency.exponentialRampToValueAtTime(200,t+0.08);
    g.gain.setValueAtTime(0.12,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.1);
    o.connect(g);g.connect(ac.destination);o.start(t);o.stop(t+0.12);
  }catch(e){}
}

function yarnLoop(){
  yarnRaf=requestAnimationFrame(yarnLoop);
  updateYarnBat(); renderYarnBat();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸŒ± GARDEN PATCH
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const FLOWER_TYPES=[
  // name, emoji, color, stage emojis, waterNeeded, fertNeeded (0=none)
  {name:'Daisy',       emoji:'ğŸŒ¼',color:'#fff9c4',stage:['ğŸŒ±','ğŸŒ¿','ğŸŒ¼'],waterNeeded:2,fertNeeded:0},
  {name:'Tulip',       emoji:'ğŸŒ·',color:'#e91e63',stage:['ğŸŒ±','ğŸŒ¿','ğŸŒ·'],waterNeeded:3,fertNeeded:1},
  {name:'Sunflower',   emoji:'ğŸŒ»',color:'#fdd835',stage:['ğŸŒ±','ğŸŒ¿','ğŸŒ»'],waterNeeded:3,fertNeeded:1},
  {name:'Cherry Blossom',emoji:'ğŸŒ¸',color:'#f48fb1',stage:['ğŸŒ±','ğŸŒ¿','ğŸŒ¸'],waterNeeded:4,fertNeeded:2},
  {name:'Rose',        emoji:'ğŸŒ¹',color:'#c62828',stage:['ğŸŒ±','ğŸŒ¿','ğŸŒ¹'],waterNeeded:5,fertNeeded:3},
];

function beginGarden() {
  stopAllGames();
  setHudMode('minigame');
  document.getElementById('game-canvas-wrap').style.display='block';
  document.querySelectorAll('.screen').forEach(s=>s.classList.add('hidden'));
  const COLS_G=5, ROWS_G=4;
  const cellW=CW/COLS_G, cellH=(CH*0.6)/ROWS_G;
  const plots=[];
  for(let r=0;r<ROWS_G;r++) for(let c=0;c<COLS_G;c++){
    plots.push({
      r,c,
      x:c*cellW+cellW/2, y:CH*0.32+r*cellH+cellH/2,
      state:'empty', // empty|seeded|growing|bloomed
      waterCount:0, fertCount:0,
      flowerType:null,
      wiggle:Math.random()*Math.PI*2,
    });
  }
  gardenState={
    running:true, time:0,
    plots,
    mode:'seed', // seed|water|fert|collect
    particles:[],
    totalBloomed:0,
    vase:[],           // collected flowers {emoji, color}
    showVase:false,    // toggle vase display
    watering:false, waterX:0, waterY:0,
  };
  if(musicEnabled) startMusic();
  gardenLoop();
}

function updateGarden() {
  const g=gardenState; if(!g||!g.running) return;
  g.time++;
  g.particles=g.particles.filter(p=>p.life>0);
  g.particles.forEach(p=>{p.x+=p.vx;p.y+=p.vy;p.life-=0.04;p.vy-=0.02;});
  g.plots.forEach(p=>{ p.wiggle+=0.02; });
}

function spawnGardenParticles(g,x,y,color){
  for(let i=0;i<8;i++) g.particles.push({
    x,y,vx:(Math.random()-0.5)*4,vy:-2-Math.random()*3,
    color, life:1,
  });
}

function renderGarden() {
  const g=gardenState; if(!g) return;
  const t=g.time;
  ctx.clearRect(0,0,CW,CH);
  // Sky
  ctx.fillStyle='#e8f5e9'; ctx.fillRect(0,0,CW,CH*0.32);
  // Sun
  ctx.fillStyle='rgba(255,220,50,0.3)';
  ctx.beginPath(); ctx.arc(CW-60,50,36,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='rgba(255,200,0,0.5)';
  ctx.beginPath(); ctx.arc(CW-60,50,24,0,Math.PI*2); ctx.fill();
  // Soil
  const soilG=ctx.createLinearGradient(0,CH*0.32,0,CH);
  soilG.addColorStop(0,'#8d6e63'); soilG.addColorStop(1,'#5d4037');
  ctx.fillStyle=soilG; ctx.fillRect(0,CH*0.32,CW,CH);
  // Grid rows
  ctx.strokeStyle='rgba(0,0,0,0.1)'; ctx.lineWidth=1;
  const COLS_G=5,ROWS_G=4,cellW=CW/COLS_G,cellH=(CH*0.6)/ROWS_G;
  for(let r=0;r<=ROWS_G;r++){
    ctx.beginPath(); ctx.moveTo(0,CH*0.32+r*cellH); ctx.lineTo(CW,CH*0.32+r*cellH); ctx.stroke();
  }
  for(let c=0;c<=COLS_G;c++){
    ctx.beginPath(); ctx.moveTo(c*cellW,CH*0.32); ctx.lineTo(c*cellW,CH); ctx.stroke();
  }
  // Plots â€” two passes: non-bloomed first (no shadow), bloomed second (with glow)
  // This guarantees shadowBlur from bloomed plants never bleeds onto non-bloomed ones.

  // Pass 1: empty highlights, non-bloomed emojis, resource dots
  ctx.shadowColor='transparent'; ctx.shadowBlur=0;
  g.plots.forEach(p=>{
    const ft=p.flowerType;
    if(p.state==='bloomed') return; // handled in pass 2

    if(p.state==='empty'){
      ctx.fillStyle='rgba(255,255,255,0.06)';
      ctx.fillRect(p.x-cellW/2+2,p.y-cellH/2+2,cellW-4,cellH-4);
    }

    const emoji = !ft ? null
      : p.state==='seeded' ? 'ğŸŒ°'
      : (p.waterCount>=ft.waterNeeded && (ft.fertNeeded===0||p.fertCount>=ft.fertNeeded)) ? ft.stage[1] : 'ğŸŒ±';

    if(emoji){
      ctx.save();
      ctx.font='18px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(emoji,p.x,p.y);
      ctx.restore();
    }

    // Resource progress dots
    if(ft && p.state!=='empty'){
      ctx.save();
      const barY=p.y+cellH*0.36;
      for(let w=0;w<ft.waterNeeded;w++){
        ctx.fillStyle=w<p.waterCount?'#42a5f5':'rgba(100,160,220,0.25)';
        ctx.beginPath(); ctx.arc(p.x-ft.waterNeeded*5+w*10+5,barY,3.5,0,Math.PI*2); ctx.fill();
      }
      if(ft.fertNeeded>0){
        ctx.font='9px serif'; ctx.textAlign='center';
        for(let f2=0;f2<ft.fertNeeded;f2++){
          ctx.fillStyle=f2<p.fertCount?'#ffb300':'rgba(200,160,0,0.25)';
          ctx.fillText('â˜…',p.x-ft.fertNeeded*7+f2*14+7,barY+12);
        }
      }
      ctx.restore();
    }
  });

  // Pass 2: bloomed flowers â€” drawn last so their glow shadow never contaminates other plots
  ctx.shadowColor='transparent'; ctx.shadowBlur=0; // explicit reset before bloomed pass
  g.plots.forEach(p=>{
    if(p.state!=='bloomed') return;
    const ft=p.flowerType; if(!ft) return;
    const bob=Math.sin(p.wiggle+t*0.04)*4;
    const sc=1+Math.sin(p.wiggle+t*0.04)*0.08;
    ctx.save();
    ctx.shadowColor=ft.color; ctx.shadowBlur=14;
    ctx.translate(p.x,p.y+bob); ctx.scale(sc,sc);
    ctx.font='28px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(ft.stage[2],0,0);
    ctx.restore();
    // Explicitly clear shadow after each bloomed plant restore (belt-and-suspenders)
    ctx.shadowColor='transparent'; ctx.shadowBlur=0;

    // Collect hint
    if(g.mode==='collect'){
      ctx.save(); ctx.globalAlpha=0.5+Math.sin(t*0.15)*0.3;
      ctx.strokeStyle='#ffd54f'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.roundRect(p.x-cellW/2+3,p.y-cellH/2+3,cellW-6,cellH-6,4); ctx.stroke();
      ctx.restore();
    }
  });
  // Final shadow reset so nothing after is affected
  ctx.shadowColor='transparent'; ctx.shadowBlur=0;
  // Vase display overlay
  if(g.showVase) renderVase(g,t);
  // Cat with tool
  ctx.save(); ctx.translate(30,CH*0.32-10);
  drawCatTopDown(ctx,0,0,catCfg,t,-Math.PI/4,false,0);
  // Tool emoji
  ctx.font='18px serif'; ctx.textAlign='center';
  ctx.fillText(g.mode==='seed'?'ğŸŒ°':g.mode==='water'?'ğŸ’§':g.mode==='fert'?'â­':'ğŸŒ¸',20,-20); ctx.restore();
  // Watering animation
  if(g.watering){
    for(let i=0;i<5;i++){
      const wx=g.waterX+(Math.random()-0.5)*30, wy=g.waterY-Math.random()*20;
      ctx.fillStyle='rgba(100,180,255,0.7)';
      ctx.beginPath(); ctx.arc(wx,wy,3,0,Math.PI*2); ctx.fill();
    }
  }
  // Particles
  g.particles.forEach(p=>{
    ctx.save(); ctx.globalAlpha=p.life;
    ctx.fillStyle=p.color; ctx.beginPath(); ctx.arc(p.x,p.y,4,0,Math.PI*2); ctx.fill(); ctx.restore();
  });
  // Score
  ctx.fillStyle='rgba(0,0,0,0.35)';
  ctx.beginPath(); ctx.roundRect(CW/2-60,8,120,34,8); ctx.fill();
  ctx.font='bold 12px Nunito,sans-serif'; ctx.fillStyle='white'; ctx.textAlign='center';
  ctx.fillText(`ğŸŒ¸ ${g.totalBloomed} bloomed  ğŸº ${g.vase.length}`,CW/2,30);
  drawGardenHUD(g,t);
  drawHelp(t);
}

function drawGardenHUD(g,t){
  const modes=[
    {id:'seed',emoji:'ğŸŒ°',label:'Plant'},
    {id:'water',emoji:'ğŸ’§',label:'Water'},
    {id:'fert',emoji:'â­',label:'Fertilize'},
    {id:'collect',emoji:'ğŸŒ¸',label:'Collect'},
  ];
  const bw=88, gap=7, totalW=modes.length*(bw+gap)+gap, bx=(CW-totalW)/2, by=CH-54;
  ctx.fillStyle='rgba(0,0,0,0.4)';
  ctx.beginPath(); ctx.roundRect(bx,by-4,totalW,50,10); ctx.fill();
  modes.forEach((m,i)=>{
    const mx=bx+gap+i*(bw+gap);
    ctx.fillStyle=g.mode===m.id?'rgba(200,230,200,0.92)':'rgba(255,255,255,0.13)';
    ctx.beginPath(); ctx.roundRect(mx,by,bw,40,8); ctx.fill();
    if(g.mode===m.id){ctx.strokeStyle='#81c784';ctx.lineWidth=1.5;ctx.beginPath();ctx.roundRect(mx,by,bw,40,8);ctx.stroke();}
    ctx.font='14px serif'; ctx.textAlign='center'; ctx.fillText(m.emoji,mx+bw/2,by+18);
    ctx.font='bold 9px Nunito,sans-serif';
    ctx.fillStyle=g.mode===m.id?'#2e7d32':'rgba(255,255,255,0.65)';
    ctx.fillText(m.label,mx+bw/2,by+35);
  });
  // Vase button top-right
  const hasFlowers=g.vase.length>0;
  ctx.fillStyle=hasFlowers?'rgba(180,100,160,0.8)':'rgba(0,0,0,0.3)';
  ctx.beginPath(); ctx.roundRect(CW-90,8,82,32,8); ctx.fill();
  ctx.font='bold 10px Nunito,sans-serif'; ctx.fillStyle='white'; ctx.textAlign='center';
  ctx.fillText(`ğŸº Vase (${g.vase.length})`,CW-49,28);
  gardenState._modeBtn=modes.map((m,i)=>({id:m.id,x:bx+gap+i*(bw+gap),y:by,w:bw,h:40}));
  gardenState._vaseBtn={x:CW-90,y:8,w:82,h:32};
}

function renderVase(g,t){
  // Modal panel showing vase contents
  const pw=260, ph=Math.min(300,g.vase.length*40+80);
  const px=(CW-pw)/2, py=(CH-ph)/2;
  ctx.fillStyle='rgba(0,0,0,0.55)'; ctx.fillRect(0,0,CW,CH);
  ctx.fillStyle='#fff9f0';
  ctx.beginPath(); ctx.roundRect(px,py,pw,ph,14); ctx.fill();
  ctx.strokeStyle='#d4a574'; ctx.lineWidth=2;
  ctx.beginPath(); ctx.roundRect(px,py,pw,ph,14); ctx.stroke();
  // Vase emoji
  ctx.font='32px serif'; ctx.textAlign='center';
  ctx.fillText('ğŸº',px+pw/2,py+38);
  ctx.font='bold 11px Nunito,sans-serif'; ctx.fillStyle='#5d3a1a';
  ctx.fillText('Your Flower Vase',px+pw/2,py+56);
  if(g.vase.length===0){
    ctx.font='11px Nunito,sans-serif'; ctx.fillStyle='#a08060';
    ctx.fillText('No flowers yet â€” collect blooms!',px+pw/2,py+80);
  } else {
    // Draw flowers in rows
    const cols=5, startY=py+72;
    g.vase.forEach((fl,i)=>{
      const fx=px+30+(i%cols)*44, fy=startY+Math.floor(i/cols)*44;
      const bob=Math.sin(t*0.05+i*0.8)*3;
      ctx.save(); ctx.shadowColor=fl.color; ctx.shadowBlur=8;
      ctx.font='24px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(fl.emoji,fx,fy+bob); ctx.restore();
    });
  }
  ctx.font='bold 10px Nunito,sans-serif'; ctx.fillStyle='#a08060'; ctx.textAlign='center';
  ctx.fillText('Tap anywhere to close',px+pw/2,py+ph-10);
  g._vaseModalOpen=true;
}

function gardenHandleTap(x,y){
  const g=gardenState; if(!g||!g.running) return;
  // Close vase modal
  if(g.showVase){ g.showVase=false; g._vaseModalOpen=false; return; }
  if(g._vaseBtn&&x>=g._vaseBtn.x&&x<=g._vaseBtn.x+g._vaseBtn.w&&y>=g._vaseBtn.y&&y<=g._vaseBtn.y+g._vaseBtn.h){g.showVase=true;return;}
  for(const btn of (g._modeBtn||[])) if(x>=btn.x&&x<=btn.x+btn.w&&y>=btn.y&&y<=btn.y+btn.h){g.mode=btn.id;return;}
  const COLS_G=5,ROWS_G=4,cellW=CW/COLS_G,cellH=(CH*0.6)/ROWS_G;
  const plot=g.plots.find(p=>Math.abs(p.x-x)<cellW/2&&Math.abs(p.y-y)<cellH/2);
  if(!plot) return;
  const ft=plot.flowerType;
  if(g.mode==='seed' && plot.state==='empty'){
    plot.state='seeded';
    plot.flowerType=FLOWER_TYPES[Math.floor(Math.random()*FLOWER_TYPES.length)];
    spawnGardenParticles(g,plot.x,plot.y,'#a5d6a7');
    playPlant();
  } else if(g.mode==='water' && ft && plot.state!=='bloomed' && plot.state!=='empty'){
    if(plot.waterCount < ft.waterNeeded){
      plot.waterCount++;
      g.watering=true; g.waterX=plot.x; g.waterY=plot.y;
      setTimeout(()=>{if(g)g.watering=false;},400);
      playWater();
      checkGardenBloom(g,plot);
    }
  } else if(g.mode==='fert' && ft && plot.state!=='bloomed' && plot.state!=='empty'){
    if(ft.fertNeeded>0 && plot.fertCount < ft.fertNeeded){
      plot.fertCount++;
      spawnGardenParticles(g,plot.x,plot.y,'#ffb300');
      playFert();
      checkGardenBloom(g,plot);
    }
  } else if(g.mode==='collect' && plot.state==='bloomed'){
    g.vase.push({emoji:ft.emoji, color:ft.color, name:ft.name});
    plot.state='empty'; plot.flowerType=null; plot.waterCount=0; plot.fertCount=0;
    spawnGardenParticles(g,plot.x,plot.y,ft.color);
    playCollectFlower();
  }
}

function checkGardenBloom(g,p){
  const ft=p.flowerType; if(!ft) return;
  if(p.waterCount>=ft.waterNeeded && (ft.fertNeeded===0||p.fertCount>=ft.fertNeeded)){
    p.state='bloomed';
    g.totalBloomed++;
    spawnGardenParticles(g,p.x,p.y,ft.color);
    playBloom();
  } else {
    p.state='growing';
  }
}

function playFert(){try{const ac=getAudio(),t=ac.currentTime;const o=ac.createOscillator(),g=ac.createGain();o.type='triangle';o.frequency.setValueAtTime(600,t);o.frequency.exponentialRampToValueAtTime(900,t+0.12);g.gain.setValueAtTime(0.09,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.18);o.connect(g);g.connect(ac.destination);o.start(t);o.stop(t+0.2);}catch(e){}}
function playCollectFlower(){try{const ac=getAudio(),t=ac.currentTime;[659,784,880].forEach((f,i)=>{const o=ac.createOscillator(),g=ac.createGain();o.type='sine';o.frequency.value=f;g.gain.setValueAtTime(0,t+i*0.06);g.gain.linearRampToValueAtTime(0.13,t+i*0.06+0.03);g.gain.exponentialRampToValueAtTime(0.001,t+i*0.06+0.3);o.connect(g);g.connect(ac.destination);o.start(t+i*0.06);o.stop(t+i*0.06+0.35);});}catch(e){}}
function playBloom(){try{const ac=getAudio(),t=ac.currentTime;[784,988,1175].forEach((f,i)=>{const o=ac.createOscillator(),g=ac.createGain();o.type='triangle';o.frequency.value=f;g.gain.setValueAtTime(0,t+i*0.08);g.gain.linearRampToValueAtTime(0.1,t+i*0.08+0.04);g.gain.exponentialRampToValueAtTime(0.001,t+i*0.08+0.4);o.connect(g);g.connect(ac.destination);o.start(t+i*0.08);o.stop(t+i*0.08+0.45);});}catch(e){}}
function playPlant(){try{const ac=getAudio(),t=ac.currentTime;const o=ac.createOscillator(),g=ac.createGain();o.type='sine';o.frequency.setValueAtTime(400,t);o.frequency.exponentialRampToValueAtTime(600,t+0.1);g.gain.setValueAtTime(0.08,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.15);o.connect(g);g.connect(ac.destination);o.start(t);o.stop(t+0.18);}catch(e){}}
function playWater(){try{const ac=getAudio(),t=ac.currentTime;for(let i=0;i<4;i++){const o=ac.createOscillator(),g=ac.createGain();o.type='sine';o.frequency.setValueAtTime(800+Math.random()*400,t+i*0.04);g.gain.setValueAtTime(0.04,t+i*0.04);g.gain.exponentialRampToValueAtTime(0.001,t+i*0.04+0.08);o.connect(g);g.connect(ac.destination);o.start(t+i*0.04);o.stop(t+i*0.04+0.1);}}catch(e){}}

function gardenLoop(){
  gardenRaf=requestAnimationFrame(gardenLoop);
  updateGarden(); renderGarden();
}
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸŒ³ TOPIARY GARDEN
// Pixel-mask approach: offscreen canvas tracks which cells are
// trimmed (transparent) vs untrimmed (green bush). Player paints
// with shears by dragging; pixels become transparent revealing
// the sky/hedge-frame underneath. Template shapes shown as guides.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const TP = {
  // Bush grid â€” 64Ã—64 cells, each ~6px on 420px canvas
  COLS: 64, ROWS: 64,
  get CW(){ return 420; },
  get CH(){ return 700; },
  get CELL(){ return 420/64; },  // ~6.5px
  BRUSH_SIZES:[1,2,4],           // cell radius for each tool
  TOOLS:['Fine âœ‚ï¸','Medium âœ‚ï¸','Wide âœ‚ï¸'],
};

// Pre-defined template shapes as functions returning Set of "col,row" strings
const TOPIARY_TEMPLATES = [
  {
    name:'Cat ğŸ±', hint:'Trim away to reveal a cat silhouette',
    // cat face: big circle head, two triangle ears, small body
    build(cols, rows) {
      const s = new Set();
      const cx=cols/2, cy=rows*0.42, cr=rows*0.22;
      // Fill INSIDE = keep green; we mark cells to KEEP as the outline tells player what to trim OUTSIDE
      // Actually we'll just give a ghost guide â€” the mask starts fully green
      // Template = pixels that should eventually be TRIMMED (transparent)
      // We draw the NEGATIVE space: everything that is NOT the cat shape
      for(let r=0;r<rows;r++) for(let cc=0;cc<cols;cc++){
        const dx=cc-cx, dy=r-cy, d=Math.hypot(dx,dy);
        const inHead = d < cr;
        // Ears: two triangles top of head
        const leftEar  = cc>cx-cr*0.55 && cc<cx-cr*0.1 && r>cy-cr*1.35 && r<cy-cr*0.6 && (r-(cy-cr*1.35)) > Math.abs(cc-(cx-cr*0.3))*0.8;
        const rightEar = cc>cx+cr*0.1  && cc<cx+cr*0.55 && r>cy-cr*1.35 && r<cy-cr*0.6 && (r-(cy-cr*1.35)) > Math.abs(cc-(cx+cr*0.3))*0.8;
        // Body: rounded rect below head
        const bw=cr*0.8, bh=cr*0.9, bx=cx, by=cy+cr*0.75;
        const inBody = Math.abs(cc-bx)<bw && Math.abs(r-by)<bh;
        if(!inHead && !leftEar && !rightEar && !inBody) s.add(`${cc},${r}`);
      }
      return s;
    }
  },
  {
    name:'Star â­', hint:'Carve a five-pointed star',
    build(cols,rows){
      const s=new Set();
      const cx=cols/2, cy=rows/2, R=rows*0.38, r2=R*0.42;
      function inStar(x,y){
        const angle=Math.atan2(y-cy,x-cx)+Math.PI/2;
        const dist=Math.hypot(x-cx,y-cy);
        const a=((angle%(Math.PI*2/5))+Math.PI*2/5)%(Math.PI*2/5);
        const rInner=r2+(R-r2)*(a<Math.PI/5?a/(Math.PI/5):(Math.PI*2/5-a)/(Math.PI/5));
        return dist<rInner;
      }
      for(let r=0;r<rows;r++) for(let cc=0;cc<cols;cc++){
        if(!inStar(cc+0.5,r+0.5)) s.add(`${cc},${r}`);
      }
      return s;
    }
  },
  {
    name:'Heart ğŸ’š', hint:'Shape the bush into a heart',
    build(cols,rows){
      const s=new Set();
      const cx=cols/2, cy=rows/2+rows*0.04, scale=rows*0.021;
      function inHeart(x,y){
        const nx=(x-cx)/scale, ny=-(y-cy)/scale+3;
        return (nx*nx+ny*ny-16)*(nx*nx+ny*ny-16)*(nx*nx+ny*ny-16) - 108*nx*nx*ny*ny*ny < 0;
      }
      for(let r=0;r<rows;r++) for(let cc=0;cc<cols;cc++){
        if(!inHeart(cc,r)) s.add(`${cc},${r}`);
      }
      return s;
    }
  },
  {
    name:'Spiral ğŸŒ€', hint:'Create a spiral groove',
    build(cols,rows){
      const s=new Set();
      // Just outer border + a cross for freeform â€” not a strict template
      // Free-carve mode: no template cells
      return s; // empty = everything to trim is player's choice
    }
  },
  {
    name:'Free âœ¨', hint:'Carve your own design freely',
    build(cols,rows){ return new Set(); }
  },
];

function beginTopiary() {
  stopAllGames();
  setHudMode('minigame');
  document.getElementById('game-canvas-wrap').style.display='block';
  document.querySelectorAll('.screen').forEach(s=>s.classList.add('hidden'));

  // Mask canvas: green=1 (bush), trimmed=0
  const mask = new Uint8Array(TP.COLS * TP.ROWS).fill(1);

  // Pick starting template (default: Cat)
  const templateIdx = 0;
  const template = TOPIARY_TEMPLATES[templateIdx];
  const guide = template.build(TP.COLS, TP.ROWS); // Set of cells that SHOULD be trimmed

  // Off-screen canvas for the bush texture (drawn once, referenced each frame)
  const bushCanvas = document.createElement('canvas');
  bushCanvas.width = TP.COLS; bushCanvas.height = TP.ROWS;
  const btx = bushCanvas.getContext('2d');
  // Fill with rich green noise texture
  for(let r=0;r<TP.ROWS;r++) for(let cc=0;cc<TP.COLS;cc++){
    const n = Math.sin(cc*0.8+r*1.1)*0.5+Math.cos(cc*1.3-r*0.7)*0.5;
    const lightness = 32+n*8;
    btx.fillStyle=`hsl(128,55%,${lightness}%)`;
    btx.fillRect(cc,r,1,1);
  }

  topiaryState = {
    running:true, time:0,
    mask, guide,
    templateIdx,
    templates: TOPIARY_TEMPLATES,
    bushCanvas,
    tool:1,            // 0=fine, 1=medium, 2=wide
    mode:'trim',       // trim|regrow
    isDrawing:false,
    particles:[],
    trimCount:0,       // total cells trimmed
    totalCells: TP.COLS * TP.ROWS,
    showTemplateMenu:false,
    // Cached display canvas (rebuilt when mask changes)
    displayDirty:true,
    displayCanvas: createTopiaryDisplay(mask, bushCanvas),
  };

  if(musicEnabled) startMusic();
  topiaryLoop();
}

function createTopiaryDisplay(mask, bushCanvas) {
  const dc = document.createElement('canvas');
  dc.width = TP.COLS; dc.height = TP.ROWS;
  return dc;
}

function rebuildTopiaryDisplay(tp) {
  const dc = tp.displayCanvas;
  const dtx = dc.getContext('2d');
  dtx.clearRect(0,0,TP.COLS,TP.ROWS);
  // Draw bush where mask=1
  dtx.drawImage(tp.bushCanvas,0,0);
  // Erase trimmed cells
  dtx.globalCompositeOperation='destination-in';
  for(let r=0;r<TP.ROWS;r++) for(let cc=0;cc<TP.COLS;cc++){
    if(tp.mask[r*TP.COLS+cc]===0){
      dtx.clearRect(cc,r,1,1);
    }
  }
  dtx.globalCompositeOperation='source-over';
  tp.displayDirty=false;
}

function updateTopiary() {
  const tp=topiaryState; if(!tp||!tp.running) return;
  tp.time++;
  tp.particles=tp.particles.filter(p=>p.life>0);
  tp.particles.forEach(p=>{p.x+=p.vx;p.y+=p.vy;p.life-=0.04;p.vy+=0.08;});
  if(tp.displayDirty) rebuildTopiaryDisplay(tp);
}

function renderTopiary() {
  const tp=topiaryState; if(!tp) return;
  const t=tp.time;
  ctx.clearRect(0,0,CW,CH);

  // Sky background (visible through trimmed areas)
  const skyG=ctx.createLinearGradient(0,0,0,CH);
  skyG.addColorStop(0,'#b3e5fc'); skyG.addColorStop(0.6,'#e8f5e9'); skyG.addColorStop(1,'#c8e6c9');
  ctx.fillStyle=skyG; ctx.fillRect(0,0,CW,CH);

  // â”€â”€ Fixed layout constants (must match topiaryApply) â”€â”€
  const TP_BY=44, TP_BH=480;          // bush top=44, height=480, bottom=524
  const TP_trunkY=530, TP_trunkH=36;  // trunk top=530, bottom=566
  const TP_potY=566, TP_potH=36;      // pot  top=566, bottom=602 (panel at 606)

  // Floor fill between pot-bottom and panel
  ctx.fillStyle='#558b2f';
  ctx.fillRect(0, TP_potY+TP_potH, CW, CH-(TP_potY+TP_potH));
  ctx.fillStyle='#7cb342';
  ctx.fillRect(0, TP_potY+TP_potH, CW, 10);

  // Stone pot
  const potW=CW*0.55, potX=(CW-potW)/2;
  const potY=TP_potY, potH=TP_potH;
  const potG=ctx.createLinearGradient(potX,potY,potX+potW,potY+potH);
  potG.addColorStop(0,'#9e9e9e'); potG.addColorStop(0.5,'#bdbdbd'); potG.addColorStop(1,'#757575');
  ctx.fillStyle=potG;
  ctx.beginPath(); ctx.roundRect(potX,potY,potW,potH,8); ctx.fill();
  ctx.strokeStyle='#616161'; ctx.lineWidth=2;
  ctx.beginPath(); ctx.roundRect(potX,potY,potW,potH,8); ctx.stroke();

  // Trunk
  const trunkW=18, trunkX=(CW-trunkW)/2;
  const trunkY=TP_trunkY, trunkH=TP_trunkH;
  const trunkG=ctx.createLinearGradient(trunkX,0,trunkX+trunkW,0);
  trunkG.addColorStop(0,'#6d4c41'); trunkG.addColorStop(0.5,'#8d6e63'); trunkG.addColorStop(1,'#5d4037');
  ctx.fillStyle=trunkG; ctx.fillRect(trunkX,trunkY,trunkW,trunkH);

  // Bush frame â€” the square frame around the topiary
  const bushPad=20;
  const BX=bushPad, BY=TP_BY, BW=CW-bushPad*2, BH=TP_BH;

  // Dark border/shadow behind bush
  ctx.fillStyle='rgba(0,0,0,0.18)';
  ctx.beginPath(); ctx.roundRect(BX+4,BY+4,BW,BH,8); ctx.fill();

  // Draw the topiary (scaled display canvas over bush area)
  ctx.save();
  ctx.beginPath(); ctx.roundRect(BX,BY,BW,BH,6); ctx.clip();
  ctx.imageSmoothingEnabled=false;
  ctx.drawImage(tp.displayCanvas, BX,BY,BW,BH);
  ctx.restore();

  // Bush border frame
  ctx.strokeStyle='#2e7d32'; ctx.lineWidth=3;
  ctx.beginPath(); ctx.roundRect(BX,BY,BW,BH,6); ctx.stroke();
  ctx.strokeStyle='#1b5e20'; ctx.lineWidth=1.5;
  ctx.beginPath(); ctx.roundRect(BX+3,BY+3,BW-6,BH-6,4); ctx.stroke();

  // Guide overlay â€” show template ghost
  if(tp.guide.size > 0) {
    const cellW=BW/TP.COLS, cellH=BH/TP.ROWS;
    ctx.save(); ctx.globalAlpha=0.18;
    ctx.fillStyle='#fff9c4';
    for(const key of tp.guide){
      const [cc,r]=key.split(',').map(Number);
      if(tp.mask[r*TP.COLS+cc]===0) continue; // already trimmed, no need to show guide
      ctx.fillRect(BX+cc*cellW, BY+r*cellH, cellW+0.5, cellH+0.5);
    }
    ctx.restore();
  }

  // Clip hint â€” progress toward template completion
  if(tp.guide.size > 0) {
    let guideTrimmed=0;
    for(const key of tp.guide) {
      const [cc,r]=key.split(',').map(Number);
      if(tp.mask[r*TP.COLS+cc]===0) guideTrimmed++;
    }
    const pct=guideTrimmed/tp.guide.size;
    if(pct>0.02) {
      // Progress bar sits in the trunk zone (530..566)
      const pbY = 535, pbH = 18;
      ctx.fillStyle='rgba(0,0,0,0.42)';
      ctx.beginPath(); ctx.roundRect(BX, pbY, BW, pbH, 5); ctx.fill();
      ctx.fillStyle=`hsl(${100+pct*40},70%,58%)`;
      ctx.beginPath(); ctx.roundRect(BX+1, pbY+1, Math.max(6,(BW-2)*pct), pbH-2, 4); ctx.fill();
      ctx.font='bold 9px Nunito,sans-serif'; ctx.fillStyle='white'; ctx.textAlign='center';
      ctx.fillText(`${Math.round(pct*100)}% of "${tp.templates[tp.templateIdx].name}" shaped`, CW/2, pbY+13);
    }
  }

  // Leaf clip particles
  tp.particles.forEach(p=>{
    ctx.save(); ctx.globalAlpha=p.life;
    ctx.font='12px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(p.emoji,p.x,p.y); ctx.restore();
  });

  drawTopiaryHUD(tp,t);
  drawHelp(t);
}

function drawTopiaryHUD(tp,t){
  // â”€â”€ Single unified bottom panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Panel sits at the bottom of the canvas, contains all controls.
  // Layout (topâ†’bottom inside panel):
  //   Row A: [ğŸ¨ Shape: <name>]   [âœ‚ï¸ Trim | ğŸŒ± Regrow]
  //   divider line
  //   Row B: [Fine âœ‚ï¸]  [Medium âœ‚ï¸]  [Wide âœ‚ï¸]

  const PAD  = 10;     // outer horizontal padding
  const IH   = 30;     // height of each inner row
  const DIV  = 6;      // divider gap between rows
  const BTM  = 8;      // gap from canvas bottom edge
  const panelH = PAD + IH + DIV + IH + PAD;  // 10+30+6+30+10 = 86
  const panelY = CH - panelH - BTM;           // y=606
  const panelW = CW - PAD*2;                  // 400
  const panelX = PAD;                          // 10

  // Panel background
  ctx.fillStyle = 'rgba(0,0,0,0.52)';
  ctx.beginPath(); ctx.roundRect(panelX, panelY, panelW, panelH, 12); ctx.fill();

  // â”€â”€ Row A: Shape button (left half) + Mode toggle (right half) â”€â”€
  const rowAy   = panelY + PAD;
  const halfW   = (panelW - 8) / 2;   // 196 each, 8px gap between
  const shapeX  = panelX + 4;
  const modeX   = shapeX + halfW + 8;

  // Shape button
  ctx.fillStyle = 'rgba(255,255,255,0.13)';
  ctx.beginPath(); ctx.roundRect(shapeX, rowAy, halfW, IH, 7); ctx.fill();
  ctx.save();
  ctx.font = 'bold 10px Nunito,sans-serif'; ctx.fillStyle = 'rgba(255,255,255,0.6)'; ctx.textAlign = 'left';
  ctx.fillText('SHAPE', shapeX+8, rowAy+10);
  ctx.font = 'bold 11px Nunito,sans-serif'; ctx.fillStyle = '#a5d6a7';
  ctx.fillText('ğŸ¨ ' + tp.templates[tp.templateIdx].name, shapeX+8, rowAy+24);
  ctx.restore();
  tp._templateBtn = {x:shapeX, y:rowAy, w:halfW, h:IH};

  // Mode toggle
  const isTrim = tp.mode === 'trim';
  ctx.fillStyle = isTrim ? 'rgba(46,125,50,0.85)' : 'rgba(230,130,30,0.85)';
  ctx.beginPath(); ctx.roundRect(modeX, rowAy, halfW, IH, 7); ctx.fill();
  ctx.save();
  ctx.font = 'bold 10px Nunito,sans-serif'; ctx.fillStyle = 'rgba(255,255,255,0.7)'; ctx.textAlign = 'left';
  ctx.fillText('MODE', modeX+8, rowAy+10);
  ctx.font = 'bold 11px Nunito,sans-serif'; ctx.fillStyle = 'white';
  ctx.fillText(isTrim ? 'âœ‚ï¸ Trimming' : 'ğŸŒ± Regrowing', modeX+8, rowAy+24);
  ctx.restore();
  tp._regrowBtn = {x:modeX, y:rowAy, w:halfW, h:IH};

  // â”€â”€ Divider â”€â”€
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,0.12)'; ctx.lineWidth = 1;
  const divY = rowAy + IH + DIV/2;
  ctx.beginPath(); ctx.moveTo(panelX+12, divY); ctx.lineTo(panelX+panelW-12, divY); ctx.stroke();
  ctx.restore();

  // â”€â”€ Row B: Three brush-size buttons, equal width â”€â”€
  const rowBy  = rowAy + IH + DIV;
  const btnGap = 6;
  const bw     = (panelW - btnGap*4) / 3;   // (400-24)/3 = 125.3
  const tools  = TP.TOOLS;

  tools.forEach((label, i) => {
    const bx = panelX + btnGap + i * (bw + btnGap);
    const sel = tp.tool === i;
    ctx.fillStyle = sel ? 'rgba(165,214,167,0.95)' : 'rgba(255,255,255,0.12)';
    ctx.beginPath(); ctx.roundRect(bx, rowBy, bw, IH, 7); ctx.fill();
    if (sel) {
      ctx.save(); ctx.strokeStyle = '#4caf50'; ctx.lineWidth = 1.5;
      ctx.beginPath(); ctx.roundRect(bx, rowBy, bw, IH, 7); ctx.stroke();
      ctx.restore();
    }
    ctx.save();
    ctx.font = 'bold 11px Nunito,sans-serif'; ctx.textAlign = 'center';
    ctx.fillStyle = sel ? '#1b5e20' : 'rgba(255,255,255,0.82)';
    ctx.fillText(label, bx + bw/2, rowBy + 19);
    ctx.restore();
  });
  tp._toolBtns = tools.map((_, i) => {
    const bx = panelX + btnGap + i * (bw + btnGap);
    return {i, x:bx, y:rowBy, w:bw, h:IH};
  });

  // â”€â”€ Template menu overlay (modal) â”€â”€
  if (tp.showTemplateMenu) {
    ctx.fillStyle = 'rgba(0,0,0,0.65)'; ctx.fillRect(0, 0, CW, CH);
    const mw = 280, mh = tp.templates.length * 52 + 56;
    const mx = (CW - mw) / 2, my = (CH - mh) / 2;
    ctx.fillStyle = '#f1f8e9';
    ctx.beginPath(); ctx.roundRect(mx, my, mw, mh, 14); ctx.fill();
    ctx.save(); ctx.strokeStyle = '#81c784'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.roundRect(mx, my, mw, mh, 14); ctx.stroke(); ctx.restore();
    ctx.save();
    ctx.font = 'bold 14px Nunito,sans-serif'; ctx.fillStyle = '#2e7d32'; ctx.textAlign = 'center';
    ctx.fillText('Choose a Shape', mx + mw/2, my + 30);
    ctx.restore();
    tp.templates.forEach((tmpl, i) => {
      const ty = my + 48 + i * 52;
      const sel = tp.templateIdx === i;
      ctx.fillStyle = sel ? 'rgba(165,214,167,0.88)' : 'rgba(255,255,255,0.7)';
      ctx.beginPath(); ctx.roundRect(mx + 10, ty, mw - 20, 42, 8); ctx.fill();
      if (sel) {
        ctx.save(); ctx.strokeStyle = '#43a047'; ctx.lineWidth = 1.5;
        ctx.beginPath(); ctx.roundRect(mx + 10, ty, mw - 20, 42, 8); ctx.stroke();
        ctx.restore();
      }
      ctx.save();
      ctx.font = 'bold 12px Nunito,sans-serif'; ctx.fillStyle = '#1b5e20'; ctx.textAlign = 'left';
      ctx.fillText(tmpl.name, mx + 22, ty + 16);
      ctx.font = '10px Nunito,sans-serif'; ctx.fillStyle = '#558b2f';
      ctx.fillText(tmpl.hint, mx + 22, ty + 31);
      ctx.restore();
    });
    tp._templateMenuItems = tp.templates.map((_, i) => ({
      i, x:mx+10, y:my+48+i*52, w:mw-20, h:42
    }));
  }

  // Hint text just below HUD strip at top
  ctx.save();
  ctx.font = 'bold 10px Nunito,sans-serif';
  ctx.fillStyle = 'rgba(20,60,20,0.55)';
  ctx.textAlign = 'center';
  ctx.fillText(isTrim ? 'Drag to trim' : 'Drag to regrow', CW/2, 52);
  ctx.restore();
}

function topiaryHandleStart(x,y){
  const tp=topiaryState; if(!tp||!tp.running) return;
  if(tp.showTemplateMenu){
    for(const item of (tp._templateMenuItems||[])){
      if(x>=item.x&&x<=item.x+item.w&&y>=item.y&&y<=item.y+item.h){
        tp.templateIdx=item.i;
        tp.guide=tp.templates[item.i].build(TP.COLS,TP.ROWS);
        tp.showTemplateMenu=false; return;
      }
    }
    tp.showTemplateMenu=false; return;
  }
  if(tp._regrowBtn&&x>=tp._regrowBtn.x&&x<=tp._regrowBtn.x+tp._regrowBtn.w&&y>=tp._regrowBtn.y&&y<=tp._regrowBtn.y+tp._regrowBtn.h){
    tp.mode=tp.mode==='trim'?'regrow':'trim'; return;
  }
  if(tp._templateBtn&&x>=tp._templateBtn.x&&x<=tp._templateBtn.x+tp._templateBtn.w&&y>=tp._templateBtn.y&&y<=tp._templateBtn.y+tp._templateBtn.h){
    tp.showTemplateMenu=true; return;
  }
  for(const btn of (tp._toolBtns||[])){
    if(x>=btn.x&&x<=btn.x+btn.w&&y>=btn.y&&y<=btn.y+btn.h){tp.tool=btn.i;return;}
  }
  tp.isDrawing=true;
  topiaryApply(tp,x,y);
}

function topiaryHandleMove(x,y){
  const tp=topiaryState; if(!tp||!tp.running||!tp.isDrawing) return;
  topiaryApply(tp,x,y);
}

function topiaryHandleEnd(){
  if(topiaryState) topiaryState.isDrawing=false;
}

function topiaryApply(tp,canvasX,canvasY){
  // Must match renderTopiary fixed constants exactly
  const bushPad=20, BX=bushPad, BY=44, BW=CW-bushPad*2, BH=480;
  const relX=canvasX-BX, relY=canvasY-BY;
  if(relX<0||relY<0||relX>BW||relY>BH) return;
  // Convert to grid coords
  const gx=(relX/BW)*TP.COLS, gy=(relY/BH)*TP.ROWS;
  const radius=TP.BRUSH_SIZES[tp.tool];
  if(tp.mode==='trim'){
    topiaryTrim(tp,gx,gy,radius);
    if(Math.random()<0.3){
      const px=canvasX+(Math.random()-0.5)*20, py=canvasY+(Math.random()-0.5)*10;
      tp.particles.push({x:px,y:py,vx:(Math.random()-0.5)*3,vy:-1.5-Math.random()*2,emoji:['ğŸƒ','ğŸŒ¿','âœ‚ï¸'][Math.floor(Math.random()*3)],life:1});
    }
  } else {
    topiaryRegrow(tp,gx,gy,radius);
  }
}

function topiaryTrim(tp, gx, gy, radius) {
  const gc=Math.floor(gx), gr=Math.floor(gy);
  let changed=false;
  for(let dr=-radius;dr<=radius;dr++) for(let dc=-radius;dc<=radius;dc++){
    if(Math.hypot(dr,dc)>radius+0.5) continue;
    const cc=gc+dc, r=gr+dr;
    if(cc<0||cc>=TP.COLS||r<0||r>=TP.ROWS) continue;
    if(tp.mask[r*TP.COLS+cc]===1){ tp.mask[r*TP.COLS+cc]=0; tp.trimCount++; changed=true; }
  }
  if(changed) tp.displayDirty=true;
}

function topiaryRegrow(tp, gx, gy, radius) {
  const gc=Math.floor(gx), gr=Math.floor(gy);
  let changed=false;
  for(let dr=-radius;dr<=radius;dr++) for(let dc=-radius;dc<=radius;dc++){
    if(Math.hypot(dr,dc)>radius+0.5) continue;
    const cc=gc+dc, r=gr+dr;
    if(cc<0||cc>=TP.COLS||r<0||r>=TP.ROWS) continue;
    if(tp.mask[r*TP.COLS+cc]===0){ tp.mask[r*TP.COLS+cc]=1; changed=true; }
  }
  if(changed) tp.displayDirty=true;
}

function topiaryLoop(){
  topiaryRaf=requestAnimationFrame(topiaryLoop);
  updateTopiary(); renderTopiary();
}
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// END TOPIARY GARDEN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// END MINI-GAMES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LEVEL DATA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const LEVEL_DEFS = [
  { name:'Home Sweet Home', icon:'ğŸ ', theme:'home', rows:32,
    floorTile:{fill:'#efebe9', alt:'#e8ddd8', line:'#d7ccc8'},
    wallFill:'#bcaaa4', elevFill:'#fff9f0', elevStroke:'#ffb3a0',
    completeTxt:'You found the cat door! ğŸ±âœ¨', catCount:3,
    collectEmojis:['ğŸŸ','ğŸ¥›','ğŸ£','ğŸ§¶','ğŸª†'],
    secretEmojis:['ğŸ ','ğŸ§¸','ğŸ’'],
    doorStyle:'home',
  },
  { name:'Neighbourhood Park', icon:'ğŸŒ³', theme:'park', rows:36,
    floorTile:{fill:'#c8e6c9', alt:'#b2dfdb', line:'#a5d6a7'},
    wallFill:'#388e3c', elevFill:'#e8f5e9', elevStroke:'#66bb6a',
    completeTxt:'You reached the park gate! ğŸŒ³ğŸŒ¸', catCount:4,
    collectEmojis:['ğŸ','ğŸŸ','ğŸŒ¸','ğŸ¾','ğŸ‚'],
    secretEmojis:['ğŸ¦‹','ğŸ„','ğŸªº'],
    doorStyle:'park',
  },
  { name:'The Big Building', icon:'ğŸ¢', theme:'building', rows:40,
    floorTile:{fill:'#cfd8dc', alt:'#b0bec5', line:'#90a4ae'},
    wallFill:'#607d8b', elevFill:'#eceff1', elevStroke:'#78909c',
    completeTxt:'Rooftop reached! ğŸ¢âœ¨', catCount:5,
    collectEmojis:['ğŸ±','ğŸ¥«','â­','ğŸ”®','ğŸ’'],
    secretEmojis:['ğŸ“€','ğŸ','ğŸ”®'],
    doorStyle:'building',
  },
  { name:'Train Station', icon:'ğŸš‰', theme:'station', rows:44,
    floorTile:{fill:'#d1c4e9', alt:'#b39ddb', line:'#9575cd'},
    wallFill:'#5e35b1', elevFill:'#ede7f6', elevStroke:'#9575cd',
    completeTxt:'All aboard! ğŸš‰ğŸŠ', catCount:5,
    collectEmojis:['ğŸ™','ğŸœ','ğŸ«','ğŸ§¸','ğŸš„'],
    secretEmojis:['ğŸŸï¸','ğŸ“¿','ğŸ—ï¸'],
    doorStyle:'station',
  },
];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WORLD GENERATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Tile types: 0=floor, 1=wall, 2=elevated(impassable without interaction), 3=void/water
function seededRng(seed) { let s = seed | 0; return () => { s = (s * 9301 + 49297) % 233280; return s / 233280; }; }

function generateWorld(levelIdx) {
  const def = LEVEL_DEFS[levelIdx];
  const R = def.rows;
  const grid = Array.from({length:R}, () => Array(C).fill(0));
  // Borders
  for (let r = 0; r < R; r++) { grid[r][0] = 1; grid[r][C-1] = 1; }
  for (let c = 0; c < C; c++) { grid[0][c] = 1; grid[R-1][c] = 1; }
  // Door gap
  grid[0][4] = 0; grid[0][5] = 0;

  const rng = seededRng(levelIdx * 7919 + Math.floor(Date.now() / 1000) % 9999);
  const themes = {
    home:     [{type:1,count:10,w:2,h:1},{type:1,count:6,w:1,h:2},{type:2,count:4,w:2,h:1}],
    park:     [{type:1,count:12,w:1,h:1},{type:3,count:2,w:3,h:3},{type:2,count:5,w:2,h:1}],
    building: [{type:1,count:14,w:3,h:1},{type:1,count:6,w:1,h:2},{type:2,count:6,w:2,h:1}],
    station:  [{type:1,count:12,w:2,h:1},{type:3,count:3,w:2,h:2},{type:2,count:6,w:2,h:1}],
  };
  for (const spec of (themes[def.theme] || themes.home)) {
    for (let i = 0; i < spec.count; i++) {
      const r = Math.floor(rng() * (R-6)) + 3;
      const c = Math.floor(rng() * (C-2-spec.w)) + 1;
      if (r <= 2 && c >= 3 && c <= 5) continue;
      if (r >= R - 4) continue;
      for (let dr = 0; dr < spec.h && r+dr < R-1; dr++)
        for (let dc = 0; dc < spec.w && c+dc < C-1; dc++)
          if (grid[r+dr][c+dc] === 0) grid[r+dr][c+dc] = spec.type;
    }
  }
  // Ensure navigable rows
  for (let r = 3; r < R-3; r += 3) {
    let hasGap = false;
    for (let c = 1; c < C-1; c++) if (grid[r][c] === 0) { hasGap = true; break; }
    if (!hasGap) { grid[r][4] = 0; grid[r][5] = 0; }
  }
  return grid;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INTERACTABLE GENERATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Types: 'box'(scratchable/breakable), 'lever'(toggles platform), 
//        'vending'(drops food), 'switch'(opens elev), 'plant'(decorative break),
//        'luggage'(knockable), 'feeder'(scatter birds)
function generateInteractables(levelIdx, grid, R, rng) {
  const def = LEVEL_DEFS[levelIdx];
  const items = [];
  const used = new Set();

  // Collect valid floor positions
  const floors = [];
  for (let r = 2; r < R-2; r++)
    for (let c = 1; c < C-1; c++)
      if (grid[r][c] === 0) floors.push({r,c});

  function place(type, emoji, brokenEmoji, pts, en, extra={}) {
    for (let a = 0; a < 40; a++) {
      const cell = floors[Math.floor(rng() * floors.length)];
      if (!cell) continue;
      const k = `${cell.r},${cell.c}`;
      if (used.has(k)) continue;
      // Don't crowd start/end
      if (cell.r >= R-4 || cell.r <= 2) continue;
      used.add(k);
      items.push({
        type, emoji, brokenEmoji, pts, en,
        wx: cell.c*TILE + TILE/2, wy: cell.r*TILE + TILE/2,
        active: true, activated: false, animTick: 0,
        ...extra
      });
      return true;
    }
    return false;
  }

  // Theme-specific interactables
  if (def.theme === 'home') {
    for (let i = 0; i < 5; i++) place('box','ğŸ“¦','ğŸ—ƒï¸', 8, 0);
    for (let i = 0; i < 3; i++) place('plant','ğŸª´','ğŸŒ¿', 4, 0);
    place('lamp','ğŸ’¡','ğŸ’¡', 0, 0, {toggled:false});
    // 2 lever+platform pairs
    for (let i = 0; i < 2; i++) placeLeverPlatformPair(items, floors, grid, R, rng, used, i, def);
  } else if (def.theme === 'park') {
    for (let i = 0; i < 4; i++) place('plant','ğŸŒ¸','ğŸŒ¸', 5, 0, {scatter:true});
    for (let i = 0; i < 3; i++) place('box','ğŸª¨','ğŸ’¨', 6, 0);
    place('feeder','ğŸ¦â€â¬›','ğŸ¦', 0, 0);
    for (let i = 0; i < 2; i++) placeLeverPlatformPair(items, floors, grid, R, rng, used, i, def);
  } else if (def.theme === 'building') {
    for (let i = 0; i < 4; i++) place('box','ğŸ“„','ğŸ“ƒ', 5, 0);
    place('vending','ğŸ°','ğŸ¥¤', 0, 0);
    for (let i = 0; i < 2; i++) place('plant','ğŸª´','ğŸŒ±', 3, 0);
    for (let i = 0; i < 2; i++) placeLeverPlatformPair(items, floors, grid, R, rng, used, i, def);
  } else {
    for (let i = 0; i < 5; i++) place('luggage','ğŸ§³','ğŸ‘œ', 7, 0);
    place('feeder','ğŸ“°','ğŸ“°', 0, 0);
    for (let i = 0; i < 2; i++) placeLeverPlatformPair(items, floors, grid, R, rng, used, i, def);
  }
  return items;
}

function placeLeverPlatformPair(items, floors, grid, R, rng, used, idx, def) {
  // Lever on one side, platform path across void/elevated area
  const leverFloors = floors.filter(p => p.r > 4 && p.r < R-5 && !used.has(`${p.r},${p.c}`));
  if (leverFloors.length < 2) return;
  const leverCell = leverFloors[Math.floor(rng() * leverFloors.length)];
  used.add(`${leverCell.r},${leverCell.c}`);
  const leverWx = leverCell.c*TILE + TILE/2;
  const leverWy = leverCell.r*TILE + TILE/2;
  const platformId = `plat_${idx}`;
  items.push({
    type:'lever', emoji:'ğŸ”§', brokenEmoji:'ğŸ”§', pts:0, en:0,
    wx:leverWx, wy:leverWy,
    active:true, activated:false, animTick:0,
    platformId,
  });
  // Moving platform â€” travels horizontally between two x positions
  const startX = (2 + Math.floor(rng() * 3)) * TILE + TILE/2;
  const endX   = (5 + Math.floor(rng() * 3)) * TILE + TILE/2;
  const platY  = leverCell.r * TILE - TILE * (2 + Math.floor(rng() * 3));
  items.push({
    type:'movingPlatform', platformId,
    wx: startX, wy: Math.max(TILE*2, platY),
    startX, endX, speed: 0.8 + rng()*0.5,
    dir: 1, running: false,
    w: TILE*2, h: TILE*0.6,
    catRiding: false,
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DOG DATA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Human definitions â€” 2-3 per level, slow wanderers, gift givers
const HUMAN_OUTFITS = {
  home:     [{top:'#ef9a9a',bottom:'#b0bec5',skin:'#ffcc80'},{top:'#80cbc4',bottom:'#ce93d8',skin:'#ffab91'},{top:'#fff9c4',bottom:'#a5d6a7',skin:'#ffe0b2'}],
  park:     [{top:'#a5d6a7',bottom:'#ffe082',skin:'#ffcc80'},{top:'#81d4fa',bottom:'#ef9a9a',skin:'#ffab91'},{top:'#f8bbd0',bottom:'#b0bec5',skin:'#ffe0b2'}],
  building: [{top:'#b0bec5',bottom:'#546e7a',skin:'#ffcc80'},{top:'#90a4ae',bottom:'#455a64',skin:'#ffab91'},{top:'#cfd8dc',bottom:'#607d8b',skin:'#ffe0b2'}],
  station:  [{top:'#ce93d8',bottom:'#7e57c2',skin:'#ffcc80'},{top:'#80deea',bottom:'#00838f',skin:'#ffab91'},{top:'#ef9a9a',bottom:'#c62828',skin:'#ffe0b2'}],
};
const HUMAN_GIFTS = ['treat','treat','pet','pet','treat','pet']; // shuffled each level

// Treat types: bone, meat, drumstick, cookie
// Dog treat preferences and required counts
// Friendly roaming cats â€” different colours, patterns, personalities
const FRIEND_CAT_TYPES = [
  {name:'Sora',    colorIdx:2, pattern:'tabby',  eyeIdx:0, speed:0.55, sound:'purr'},
  {name:'Mikan',   colorIdx:1, pattern:'tabby',  eyeIdx:2, speed:0.7,  sound:'chirp'},
  {name:'Kuro',    colorIdx:3, pattern:'solid',  eyeIdx:1, speed:0.45, sound:'purr'},
  {name:'Shiro',   colorIdx:0, pattern:'tuxedo', eyeIdx:2, speed:0.6,  sound:'mew'},
  {name:'Hana',    colorIdx:6, pattern:'calico', eyeIdx:4, speed:0.5,  sound:'trill'},
  {name:'Kinako',  colorIdx:4, pattern:'spots',  eyeIdx:2, speed:0.65, sound:'chirp'},
  {name:'Mugi',    colorIdx:5, pattern:'tabby',  eyeIdx:0, speed:0.5,  sound:'purr'},
];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BEGIN LEVEL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€ Spawn secrets â”€â”€
function spawnSecrets(def, floorCells, usedC, R, rng) {
  const secrets = [];
  const emojis = def.secretEmojis || ['ğŸ’','â­','ğŸŒŸ'];
  // Place in varied areas of the level
  const zones = [
    floorCells.filter(p => p.r > Math.floor(R*0.15) && p.r < Math.floor(R*0.4)),
    floorCells.filter(p => p.r > Math.floor(R*0.4)  && p.r < Math.floor(R*0.65)),
    floorCells.filter(p => p.r > Math.floor(R*0.65) && p.r < Math.floor(R*0.88)),
  ];
  for (let i = 0; i < 3; i++) {
    const zone = zones[i];
    if (!zone || zone.length === 0) continue;
    let cell;
    for (let a = 0; a < 30; a++) {
      cell = zone[Math.floor(rng() * zone.length)];
      if (cell && !usedC.has(`${cell.r},${cell.c}`)) break;
    }
    if (!cell) continue;
    usedC.add(`${cell.r},${cell.c}`);
    secrets.push({
      emoji: emojis[i % emojis.length],
      wx: cell.c*TILE + TILE/2,
      wy: cell.r*TILE + TILE/2,
      collected: false,
      revealed: false,
      bob: rng()*Math.PI*2,
    });
  }
  return secrets;
}

function spawnHumans(def, floorCells, R, rng) {
  const count = 2 + (R > 36 ? 1 : 0); // 2-3 depending on level size
  const humans = [];
  const outfits = HUMAN_OUTFITS[def.theme] || HUMAN_OUTFITS.home;
  const usedCells = new Set();
  // Spread across top 2/3 of level
  const zone = floorCells.filter(p => p.r > 3 && p.r < Math.floor(R * 0.82));
  for (let i = 0; i < count; i++) {
    let cell;
    for (let a = 0; a < 40; a++) {
      cell = zone[Math.floor(rng() * zone.length)];
      if (cell && !usedCells.has(`${cell.r},${cell.c}`)) break;
    }
    if (!cell) continue;
    usedCells.add(`${cell.r},${cell.c}`);
    const gift = rng() > 0.5 ? 'treat' : 'pet';
    const treatTypes = ['bone','meat','drumstick','cookie'];
    humans.push({
      wx: cell.c*TILE + TILE/2,
      wy: cell.r*TILE + TILE/2,
      outfit: outfits[i % outfits.length],
      gift,
      treatType: treatTypes[Math.floor(rng()*treatTypes.length)],
      state: 'wander',      // wander | offering | cooldown
      wanderAngle: rng()*Math.PI*2,
      wanderTimer: 80 + Math.floor(rng()*100),
      offerCooldown: 0,
      giftAnim: 0,
      facingAngle: 0,
      moving: false,
    });
  }
  return humans;
}

function beginLevel(idx) {
  stopAllGames();
  stopPreviewAnim();
  currentLevel = idx;
  const def = LEVEL_DEFS[idx];
  const R = def.rows;
  const rng = seededRng(idx * 7919 + Math.floor(Date.now() / 500) % 10000);
  const grid = generateWorld(idx);

  // Floor cells for spawning
  const floorCells = [];
  for (let r = 2; r < R-2; r++)
    for (let c = 1; c < C-1; c++)
      if (grid[r][c] === 0) floorCells.push({r,c});

  // Key in middle third
  const keyZone = floorCells.filter(p => p.r > R*0.25 && p.r < R*0.75);
  const keyCell = keyZone[Math.floor(rng() * keyZone.length)] || {r:Math.floor(R/2),c:5};

  // Collectibles
  const collectibles = [];
  const usedC = new Set([`${keyCell.r},${keyCell.c}`]);
  const count = 26 + idx*4;
  for (let i = 0; i < count; i++) {
    let cell;
    for (let a = 0; a < 20; a++) {
      cell = floorCells[Math.floor(rng() * floorCells.length)];
      if (cell && !usedC.has(`${cell.r},${cell.c}`) && cell.r < R-3) break;
    }
    if (!cell) continue;
    usedC.add(`${cell.r},${cell.c}`);
    const roll = rng();
    let type,emoji,pts,en;
    if (roll < 0.3)       { type='food';  emoji=def.collectEmojis[0]; pts=0; en=22; }
    else if (roll < 0.48) { type='food';  emoji=def.collectEmojis[1]||'ğŸŸ'; pts=0; en=18; }
    else if (roll < 0.62) { type='toy';   emoji=def.collectEmojis[2]||'ğŸ§¶'; pts=0; en=0; }
    else if (roll < 0.74) { type='toy';   emoji=def.collectEmojis[3]||'ğŸ¾'; pts=0; en=0; }
    else if (roll < 0.82) { type='mouse'; emoji='ğŸ­'; pts=0; en=10; }
    else if (roll < 0.86) { type='goldenmouse'; emoji='ğŸ­'; pts=0; en=0; }
    else if (roll < 0.93) { type='flower'; emoji=['ğŸŒ¸','ğŸŒ¼','ğŸ’'][Math.floor(rng()*3)]; pts=0; en=0; }
    else                  { type='flower'; emoji=['ğŸŒ¸','ğŸŒ¼','ğŸ’'][Math.floor(rng()*3)]; pts=0; en=0; }
    const isMouse = type==='mouse'||type==='goldenmouse';
    const spd = isMouse ? (type==='goldenmouse' ? 1.1:0.7) : 0;
    collectibles.push({
      type,emoji,pts,en:0,collected:false,
      wx:cell.c*TILE+TILE/2, wy:cell.r*TILE+TILE/2,
      moveSpeed:spd, moveDir:rng()>0.5?1:-1,
      moveMin:(cell.c-1)*TILE+TILE/2, moveMax:(cell.c+1)*TILE+TILE/2,
      bob:rng()*Math.PI*2, golden:type==='goldenmouse',
    });
  }

  // Friendly roaming cats
  const dogs = []; // kept as 'dogs' var name for minimal refactor, they're cats now
  const catCount = Math.round((def.catCount||3) * (CAT_COUNT_MULT||1));
  const catZone = floorCells.filter(p => p.r > 4 && p.r < R-4);
  for (let i = 0; i < catCount; i++) {
    let cell;
    for (let a = 0; a < 30; a++) {
      cell = catZone[Math.floor(rng() * catZone.length)];
      if (cell && !usedC.has(`${cell.r},${cell.c}`)) break;
    }
    if (!cell) continue;
    usedC.add(`${cell.r},${cell.c}`);
    const type = FRIEND_CAT_TYPES[Math.floor(rng() * FRIEND_CAT_TYPES.length)];
    dogs.push({
      ...type,
      wx: cell.c*TILE+TILE/2, wy: cell.r*TILE+TILE/2,
      state: 'wander',
      wanderTimer: 80+Math.floor(rng()*140),
      wanderAngle: rng()*Math.PI*2,
      facingAngle: 0,
      touchCooldown: 0,
      heartAnim: 0,
      bob: rng()*Math.PI*2,
    });
  }

  // Interactables
  const interactables = generateInteractables(idx, grid, R, rng);

  const humans = spawnHumans(def, floorCells, R, rng);

  // â”€â”€ Secret collectibles (3 per level, hidden) â”€â”€
  const secrets = spawnSecrets(def, floorCells, usedC, R, rng);
  const napSpots = spawnNapSpots(idx, floorCells, usedC, rng);
  const stickers = spawnLevelStickers(idx, floorCells, usedC, rng);
  const wateringCan = spawnWaterFeature(idx, floorCells, interactables, usedC, rng);
  const hiddenRoom = spawnHiddenRoom(idx, grid, R, floorCells, usedC, rng);
  // Fish tank â€” add as a fixed interactable near the start
  const ftZone = floorCells.filter(p => p.r > 2 && p.r < 8);
  const ftCell = ftZone[Math.floor(rng()*ftZone.length)] || floorCells[0];
  const fishTank = { wx: ftCell.c*TILE+TILE/2, wy: ftCell.r*TILE+TILE/2 };
  initWeather(idx);
  fishTapAnim = 0;

  gs = {
    running:true, time:0,
    hasKey:false, doorShake:0,
    camY:0, grid, R, def,
    cat:{
      wx:CW/2, wy:R*TILE - TILE*1.5,
      facingAngle:Math.PI, moving:false,
      scratchCooldown:0, scratchActive:false,
      onPlatform:null,
      dashFrames:0, dashCooldown:0, dashDx:0, dashDy:0,
      happyFrames:0,
    },
    key:{wx:keyCell.c*TILE+TILE/2, wy:keyCell.r*TILE+TILE/2, collected:false},
    door:{wx:(4.5)*TILE + TILE/2, wy:TILE*1.4},
    collectibles, dogs, interactables, secrets, humans,
    napSpots, stickers, hiddenRoom, fishTank,
    hasWateringCan: false, wateringCanItem: wateringCan,
    particles:[],
    joystick:{active:false,dx:0,dy:0},
    scratchPressed:false,
  };

  setHudMode('rpg');
  document.getElementById('game-canvas-wrap').style.display = 'block';
  document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
  if (raf) cancelAnimationFrame(raf);
  if (musicEnabled) startMusic();
  // Push watering can into collectibles list
  if (wateringCan) gs.collectibles.push(wateringCan);
  // Register hidden room trigger as a scratchable interactable
  if (hiddenRoom) {
    gs.interactables.push({
      type:'hiddenroom', emoji:hiddenRoom.emoji, wx:hiddenRoom.wx, wy:hiddenRoom.wy,
      active:true, broken:false, animTick:0, activated:false,
      _room: hiddenRoom,
    });
  }
  loadJournal();
  gameLoop();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GAME STATE & LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let gs = null, raf = null;
// Double-tap tracking for dash (PC)
const lastKeyTap = {}; // code -> timestamp of last tap
const DOUBLE_TAP_MS = 200;

// Swipe tracking for dash (mobile)
let swipeStart = null;
const SWIPE_MIN_DIST = 40;
const SWIPE_MAX_MS = 220;

const canvas = document.getElementById('gameCanvas');

// Zen garden mouse drag
canvas.addEventListener('mousedown', e => {
  if (topiaryState?.running) {
    const rect=canvas.getBoundingClientRect();
    const scaleX=CW/rect.width, scaleY=CH/rect.height;
    topiaryHandleStart((e.clientX-rect.left)*scaleX,(e.clientY-rect.top)*scaleY);
    return;
  }
  if (!zenState?.running) return;
  const rect=canvas.getBoundingClientRect();
  const scaleX=CW/rect.width, scaleY=CH/rect.height;
  zenHandleStart((e.clientX-rect.left)*scaleX,(e.clientY-rect.top)*scaleY);
});
canvas.addEventListener('mousemove', e => {
  if (topiaryState?.running) {
    const rect=canvas.getBoundingClientRect();
    const scaleX=CW/rect.width, scaleY=CH/rect.height;
    topiaryHandleMove((e.clientX-rect.left)*scaleX,(e.clientY-rect.top)*scaleY);
    return;
  }
  if (!zenState?.running) return;
  const rect=canvas.getBoundingClientRect();
  const scaleX=CW/rect.width, scaleY=CH/rect.height;
  zenHandleMove((e.clientX-rect.left)*scaleX,(e.clientY-rect.top)*scaleY);
});
canvas.addEventListener('mouseup', () => { if(zenState?.running) zenHandleEnd(); if(topiaryState?.running) topiaryHandleEnd(); });
canvas.addEventListener('mouseleave', () => { if(zenState?.running) zenHandleEnd(); if(topiaryState?.running) topiaryHandleEnd(); });

// Scroll handling for help menu
canvas.addEventListener('wheel', e => {
  if (!helpOpen) return;
  e.preventDefault();
  const max = drawHelp._maxScroll || 0;
  helpScroll = Math.max(0, Math.min(max, helpScroll + e.deltaY * 0.4));
}, { passive: false });

// Touch scroll for help menu
let helpTouchY = null;
canvas.addEventListener('touchstart', e => {
  if (!helpOpen) return;
  helpTouchY = e.touches[0].clientY;
}, { passive: true });
canvas.addEventListener('touchmove', e => {
  if (!helpOpen || helpTouchY === null) return;
  const dy = helpTouchY - e.touches[0].clientY;
  helpTouchY = e.touches[0].clientY;
  const max = drawHelp._maxScroll || 0;
  helpScroll = Math.max(0, Math.min(max, helpScroll + dy * 1.2));
}, { passive: true });
canvas.addEventListener('touchend', e => {
  helpTouchY = null;
  if (zenState?.running) zenHandleEnd();
  if (topiaryState?.running) topiaryHandleEnd();
});

// Zen garden drag (touchmove on canvas)
canvas.addEventListener('touchmove', e => {
  if (topiaryState?.running) {
    e.preventDefault();
    const rect=canvas.getBoundingClientRect();
    const scaleX=CW/rect.width, scaleY=CH/rect.height;
    const t=e.touches[0];
    topiaryHandleMove((t.clientX-rect.left)*scaleX,(t.clientY-rect.top)*scaleY);
    return;
  }
  if (zenState?.running) {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const scaleX = CW/rect.width, scaleY = CH/rect.height;
    const t = e.touches[0];
    zenHandleMove((t.clientX-rect.left)*scaleX, (t.clientY-rect.top)*scaleY);
    return;
  }
}, {passive:false});

canvas.addEventListener('touchstart', e => {
  if (zenState?.running) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = CW/rect.width, scaleY = CH/rect.height;
    const t = e.touches[0];
    zenHandleStart((t.clientX-rect.left)*scaleX, (t.clientY-rect.top)*scaleY);
  }
  if (topiaryState?.running) {
    const rect=canvas.getBoundingClientRect();
    const scaleX=CW/rect.width, scaleY=CH/rect.height;
    const t=e.touches[0];
    topiaryHandleStart((t.clientX-rect.left)*scaleX,(t.clientY-rect.top)*scaleY);
  }
  // Soccer kickoff via tap when paused
  if (soccerState && !soccerState.running && !soccerState.winner) {
    const rect=canvas.getBoundingClientRect();
    const scaleX=CW/rect.width, scaleY=CH/rect.height;
    const t=e.touches[0];
    const mx=(t.clientX-rect.left)*scaleX, my=(t.clientY-rect.top)*scaleY;
    const bx=renderSoccer._kickBtnX||0,bw=renderSoccer._kickBtnW||140;
    const by=renderSoccer._kickBtnY||0,bh=renderSoccer._kickBtnH||36;
    if(mx>=bx&&mx<=bx+bw&&my>=by&&my<=by+bh){kickOff();}
  }
  if (fishState?.running || yarnState?.running || gardenState?.running) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = CW/rect.width, scaleY = CH/rect.height;
    const t = e.touches[0];
    const mx=(t.clientX-rect.left)*scaleX, my=(t.clientY-rect.top)*scaleY;
    if (fishState?.running)   fishHandleTap(mx,my);
    if (yarnState?.running)   yarnHandleTap(mx,my);
    if (gardenState?.running) gardenHandleTap(mx,my);
  }
}, {passive:true});
// Mini-game tap routing
canvas.addEventListener('click', e => {
  const rect = canvas.getBoundingClientRect();
  const scaleX = CW/rect.width, scaleY = CH/rect.height;
  const mx = (e.clientX-rect.left)*scaleX;
  const my = (e.clientY-rect.top)*scaleY;
  if (soccerState && !soccerState.running && !soccerState.winner) {
    const bx=renderSoccer._kickBtnX||0,bw=renderSoccer._kickBtnW||140;
    const by=renderSoccer._kickBtnY||0,bh=renderSoccer._kickBtnH||36;
    if(mx>=bx&&mx<=bx+bw&&my>=by&&my<=by+bh){kickOff();return;}
  }
  if (zenState?.running)    { zenHandleStart(mx,my); return; }
  if (fishState?.running)   { fishHandleTap(mx,my); return; }
  if (yarnState?.running)   { yarnHandleTap(mx,my); return; }
  if (gardenState?.running)  { gardenHandleTap(mx,my); return; }
  // topiaryState handled via mousedown/touchstart, not click
});

// Click anywhere on help overlay to close
canvas.addEventListener('click', e => {
  if (!helpOpen) return;
  const rect = canvas.getBoundingClientRect();
  const scaleX = CW / rect.width, scaleY = CH / rect.height;
  const mx = (e.clientX - rect.left) * scaleX;
  const my = (e.clientY - rect.top) * scaleY;
  const pw = 310, ph = 410;
  const px = (CW-pw)/2, py = (CH-ph)/2;
  // Click X button or outside panel closes it
  const onX = mx > px+pw-30 && mx < px+pw-4 && my > py+10 && my < py+42;
  const outside = mx < px || mx > px+pw || my < py || my > py+ph;
  if (onX || outside) helpOpen = false;
});

const ctx = canvas.getContext('2d');
const keys = {};

window.addEventListener('keydown', e => {
  const wasDown = keys[e.code];
  keys[e.code] = true;
  if ((e.code==='KeyX'||e.code==='KeyZ') && gs?.running) {
    doScratch();
    if (gs.hasWateringCan) tryWaterPlant(gs.cat);
  }
  if (e.code==='KeyP') takePhoto();
  if (e.code==='KeyJ') toggleJournal();
  if (e.code==='KeyH') toggleHelp();
  if ((e.code==='Space'||e.code==='Enter') && soccerState && !soccerState.running && !soccerState.winner) kickOff();
  if (e.code==='Space') e.preventDefault();
  // Double-tap dash detection
  if (!wasDown && gs?.running) {
    const DASH_KEYS = ['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','KeyA','KeyD','KeyW','KeyS'];
    if (DASH_KEYS.includes(e.code)) {
      const now = Date.now();
      if (lastKeyTap[e.code] && now - lastKeyTap[e.code] < DOUBLE_TAP_MS) {
        triggerDash(e.code);
        lastKeyTap[e.code] = 0;
      } else {
        lastKeyTap[e.code] = now;
      }
    }
  }
});
window.addEventListener('keyup', e => keys[e.code] = false);

// Joystick
const jZone = document.getElementById('joystick-zone');
const jKnob = document.getElementById('joystick-knob');
let jTouch = null;
const JR = 52;
jZone.addEventListener('touchstart', e => {
  e.preventDefault(); const t = e.changedTouches[0];
  const rect = jZone.getBoundingClientRect();
  jTouch = {id:t.identifier, cx:rect.left+rect.width/2, cy:rect.top+rect.height/2};
  swipeStart = {x:t.clientX, y:t.clientY, time:Date.now()};
  updateJoystick(t.clientX, t.clientY);
}, {passive:false});
jZone.addEventListener('touchmove', e => {
  e.preventDefault();
  for (const t of e.changedTouches) if (jTouch && t.identifier===jTouch.id) updateJoystick(t.clientX, t.clientY);
}, {passive:false});
['touchend','touchcancel'].forEach(ev => jZone.addEventListener(ev, e => {
  for (const t of e.changedTouches) if (jTouch && t.identifier===jTouch.id) {
    jTouch = null;
    if (gs) gs.joystick = {active:false,dx:0,dy:0};
    if (soccerState) soccerState.joystick = {active:false,dx:0,dy:0};
    jKnob.style.transform = 'translate(-50%,-50%)';
    // Swipe-to-dash detection
    if (swipeStart && (gs?.running || soccerState?.running)) {
      const elapsed = Date.now() - swipeStart.time;
      const sdx = t.clientX - swipeStart.x, sdy = t.clientY - swipeStart.y;
      const sdist = Math.hypot(sdx, sdy);
      if (elapsed < SWIPE_MAX_MS && sdist > SWIPE_MIN_DIST) {
        const nx = sdx/sdist, ny = sdy/sdist;
        if (soccerState?.running) {
          // In soccer: directly blast the ball if player is near it
          const p = soccerState.player, b = soccerState.ball;
          const bdist = Math.hypot(b.x-p.x, b.y-p.y);
          if (bdist < 60) {
            // Push ball away hard in swipe direction
            b.vx = nx * 18;
            b.vy = ny * 18;
            b.x = p.x + nx*(b.r+p.r+1);
            b.y = p.y + ny*(b.r+p.r+1);
            playSoccerKick();
            // Visual dash on player too
            p.dashDx=nx; p.dashDy=ny; p.dashFrames=6; p.dashCooldown=30;
          } else {
            triggerDash(null, nx, ny);
          }
        } else {
          triggerDash(null, nx, ny);
        }
      }
    }
    swipeStart = null;
  }
}));
function updateJoystick(cx, cy) {
  if (!jTouch) return;
  let dx=cx-jTouch.cx, dy=cy-jTouch.cy;
  const d = Math.hypot(dx,dy); if (d>JR) {dx=dx/d*JR; dy=dy/d*JR;}
  jKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
  if (gs) gs.joystick = {active:true, dx:dx/JR, dy:dy/JR};
  if (soccerState) soccerState.joystick = {active:true, dx:dx/JR, dy:dy/JR};
}
function onScratchDown(e) { e.preventDefault(); if (soccerState && !soccerState.running && !soccerState.winner) { kickOff(); } else if (gs?.running) doScratch(); document.getElementById('scratch-btn').classList.add('pressed'); }
function onScratchUp(e)   { e.preventDefault(); document.getElementById('scratch-btn').classList.remove('pressed'); }

function triggerDash(keyCode, nx, ny) {
  // Soccer mode dash
  if (soccerState?.running) {
    const p = soccerState.player;
    if (p.dashFrames > 0 || p.dashCooldown > 0) return;
    let dx = nx||0, dy = ny||0;
    if (keyCode) {
      if (keyCode==='ArrowLeft'||keyCode==='KeyA')  { dx=-1; dy=0; }
      if (keyCode==='ArrowRight'||keyCode==='KeyD') { dx=1;  dy=0; }
      if (keyCode==='ArrowUp'||keyCode==='KeyW')    { dx=0;  dy=-1; }
      if (keyCode==='ArrowDown'||keyCode==='KeyS')  { dx=0;  dy=1; }
    }
    const dl = Math.hypot(dx,dy)||1; dx/=dl; dy/=dl;
    p.dashDx=dx; p.dashDy=dy; p.dashFrames=14; p.dashCooldown=90;
    p.justDashed=true;
    playDash();
    return;
  }
  if (!gs || gs.cat.dashFrames > 0 || gs.cat.dashCooldown > 0) return;
  let dx = nx||0, dy = ny||0;
  if (keyCode) {
    if (keyCode==='ArrowLeft'||keyCode==='KeyA')  { dx=-1; dy=0; }
    if (keyCode==='ArrowRight'||keyCode==='KeyD') { dx=1;  dy=0; }
    if (keyCode==='ArrowUp'||keyCode==='KeyW')    { dx=0;  dy=-1; }
    if (keyCode==='ArrowDown'||keyCode==='KeyS')  { dx=0;  dy=1; }
  }
  const dl = Math.hypot(dx,dy)||1; dx/=dl; dy/=dl;
  gs.cat.dashDx = dx; gs.cat.dashDy = dy;
  gs.cat.dashFrames = DASH_FRAMES;
  gs.cat.dashCooldown = DASH_COOLDOWN;
  playDash();
  // Spawn trail ghosts
  for (let i=0; i<5; i++) {
    gs.particles.push({
      wx:gs.cat.wx - dx*i*8, wy:gs.cat.wy - dy*i*8,
      vx:0, vy:0, life:0.7-i*0.12, size:24-i*2,
      emoji:null, isDashTrail:true,
      col:CAT_COLORS[catCfg.colorIdx].body,
      alpha:0.55-i*0.1,
    });
  }
}

function doScratch() {
  if (!gs || gs.cat.scratchCooldown > 0) return;
  gs.cat.scratchCooldown = SCRATCH_COOLDOWN;
  gs.cat.scratchActive = true;
  gs.energy = Math.max(0, gs.energy - 1);
  playMeow();
  checkScratchHits();
}


function checkScratchHits() {
  const cat = gs.cat;
  const fa = cat.facingAngle - Math.PI/2; // actual world direction

  // Friendly cats react to nearby scratch (gentle)
  for (const fc of gs.dogs) {
    const dx=fc.wx-cat.wx, dy=fc.wy-cat.wy;
    const dist=Math.hypot(dx,dy);
    if (dist>SCRATCH_RANGE) continue;
    if (fc.touchCooldown>0) continue;
    const angle=Math.atan2(dy,dx);
    const diff=Math.abs(normaliseAngle(angle-fa));
    if (diff>SCRATCH_ARC/2) continue;
    fc.touchCooldown=60; fc.heartAnim=55;
    playFriendCatSound(fc.sound);
    spawnParticles(fc.wx, fc.wy-10, 'ğŸ’•');
    break;
  }


  // Check interactables
  for (const obj of gs.interactables) {
    if (!obj.active || obj.type==='movingPlatform') continue;
    const dx=obj.wx-cat.wx, dy=obj.wy-cat.wy;
    const dist = Math.hypot(dx,dy);
    if (dist > SCRATCH_RANGE) continue;
    const angle = Math.atan2(dy,dx);
    const diff = Math.abs(normaliseAngle(angle - fa));
    if (diff > SCRATCH_ARC/2) continue;
    activateInteractable(obj);
  }
}

function normaliseAngle(a) {
  while (a > Math.PI) a -= Math.PI*2;
  while (a < -Math.PI) a += Math.PI*2;
  return a;
}

function activateInteractable(obj) {
  if (obj.type === 'hiddenroom') {
    if (!obj.activated) {
      obj.activated = true;
      obj._room.open = true; obj._room.openAnim = 0; obj._room.activated = true;
      spawnParticles(obj.wx, obj.wy, 'âœ¨');
      spawnParticles(obj.wx, obj.wy, 'ğŸŒŸ');
      spawnPop(obj.wx, obj.wy, 'Secret room! ğŸŒŸ', '#ce93d8');
      playDoorOpen();
    }
    return;
  }
  if (obj.type === 'plant' && obj.wilted) { tryWaterPlant(gs.cat); return; }

  obj.animTick = 20;
  if (obj.type==='box'||obj.type==='luggage') {
    obj.active = false; obj.broken = true;
    spawnPop(obj.wx, obj.wy, 'ğŸ’¥ Smash!', '#f48fb1');
    spawnParticles(obj.wx, obj.wy, obj.brokenEmoji||'âœ¨');
    playBreak();
  } else if (obj.type==='plant') {
    obj.active = false; obj.broken = true;
    spawnPop(obj.wx, obj.wy, 'ğŸŒ¿ Whoosh!', '#a5d6a7');
    spawnParticles(obj.wx, obj.wy, 'ğŸŒ¸');
    playBreak();
  } else if (obj.type==='feeder') {
    obj.active = false; obj.broken = true;
    spawnPop(obj.wx, obj.wy, 'ğŸ¦ Fly away!', '#81d4fa');
    spawnParticles(obj.wx, obj.wy, 'ğŸ¦');
    playBreak();
  } else if (obj.type==='lamp') {
    obj.toggled = !obj.toggled; obj.animTick = 15;
    spawnPop(obj.wx, obj.wy, obj.toggled?'ğŸ’¡ On!':'ğŸŒ‘ Off!', '#ffe082');
    playLeverClick();
  } else if (obj.type==='vending') {
    if (!obj.used) {
      obj.used = true; obj.animTick = 30;
      playCollect();
      // Drop food collectible nearby
      gs.collectibles.push({
        type:'food', emoji:'ğŸ¥¤', pts:15, en:35, collected:false,
        wx:obj.wx+20, wy:obj.wy+20,
        moveSpeed:0, moveDir:1, moveMin:obj.wx, moveMax:obj.wx+TILE, bob:0, golden:false,
      });
      spawnPop(obj.wx, obj.wy, 'ğŸ¥¤ Snack!', '#66bb6a');
      spawnParticles(obj.wx, obj.wy, 'ğŸ¥¤');
    } else {
      spawnPop(obj.wx, obj.wy, 'Empty!', '#bdbdbd');
    }
  } else if (obj.type==='lever') {
    obj.activated = !obj.activated; obj.animTick = 20;
    playLeverClick();
    // Find linked platform and toggle it
    const plat = gs.interactables.find(p => p.type==='movingPlatform' && p.platformId===obj.platformId);
    if (plat) {
      plat.running = obj.activated;
      if (plat.running) playPlatformStart();
      spawnPop(obj.wx, obj.wy, obj.activated?'âš™ï¸ Platform ON!':'âš™ï¸ Platform OFF!', '#ce93d8');
    }
  }
}

function gameLoop() {
  if (!gs || !gs.running) return;
  raf = requestAnimationFrame(gameLoop);
  gs.time++;
  update();
  render();
}

function update() {
  const cat = gs.cat;
  const d = {catCount:1};
  const t = gs.time;

  // Movement
  let ix=0, iy=0;
  if (keys['ArrowLeft']||keys['KeyA']) ix -= 1;
  if (keys['ArrowRight']||keys['KeyD']) ix += 1;
  if (keys['ArrowUp']||keys['KeyW']) iy -= 1;
  if (keys['ArrowDown']||keys['KeyS']) iy += 1;
  if (gs.joystick.active) { ix += gs.joystick.dx; iy += gs.joystick.dy; }
  const len = Math.hypot(ix,iy); if (len>1) {ix/=len; iy/=len;}
  cat.moving = len > 0.1;
  if (cat.moving) cat.facingAngle = Math.atan2(iy,ix) + Math.PI/2;

  // Moving platform riding
  cat.onPlatform = null;
  for (const obj of gs.interactables) {
    if (obj.type!=='movingPlatform'||!obj.running) continue;
    // Move platform
    obj.wx += obj.dir * obj.speed;
    if (obj.wx >= obj.endX||obj.wx <= obj.startX) obj.dir *= -1;
    // Check if cat is standing on it
    if (Math.abs(cat.wx-obj.wx)<obj.w/2 && Math.abs(cat.wy-obj.wy)<22) {
      cat.onPlatform = obj;
      cat.wx += obj.dir * obj.speed;
    }
  }

  // Dash movement
  if (cat.dashCooldown > 0) cat.dashCooldown--;
  if (cat.dashFrames > 0) {
    cat.dashFrames--;
    const dashSpd = DASH_SPEED * (cat.happyFrames>0?HAPPY_SPEED_MULT:1);
    cat.wx += cat.dashDx * dashSpd;
    cat.wy += cat.dashDy * dashSpd;
    cat.wx = Math.max(TILE*1.1, Math.min(COLS*TILE-TILE*1.1, cat.wx));
    cat.wy = Math.max(TILE*1.1, Math.min(gs.R*TILE-TILE*1.1, cat.wy));
    if (catHitsWall(cat.wx, cat.wy)) { cat.wx -= cat.dashDx*dashSpd; cat.wy -= cat.dashDy*dashSpd; cat.dashFrames=0; }
    // Spawn trail particle each dash frame
    if (cat.dashFrames % 3 === 0) {
      gs.particles.push({wx:cat.wx, wy:cat.wy, vx:0, vy:0, life:0.5, size:20, emoji:null,
        isDashTrail:true, col:CAT_COLORS[catCfg.colorIdx].body, alpha:0.4});
    }
    resolveCollisions(cat);
  } else {
    // Happy speed boost
    const spd = CAT_SPEED * (cat.happyFrames>0?HAPPY_SPEED_MULT:1);
    // Apply movement one axis at a time â€” stops cleanly, no bounce
    cat.wx += ix * spd;
    cat.wx = Math.max(TILE*1.1, Math.min(COLS*TILE - TILE*1.1, cat.wx));
    if (catHitsWall(cat.wx, cat.wy)) cat.wx -= ix * spd;

    cat.wy += iy * spd;
    cat.wy = Math.max(TILE*1.1, Math.min(gs.R*TILE - TILE*1.1, cat.wy));
    if (catHitsWall(cat.wx, cat.wy)) cat.wy -= iy * spd;

    resolveCollisions(cat);
  }
  // Tick happy
  if (cat.happyFrames > 0) cat.happyFrames--;

  // Scratch cooldown
  if (cat.scratchCooldown > 0) cat.scratchCooldown--;

  // Camera
  const targetCamY = cat.wy - CH * 0.62;
  gs.camY += (targetCamY - gs.camY) * 0.09;
  gs.camY = Math.max(0, Math.min(gs.R * TILE - CH, gs.camY));

  // Key pickup
  if (!gs.key.collected) {
    if (Math.hypot(cat.wx-gs.key.wx, cat.wy-gs.key.wy) < 24) {
      gs.key.collected=true; gs.hasKey=true;
      playKeyPickup();
      spawnPop(gs.key.wx, gs.key.wy, 'ğŸ—ï¸ Found the key!', '#ffd700');
      spawnParticles(gs.key.wx, gs.key.wy, 'âœ¨');
      document.getElementById('key-indicator').textContent='ğŸ—ï¸ âœ“';
    }
  }

  // Door
  const dd = Math.hypot(cat.wx-gs.door.wx, cat.wy-gs.door.wy);
  if (dd < 38) {
    if (gs.hasKey) {
      playDoorOpen(); gs.running=false; showLevelComplete(); return;
    } else if (!gs.doorShake) {
      gs.doorShake=30;
      spawnPop(gs.door.wx, gs.door.wy, 'ğŸ”‘ Need the key!', '#ff7043');
    }
  }
  if (gs.doorShake>0) gs.doorShake--;

  // Collectibles
  for (const c of gs.collectibles) {
    if (c.collected) continue;
    if (c.moveSpeed>0) {
      // Flee from cat when nearby
      const mouseDist = Math.hypot(cat.wx-c.wx, cat.wy-c.wy);
      const fleeing = mouseDist < 100;
      const spd = c.moveSpeed * (fleeing ? 1.3 : 1);

      // Try moving in current direction; also drift vertically for 2D roaming
      if (!c.vy) c.vy = (Math.random()-0.5)*0.8;
      if (fleeing) {
        // Run directly away from cat
        const fx = c.wx-cat.wx, fy = c.wy-cat.wy;
        const fl = Math.hypot(fx,fy)||1;
        c.wx += fx/fl * spd;
        c.wy += fy/fl * spd;
        c.moveDir = fx > 0 ? 1 : -1;
      } else {
        c.wx += c.moveDir * spd;
        c.wy += c.vy;
        // Occasionally change vertical drift
        if (Math.random() < 0.01) c.vy = (Math.random()-0.5)*1.2;
      }

      // Check if mouse is now inside a solid tile â€” teleport to a random floor cell ("mouse hole")
      const mgr = Math.floor(c.wy/TILE), mgc = Math.floor(c.wx/TILE);
      const inWall = mgr<0||mgr>=gs.R||mgc<0||mgc>=COLS ||
                     gs.grid[mgr][mgc]===1||gs.grid[mgr][mgc]===2||gs.grid[mgr][mgc]===3;
      const outOfBounds = c.wx<TILE||c.wx>(COLS-1)*TILE||c.wy<TILE||c.wy>(gs.R-1)*TILE;
      if (inWall||outOfBounds) {
        // Mouse pops out of a random floor tile (mouse hole!)
        const floorCells=[];
        for(let r=2;r<gs.R-2;r++) for(let cc=1;cc<COLS-1;cc++) if(gs.grid[r][cc]===0) floorCells.push({r,cc});
        if(floorCells.length>0){
          const pick=floorCells[Math.floor(Math.random()*floorCells.length)];
          c.wx=pick.cc*TILE+TILE/2; c.wy=pick.r*TILE+TILE/2;
        }
        c.moveDir*=-1; c.vy=(Math.random()-0.5)*0.8;
      }
    }
    if (Math.hypot(cat.wx-c.wx, cat.wy-c.wy)<20) {
      c.collected=true;
      if (c.type === 'wateringcan') {
        gs.hasWateringCan = true;
        playCollect();
        spawnPop(c.wx, c.wy, 'ğŸª£ Watering can!', '#80cbc4');
        spawnParticles(c.wx, c.wy, 'ğŸ’§');
      } else {
        playCollect();
        spawnPop(c.wx, c.wy, c.golden?'âœ¨ Shiny!':'Yay!', c.golden?'#ffd700':'#ce93d8');
        spawnParticles(c.wx, c.wy, c.golden?'âœ¨':'ğŸŒ¸');
      }
    }
  }

  updateDogs();
  updateSecrets();
  updateStickerPickup();
  updateNapSpots();
  checkFishTank();
  updateWeather();
  updateHumans();
  updateHUD();
}

function updateHumans() {
  if (!gs.humans) return;
  const cat = gs.cat;
  for (const h of gs.humans) {
    if (h.offerCooldown > 0) h.offerCooldown--;
    if (h.giftAnim > 0) h.giftAnim--;

    const dist = Math.hypot(cat.wx - h.wx, cat.wy - h.wy);

    if (dist < 48 && h.offerCooldown === 0) {
      // Give gift to cat
      h.state = 'offering';
      h.giftAnim = 40;
      h.offerCooldown = 300; // 5s cooldown before offering again
      h.facingAngle = Math.atan2(cat.wy - h.wy, cat.wx - h.wx) + Math.PI/2;
      h.moving = false;

      if (h.gift === 'treat') {
          playCollect();
          spawnPop(h.wx, h.wy, 'ğŸŸ Snack!', '#f48fb1');
          spawnParticles(h.wx, h.wy, 'ğŸŸ');
          spawnParticles(h.wx, h.wy, 'ğŸ’•');
      } else {
        // Pet â€” give happiness boost
        cat.happyFrames = HAPPY_DURATION;
        playPurr();
        spawnPop(h.wx, h.wy, 'ğŸŒˆ Good kitty!', '#ce93d8');
        spawnParticles(h.wx, h.wy, 'ğŸŒˆ');
        spawnParticles(cat.wx, cat.wy, 'âœ¨');
      }
    } else if (dist >= 48) {
      h.state = 'wander';
    }

    if (h.state === 'wander') {
      h.wanderTimer--;
      if (h.wanderTimer <= 0) {
        h.wanderAngle += (Math.random()-0.5)*1.1;
        h.wanderTimer = 80 + Math.floor(Math.random()*120);
      }
      const spd = 0.4;
      const nx = Math.cos(h.wanderAngle)*spd, ny = Math.sin(h.wanderAngle)*spd;
      h.wx += nx; h.wy += ny;
      h.moving = Math.abs(nx)+Math.abs(ny) > 0.05;
      if (h.moving) h.facingAngle = Math.atan2(ny, nx) + Math.PI/2;
      // Clamp to world
      h.wx = Math.max(TILE*1.5, Math.min((COLS-1)*TILE-TILE*1.5, h.wx));
      h.wy = Math.max(TILE*1.5, Math.min((gs.R-1)*TILE-TILE*1.5, h.wy));
      // Bounce off walls
      const hgr = Math.floor(h.wy/TILE), hgc = Math.floor(h.wx/TILE);
      if (hgr>=0&&hgr<gs.R&&hgc>=0&&hgc<COLS && (gs.grid[hgr][hgc]===1||gs.grid[hgr][hgc]===2||gs.grid[hgr][hgc]===3)) {
        h.wx -= nx; h.wy -= ny;
        h.wanderAngle += Math.PI * (0.5 + Math.random()*0.5);
      }
    }
  }
}


function updateSecrets() {
  if (!gs.secrets) return;
  const cat = gs.cat;
  for (const s of gs.secrets) {
    if (s.collected) continue;
    const dist = Math.hypot(cat.wx-s.wx, cat.wy-s.wy);
    if (dist < 30) s.revealed = true;
    if (dist < 20 && s.revealed) {
      s.collected = true;
      playKeyPickup(); // nice chime for secret find
      spawnPop(s.wx, s.wy, 'ğŸ” Secret found! âœ¨', '#ffd700');
      spawnParticles(s.wx, s.wy, 'âœ¨');
      spawnParticles(s.wx, s.wy, s.emoji);
    }
  }
}

// Returns true if the cat circle at (wx,wy) overlaps any solid tile
function catHitsWall(wx, wy) {
  const R2 = 13;
  const probes = [[R2,0],[-R2,0],[0,R2],[0,-R2],[R2,R2*.7],[-R2,R2*.7],[R2,-R2*.7],[-R2,-R2*.7]];
  for (const [dx,dy] of probes) {
    const gr = Math.floor((wy+dy)/TILE);
    const gc = Math.floor((wx+dx)/TILE);
    if (gr<0||gr>=gs.R||gc<0||gc>=COLS) return true;
    const t = gs.grid[gr][gc];
    if (t===1||t===2||t===3) return true;
  }
  return false;
}

function resolveCollisions(cat) {
  const R2 = 13;
  // Fine-grain snap: push cat out of any overlapping solid tile
  const probes = [[R2,0],[-R2,0],[0,R2],[0,-R2],[R2,R2*.7],[-R2,R2*.7],[R2,-R2*.7],[-R2,-R2*.7]];
  for (let pass=0; pass<3; pass++) {
    for (const [dx,dy] of probes) {
      const gr = Math.floor((cat.wy+dy)/TILE);
      const gc = Math.floor((cat.wx+dx)/TILE);
      if (gr<0||gr>=gs.R||gc<0||gc>=COLS) continue;
      const tile = gs.grid[gr][gc];
      if (tile!==1&&tile!==2&&tile!==3) continue;
      // Compute overlap and push out along minimum axis
      const tileX = gc*TILE + TILE/2, tileY = gr*TILE + TILE/2;
      const overlapX = (R2 + TILE/2) - Math.abs(cat.wx - tileX);
      const overlapY = (R2 + TILE/2) - Math.abs(cat.wy - tileY);
      if (overlapX > 0 && overlapY > 0) {
        if (overlapX < overlapY) {
          cat.wx += cat.wx < tileX ? -overlapX : overlapX;
        } else {
          cat.wy += cat.wy < tileY ? -overlapY : overlapY;
        }
      }
    }
  }
  // Solid interactables (unbroken boxes/luggage)
  for (const obj of gs.interactables) {
    if (obj.type==='movingPlatform'||!obj.active||obj.broken) continue;
    if (obj.type!=='box'&&obj.type!=='luggage') continue;
    const dx2=cat.wx-obj.wx, dy2=cat.wy-obj.wy;
    const half = TILE*0.55;
    if (Math.abs(dx2)<half && Math.abs(dy2)<half) {
      if (Math.abs(dx2) >= Math.abs(dy2)) cat.wx = obj.wx + (dx2>0?half:-half);
      else cat.wy = obj.wy + (dy2>0?half:-half);
    }
  }
  cat.wx = Math.max(TILE+R2, Math.min((COLS-1)*TILE-R2, cat.wx));
  cat.wy = Math.max(TILE+R2, Math.min((gs.R-1)*TILE-R2, cat.wy));
}

function updateDogs() { // friendly cats
  const cat = gs.cat;
  for (const fc of gs.dogs) {
    if (fc.heartAnim > 0) fc.heartAnim--;
    if (fc.touchCooldown > 0) fc.touchCooldown--;

    // Wander gently
    fc.wanderTimer--;
    if (fc.wanderTimer <= 0) {
      fc.wanderAngle += (Math.random()-0.5)*1.1;
      fc.wanderTimer = 90 + Math.floor(Math.random()*160);
    }
    const nx = Math.cos(fc.wanderAngle)*fc.speed*0.32;
    const ny = Math.sin(fc.wanderAngle)*fc.speed*0.32;
    fc.wx += nx; fc.wy += ny;
    if (Math.abs(nx)+Math.abs(ny)>0.05) fc.facingAngle = Math.atan2(ny,nx)+Math.PI/2;

    // Clamp + wall bounce
    fc.wx = Math.max(TILE*1.5, Math.min((COLS-1)*TILE-TILE*1.5, fc.wx));
    fc.wy = Math.max(TILE*1.5, Math.min((gs.R-1)*TILE-TILE*1.5, fc.wy));
    const fgr=Math.floor(fc.wy/TILE), fgc=Math.floor(fc.wx/TILE);
    if (fgr>=0&&fgr<gs.R&&fgc>=0&&fgc<COLS &&
        (gs.grid[fgr][fgc]===1||gs.grid[fgr][fgc]===2||gs.grid[fgr][fgc]===3)) {
      fc.wx -= nx; fc.wy -= ny;
      fc.wanderAngle += Math.PI*(0.5+Math.random()*0.5);
    }

    // Touch detection â€” play sound + show heart
    const dist = Math.hypot(cat.wx-fc.wx, cat.wy-fc.wy);
    if (dist < 28 && fc.touchCooldown === 0) {
      fc.touchCooldown = 90;
      fc.heartAnim = 55;
      playFriendCatSound(fc.sound);
      spawnParticles(fc.wx, fc.wy-10, 'ğŸ’•');
    }
    // Soft nudge so cats don't overlap player
    if (dist < 26) {
      const ex=(cat.wx-fc.wx)/(dist||1), ey=(cat.wy-fc.wy)/(dist||1);
      cat.wx += ex*1.0; cat.wy += ey*1.0;
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RENDER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function render() {
  ctx.clearRect(0,0,CW,CH);
  ctx.save(); ctx.translate(0, -gs.camY);
  const camY=gs.camY, def=gs.def;
  const startR=Math.max(0,Math.floor(camY/TILE)-1);
  const endR=Math.min(gs.R,startR+Math.ceil(CH/TILE)+2);

  // Tiles
  for (let r=startR; r<endR; r++)
    for (let c=0; c<COLS; c++)
      drawTile(c*TILE, r*TILE, gs.grid[r][c], def, r, c);

  // Moving platforms (draw under everything)
  for (const obj of gs.interactables) {
    if (obj.type!=='movingPlatform') continue;
    drawMovingPlatform(obj, def);
  }

  // Door
  drawDoor(gs.door.wx, gs.door.wy, def, gs.hasKey, gs.doorShake, gs.time);

  // Key
  if (!gs.key.collected) drawKey(gs.key.wx, gs.key.wy, gs.time);

  // Collectibles
  for (const c of gs.collectibles) if (!c.collected) drawCollectible(c, gs.time);

  // Interactables
  for (const obj of gs.interactables) {
    if (obj.type!=='movingPlatform') drawInteractable(obj, gs.time);
  }

  // Dogs
  for (const dog of gs.dogs) if (dog.state!=='gone') drawDogTopDown(dog, gs.time, gs.cat);

  // Humans
  if (gs.humans) for (const h of gs.humans) drawHuman(h, gs.time);

  // Secrets (hidden until near)
  if (gs.secrets) for (const s of gs.secrets) if (!s.collected) drawSecret(s, gs.time, gs.cat);

  // Nap spots (under cat)
  if (gs.napSpots) drawNapSpots(gs.time);
  // Fish tank
  drawFishTank(gs.time);
  // Hidden room
  drawHiddenRoom(gs.time);
  // Sticker items
  drawStickerItems(gs.time);

  // Dash trail (behind cat)
  drawDashTrail();

  // Rainbow glow (under cat, above trail)
  if (gs.cat.happyFrames > 0) drawRainbowGlow(gs.cat.wx, gs.cat.wy, gs.time, gs.cat.happyFrames);

  // Cat
  drawCatTopDown(ctx, gs.cat.wx, gs.cat.wy, catCfg, gs.time, gs.cat.facingAngle, gs.cat.moving, gs.cat.scratchCooldown);

  // Particles
  drawParticles();
  ctx.restore();

  // Progress bar (screen-space)
  drawProgress();
}

function drawTile(tx,ty,tile,def,r,c) {
  const alt=(r+c)%2===1;
  if (tile===0) {
    ctx.fillStyle=alt?def.floorTile.alt:def.floorTile.fill;
    ctx.fillRect(tx,ty,TILE,TILE);
    ctx.strokeStyle=def.floorTile.line; ctx.lineWidth=0.4;
    ctx.strokeRect(tx,ty,TILE,TILE);
  } else if (tile===1) {
    ctx.fillStyle=def.wallFill; ctx.fillRect(tx,ty,TILE,TILE);
    ctx.fillStyle='rgba(255,255,255,0.15)'; ctx.fillRect(tx,ty,TILE,3);
    const iconSets={home:['ğŸ›‹ï¸','ğŸ“¦','ğŸª‘','ğŸšª'],park:['ğŸŒ³','ğŸª¨','ğŸŒ¿','ğŸŒ²'],building:['ğŸ–¥ï¸','ğŸ“','ğŸª‘','ğŸ—„ï¸'],station:['ğŸ§³','ğŸ—‘ï¸','ğŸ“¦','ğŸª‘']};
    const icons=iconSets[def.theme]||['â¬œ'];
    ctx.font='18px serif'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.globalAlpha=0.65;
    ctx.fillText(icons[((r*COLS+c)*31)%icons.length],tx+TILE/2,ty+TILE/2); ctx.globalAlpha=1;
  } else if (tile===2) {
    ctx.fillStyle=def.elevFill; ctx.fillRect(tx,ty,TILE,TILE);
    ctx.strokeStyle=def.elevStroke; ctx.lineWidth=2.5; ctx.strokeRect(tx+1,ty+1,TILE-2,TILE-2);
    ctx.fillStyle='rgba(0,0,0,0.1)'; ctx.fillRect(tx+3,ty+TILE-4,TILE-3,4); ctx.fillRect(tx+TILE-4,ty+3,4,TILE-4);
    ctx.fillStyle='rgba(255,255,255,0.28)'; ctx.fillRect(tx,ty,TILE,3); ctx.fillRect(tx,ty,3,TILE);
  } else if (tile===3) {
    const wt=gs.time*0.025;
    const wc={home:'#b0bec5',park:'#81d4fa',building:'#263238',station:'#1a237e'};
    ctx.fillStyle=wc[def.theme]||'#90caf9'; ctx.fillRect(tx,ty,TILE,TILE);
    ctx.globalAlpha=0.25+Math.sin(wt+r+c)*0.1;
    ctx.fillStyle='rgba(255,255,255,0.4)';
    ctx.beginPath(); ctx.ellipse(tx+TILE*0.3,ty+TILE*0.45,7,3.5,wt,0,Math.PI*2); ctx.fill();
    ctx.globalAlpha=1;
  }
}

function drawMovingPlatform(obj, def) {
  const pw=obj.w, ph=obj.h+8;
  ctx.save(); ctx.translate(obj.wx-pw/2, obj.wy-ph/2);
  // Platform shadow
  ctx.fillStyle='rgba(0,0,0,0.12)'; ctx.fillRect(4,6,pw,ph);
  // Platform body
  const pColors={home:'#8d6e63',park:'#388e3c',building:'#455a64',station:'#4527a0'};
  ctx.fillStyle=pColors[def.theme]||'#795548';
  ctx.beginPath(); ctx.roundRect(0,0,pw,ph,6); ctx.fill();
  ctx.fillStyle='rgba(255,255,255,0.25)'; ctx.fillRect(0,0,pw,4);
  // Arrow showing direction
  ctx.fillStyle='rgba(255,255,255,0.5)'; ctx.font='12px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(obj.running?(obj.dir>0?'â†’':'â†'):'â¸', pw/2, ph/2);
  ctx.restore();
}

function drawInteractable(obj, t) {
  if (obj.type==='movingPlatform') return;
  ctx.save(); ctx.translate(obj.wx, obj.wy);
  const pulse = obj.animTick>0 ? (obj.animTick/20)*0.4 : 0;
  ctx.scale(1+pulse*0.3, 1+pulse*0.3);
  if (obj.animTick>0) obj.animTick--;

  if (obj.broken) {
    ctx.globalAlpha=0.5;
    ctx.font='18px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(obj.brokenEmoji||'ğŸ’¨',0,0);
  } else {
    ctx.font='22px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
    if (obj.type==='lamp') {
      ctx.fillText(obj.toggled?'ğŸ’¡':'ğŸ•¯ï¸',0,0);
      if (obj.toggled) {
        ctx.globalAlpha=0.15+Math.sin(t*0.1)*0.05;
        ctx.fillStyle='#ffe082'; ctx.beginPath(); ctx.arc(0,0,30,0,Math.PI*2); ctx.fill();
        ctx.globalAlpha=1;
      }
    } else if (obj.type==='lever') {
      ctx.fillText(obj.activated?'ğŸ”›':'ğŸ”§',0,0);
      // glow if activated
      if (obj.activated) {
        ctx.globalAlpha=0.2+Math.sin(t*0.12)*0.1;
        ctx.fillStyle='#ce93d8'; ctx.beginPath(); ctx.arc(0,0,24,0,Math.PI*2); ctx.fill();
        ctx.globalAlpha=1;
      }
    } else {
      ctx.fillText(obj.emoji,0,0);
    }
    // Interaction hint when nearby (handled below in render-hint pass)
  }
  ctx.restore();
}

function drawInteractableHints() {
  if (!gs) return;
  const cat = gs.cat;
  for (const obj of gs.interactables) {
    if (obj.type==='movingPlatform'||!obj.active||obj.broken) continue;
    const dist=Math.hypot(cat.wx-obj.wx, cat.wy-obj.wy);
    if (dist<70) {
      ctx.save(); ctx.translate(obj.wx, obj.wy-22);
      ctx.globalAlpha=0.7+Math.sin(gs.time*0.15)*0.3;
      ctx.font='bold 10px Nunito,sans-serif'; ctx.fillStyle='white';
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.beginPath(); ctx.roundRect(-16,-8,32,16,6); ctx.fill();
      ctx.fillStyle='white'; ctx.fillText('[!]',0,0);
      ctx.restore();
    }
  }
}

function drawDoor(wx,wy,def,hasKey,shake,t) {
  const x=wx+(shake>0?Math.sin(t*0.8)*(shake/5):0), y=wy;
  const dc={home:{frame:'#795548',panel:'#8d6e63'},park:{frame:'#388e3c',panel:'#4caf50'},building:{frame:'#455a64',panel:'#607d8b'},station:{frame:'#4527a0',panel:'#5e35b1'}};
  const c=dc[def.theme]||dc.home;
  ctx.save(); ctx.translate(x,y);
  ctx.fillStyle=c.frame; ctx.fillRect(-22,-30,44,54);
  ctx.fillStyle=hasKey?'#66bb6a':c.panel; ctx.fillRect(-17,-25,34,47);
  ctx.fillStyle='rgba(255,255,255,0.15)';
  ctx.fillRect(-13,-21,13,18); ctx.fillRect(2,-21,13,18);
  ctx.fillRect(-13,-1,13,18); ctx.fillRect(2,-1,13,18);
  ctx.fillStyle=hasKey?'#ffd700':'rgba(255,255,255,0.6)'; ctx.beginPath(); ctx.arc(10,4,4,0,Math.PI*2); ctx.fill();
  if (hasKey) {
    ctx.save(); ctx.globalAlpha=0.3+Math.sin(t*0.1)*0.12;
    ctx.fillStyle='#a5d6a7'; ctx.beginPath(); ctx.arc(0,0,30,0,Math.PI*2); ctx.fill(); ctx.restore();
  }
  ctx.font='bold 8px Nunito,sans-serif'; ctx.fillStyle=hasKey?'#2e7d32':'rgba(255,255,255,0.85)';
  ctx.textAlign='center'; ctx.textBaseline='bottom';
  ctx.fillText(hasKey?'OPEN':'ğŸ”’ LOCKED',0,-32);
  ctx.fillStyle=c.frame; ctx.beginPath(); ctx.arc(0,-30,22,Math.PI,2*Math.PI); ctx.fill();
  ctx.fillStyle=hasKey?'#a5d6a7':c.panel; ctx.beginPath(); ctx.arc(0,-30,17,Math.PI,2*Math.PI); ctx.fill();
  ctx.restore();
}

function drawKey(wx,wy,t) {
  ctx.save(); ctx.translate(wx,wy);

  // Large outer beacon glow â€” visible from far away
  const outerR = 34 + Math.sin(t*0.07)*6;
  const grd = ctx.createRadialGradient(0,0,4,0,0,outerR);
  grd.addColorStop(0,'rgba(255,220,0,0.45)');
  grd.addColorStop(0.5,'rgba(255,180,0,0.22)');
  grd.addColorStop(1,'rgba(255,160,0,0)');
  ctx.fillStyle=grd;
  ctx.beginPath(); ctx.arc(0,0,outerR,0,Math.PI*2); ctx.fill();

  // Pulsing solid ring
  ctx.strokeStyle=`rgba(255,215,0,${0.55+Math.sin(t*0.12)*0.35})`;
  ctx.lineWidth=2.5;
  ctx.beginPath(); ctx.arc(0,0,22+Math.sin(t*0.09)*4,0,Math.PI*2); ctx.stroke();

  // Second smaller ring, offset phase
  ctx.strokeStyle=`rgba(255,255,150,${0.4+Math.sin(t*0.12+2)*0.3})`;
  ctx.lineWidth=1.5;
  ctx.beginPath(); ctx.arc(0,0,15+Math.sin(t*0.11+1)*3,0,Math.PI*2); ctx.stroke();

  // Key emoji â€” larger, strong shadow
  ctx.shadowColor='#ffd700'; ctx.shadowBlur=18+Math.sin(t*0.1)*8;
  const s = 1.0+Math.sin(t*0.08)*0.1; ctx.scale(s,s);
  ctx.font='28px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText('ğŸ—ï¸',0,1);
  ctx.shadowBlur=0;

  // 4 orbiting sparkles
  ctx.globalAlpha=0.85;
  ctx.font='11px serif';
  for(let i=0;i<4;i++){
    const a = t*0.06 + i*Math.PI/2;
    const r = 28+Math.sin(t*0.1+i)*4;
    ctx.fillText(['âœ¨','â­','âœ¨','ğŸ’›'][i], Math.cos(a)*r, Math.sin(a)*r);
  }
  ctx.restore();
}

function drawCollectible(c,t) {
  const bob = Math.sin(t*0.07+c.bob)*3;
  ctx.save();
  ctx.translate(c.wx, c.wy+bob);

  // Glow ring underneath
  const isFood = c.type==='food';
  const isToy  = c.type==='toy'||c.type==='flower';
  const isMouse= c.type==='mouse'||c.type==='goldenmouse'||c.golden;
  const ringColor = isMouse?'#ffd700': isFood?'#f48fb1':'#ce93d8';
  const ringR = isMouse ? 18 : 14;
  const ringAlpha = 0.35 + Math.sin(t*0.1+c.bob)*0.18;
  ctx.globalAlpha = ringAlpha;
  ctx.fillStyle = ringColor;
  ctx.beginPath(); ctx.arc(0, 0, ringR, 0, Math.PI*2); ctx.fill();
  // Outer pulse ring
  const pulseR = ringR + 4 + Math.sin(t*0.08+c.bob)*4;
  ctx.globalAlpha = ringAlpha*0.4;
  ctx.beginPath(); ctx.arc(0, 0, pulseR, 0, Math.PI*2); ctx.fill();
  ctx.globalAlpha = 1;

  // Drop shadow for depth
  ctx.shadowColor = 'rgba(0,0,0,0.35)';
  ctx.shadowBlur = 6;
  ctx.shadowOffsetY = 3;

  // Golden glow
  if (isMouse) { ctx.shadowColor='#ffd700'; ctx.shadowBlur=14+Math.sin(t*0.1)*6; ctx.shadowOffsetY=0; }

  ctx.font = isMouse?'26px serif':'22px serif';
  ctx.textAlign='center'; ctx.textBaseline='middle';
  if (c.moveSpeed>0&&c.moveDir<0) ctx.scale(-1,1);
  ctx.fillText(c.emoji, 0, 0);
  ctx.restore();
}

function playFriendCatSound(soundType) {
  try {
    const ac = getAudio(), t = ac.currentTime;
    if (soundType === 'purr') {
      // Gentle purr â€” low rumbling sine
      const o = ac.createOscillator(), g = ac.createGain();
      const lfo = ac.createOscillator(), lg = ac.createGain();
      o.type='sine'; o.frequency.value=62;
      lfo.type='sine'; lfo.frequency.value=26; lg.gain.value=14;
      lfo.connect(lg); lg.connect(o.frequency);
      g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(0.18,t+0.08);
      g.gain.setValueAtTime(0.18,t+0.35); g.gain.exponentialRampToValueAtTime(0.001,t+0.55);
      o.connect(g); g.connect(ac.destination);
      o.start(t); o.stop(t+0.6); lfo.start(t); lfo.stop(t+0.6);
    } else if (soundType === 'mew') {
      // Short mew â€” higher pitch meow
      const o = ac.createOscillator(), g = ac.createGain();
      o.type='sine'; o.frequency.setValueAtTime(520,t); o.frequency.exponentialRampToValueAtTime(380,t+0.18);
      g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(0.16,t+0.03);
      g.gain.exponentialRampToValueAtTime(0.001,t+0.22);
      o.connect(g); g.connect(ac.destination); o.start(t); o.stop(t+0.25);
    } else if (soundType === 'chirp') {
      // Chirp trill â€” rapidly oscillating
      const o = ac.createOscillator(), g = ac.createGain();
      const trem = ac.createOscillator(), tg = ac.createGain();
      o.type='triangle'; o.frequency.value=680;
      trem.type='sine'; trem.frequency.value=22; tg.gain.value=0.12;
      trem.connect(tg); tg.connect(g.gain);
      g.gain.setValueAtTime(0.14,t); g.gain.exponentialRampToValueAtTime(0.001,t+0.28);
      o.connect(g); g.connect(ac.destination);
      o.start(t); o.stop(t+0.3); trem.start(t); trem.stop(t+0.3);
    } else {
      // trill â€” two-note warble
      [0, 0.1].forEach((dt,i) => {
        const o = ac.createOscillator(), g = ac.createGain();
        o.type='sine'; o.frequency.value = i===0?440:520;
        g.gain.setValueAtTime(0,t+dt); g.gain.linearRampToValueAtTime(0.14,t+dt+0.04);
        g.gain.exponentialRampToValueAtTime(0.001,t+dt+0.18);
        o.connect(g); g.connect(ac.destination); o.start(t+dt); o.stop(t+dt+0.2);
      });
    }
  } catch(e){}
}

function drawDogTopDown(fc, t, cat) {
  // Draw a friendly roaming cat
  const cfg = {colorIdx:fc.colorIdx, pattern:fc.pattern, eyeIdx:fc.eyeIdx, accessory:'none'};
  const bob = Math.sin(t*0.09 + fc.bob)*2;
  const moving = true; // always animate gently

  ctx.save();
  ctx.translate(fc.wx, fc.wy + bob);
  ctx.rotate(fc.facingAngle);

  // Soft shadow
  ctx.fillStyle='rgba(0,0,0,0.07)';
  ctx.beginPath(); ctx.ellipse(0,6,12,5,0,0,Math.PI*2); ctx.fill();

  // Reuse the main cat drawing but smaller
  ctx.scale(0.72, 0.72);
  drawCatTopDown(ctx, 0, 0, cfg, t + fc.bob*40, 0, true, 0);
  ctx.restore();

  // Name label (shows on nearby approach)
  const dist = Math.hypot(cat.wx-fc.wx, cat.wy-fc.wy);
  if (dist < 70) {
    ctx.save();
    ctx.globalAlpha = Math.min(1, (70-dist)/30);
    ctx.font = 'bold 9px Nunito, sans-serif';
    ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
    ctx.fillStyle = 'rgba(0,0,0,0.45)';
    ctx.fillText(fc.name, fc.wx+0.5, fc.wy-22+0.5);
    ctx.fillStyle = 'white';
    ctx.fillText(fc.name, fc.wx, fc.wy-22);
    ctx.restore();
  }

  // Heart animation when touched
  if (fc.heartAnim > 0) {
    const prog = fc.heartAnim/55;
    ctx.save();
    ctx.globalAlpha = prog * 0.9;
    ctx.font = `${10+prog*6}px serif`;
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText('ğŸ’•', fc.wx + Math.sin(fc.heartAnim*0.3)*8, fc.wy - 28 - (55-fc.heartAnim)*0.6);
    ctx.restore();
  }
}



function drawSecret(s, t, cat) {
  const dist = Math.hypot(cat.wx-s.wx, cat.wy-s.wy);
  const nearbyFactor = Math.max(0, 1-(dist/80)); // shimmer builds as you approach

  ctx.save();
  ctx.translate(s.wx, s.wy);

  if (s.revealed) {
    // Fully revealed â€” pulse and glow
    const pulse = 0.85 + Math.sin(t*0.1+s.bob)*0.18;
    ctx.save(); ctx.scale(pulse, pulse);
    ctx.shadowColor='#ffd700'; ctx.shadowBlur=14+Math.sin(t*0.1)*6;
    ctx.globalAlpha=1;
    ctx.font='22px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(s.emoji, 0, 0);
    ctx.restore();
    // Gold ring
    ctx.globalAlpha=0.4+Math.sin(t*0.12)*0.2;
    ctx.strokeStyle='#ffd700'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc(0,0,18,0,Math.PI*2); ctx.stroke();
    ctx.globalAlpha=1;
    // "SECRET" label
    ctx.font='bold 8px Nunito,sans-serif';
    ctx.fillStyle='#ffd700'; ctx.textAlign='center'; ctx.textBaseline='bottom';
    ctx.fillText('SECRET',0,-22);
  } else if (nearbyFactor > 0) {
    // Subtle shimmer hint when nearby â€” just barely visible
    ctx.globalAlpha = nearbyFactor * 0.35;
    ctx.fillStyle='#ffd700';
    // Sparkle particles at item location
    ctx.font='10px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
    const sparkAngle = t*0.08 + s.bob;
    ctx.fillText('âœ¨', Math.cos(sparkAngle)*10, Math.sin(sparkAngle)*10);
    ctx.fillText('âœ¨', Math.cos(sparkAngle+Math.PI)*8, Math.sin(sparkAngle+Math.PI)*8);
    ctx.globalAlpha=1;
  }
  ctx.restore();
}

function drawHuman(h, t) {
  const o = h.outfit;
  const bob = h.moving ? Math.sin(t*0.22)*1.5 : 0;
  const isOffering = h.state==='offering';
  const armWave = isOffering ? Math.sin(t*0.25)*0.4 : Math.sin(t*0.1)*0.15;

  ctx.save();
  ctx.translate(h.wx, h.wy + bob);
  ctx.rotate(h.facingAngle);

  // Shadow
  ctx.fillStyle='rgba(0,0,0,0.08)';
  ctx.beginPath(); ctx.ellipse(0,6,14,5,0,0,Math.PI*2); ctx.fill();

  // Legs
  const legSwing = h.moving ? Math.sin(t*0.2)*8 : 0;
  ctx.fillStyle=o.bottom; ctx.strokeStyle='rgba(0,0,0,0.15)'; ctx.lineWidth=1;
  [[-5,14+legSwing],[5,14-legSwing]].forEach(([lx,ly])=>{
    ctx.beginPath(); ctx.roundRect(lx-4,8,8,ly-8,3); ctx.fill(); ctx.stroke();
  });
  // Feet
  ctx.fillStyle='#5d4037';
  [[-5,14+legSwing],[5,14-legSwing]].forEach(([lx,ly])=>{
    ctx.beginPath(); ctx.ellipse(lx,ly+2,5,3,0,0,Math.PI*2); ctx.fill();
  });

  // Body
  ctx.fillStyle=o.top; ctx.strokeStyle='rgba(0,0,0,0.1)'; ctx.lineWidth=1.5;
  ctx.beginPath(); ctx.roundRect(-9,-4,18,13,4); ctx.fill(); ctx.stroke();

  // Arms
  ctx.fillStyle=o.top; ctx.strokeStyle='rgba(0,0,0,0.1)'; ctx.lineWidth=1;
  const leftArm = h.moving ? armWave : armWave;
  const rightArm = -leftArm;
  // Left arm
  ctx.save(); ctx.translate(-9,0); ctx.rotate(leftArm);
  ctx.beginPath(); ctx.roundRect(-4,0,8,10,3); ctx.fill(); ctx.stroke(); ctx.restore();
  // Right arm â€” if offering, extends forward holding gift
  ctx.save(); ctx.translate(9,0); ctx.rotate(isOffering ? -0.6 : rightArm);
  ctx.beginPath(); ctx.roundRect(-4,0,8,10,3); ctx.fill(); ctx.stroke();
  if (isOffering) {
    // Hand holding gift
    ctx.fillStyle=o.skin; ctx.beginPath(); ctx.arc(0,12,4,0,Math.PI*2); ctx.fill();
    ctx.font='11px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(h.gift==='treat'?'ğŸŸ':'ğŸ¤š',0,12);
  }
  ctx.restore();

  // Head
  ctx.fillStyle=o.skin; ctx.strokeStyle='rgba(0,0,0,0.12)'; ctx.lineWidth=1.5;
  ctx.beginPath(); ctx.arc(0,-12,10,0,Math.PI*2); ctx.fill(); ctx.stroke();

  // Hair â€” simple arc
  const hairColors=['#5d4037','#212121','#ffd54f','#ef9a9a','#b0bec5'];
  ctx.fillStyle=hairColors[Math.abs(h.wx*3|0)%hairColors.length];
  ctx.beginPath(); ctx.arc(0,-14,10,Math.PI,2*Math.PI); ctx.fill();

  // Face
  ctx.fillStyle='#3e2723';
  ctx.beginPath(); ctx.arc(-3,-12,1.8,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(3,-12,1.8,0,Math.PI*2); ctx.fill();
  // Smile when offering
  ctx.strokeStyle='#3e2723'; ctx.lineWidth=1.5; ctx.lineCap='round';
  ctx.beginPath();
  if (isOffering) {
    ctx.arc(0,-10,4,0.2,Math.PI-0.2); // big smile
  } else {
    ctx.arc(0,-10,3,0.3,Math.PI-0.3); // small smile
  }
  ctx.stroke();

  // Gift bubble when nearby but not yet offering
  if (h.offerCooldown === 0 && h.state!=='offering') {
    const giftEmoji = h.gift==='treat'?'ğŸŸ':'ğŸ¤—';
    ctx.save();
    ctx.globalAlpha=0.7+Math.sin(t*0.12)*0.3;
    ctx.font='14px serif'; ctx.textAlign='center';
    // Small floating icon hint
    ctx.fillText(giftEmoji, 2, -26-Math.sin(t*0.08)*3);
    ctx.restore();
  }

  // Offering animation â€” sparkle burst
  if (h.giftAnim > 0) {
    const prog = h.giftAnim/40;
    ctx.save(); ctx.globalAlpha=prog;
    ctx.font='14px serif'; ctx.textAlign='center';
    ctx.fillText('âœ¨', -15*prog, -20-10*prog);
    ctx.fillText('âœ¨',  15*prog, -20-8*prog);
    ctx.restore();
  }

  ctx.restore();
}

function drawParticles() {
  gs.particles=gs.particles.filter(p=>p.life>0);
  for (const p of gs.particles) {
    if (p.isDashTrail) { p.life-=0.07; continue; } // drawn by drawDashTrail
    ctx.save(); ctx.globalAlpha=p.life;
    ctx.font=p.size+'px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(p.emoji,p.wx,p.wy); ctx.restore();
    p.wx+=p.vx; p.wy+=p.vy; p.vy-=0.08; p.life-=0.022;
  }
}

function drawDashTrail() {
  for (const p of gs.particles) {
    if (!p.isDashTrail) continue;
    ctx.save();
    ctx.globalAlpha = p.life * 0.7;
    ctx.fillStyle = p.col || '#f8bbd0';
    ctx.beginPath(); ctx.arc(p.wx, p.wy, p.size/2, 0, Math.PI*2); ctx.fill();
    ctx.restore();
    p.life -= 0.07;
  }
}

function drawRainbowGlow(wx, wy, t, frames) {
  const intensity = Math.min(1, frames / 60); // fade in/out
  const ringCount = 3;
  for (let i = 0; i < ringCount; i++) {
    const hue = ((t * 3 + i * (360/ringCount)) % 360);
    const r = 22 + i*5 + Math.sin(t*0.15+i)*3;
    ctx.save();
    ctx.globalAlpha = intensity * (0.35 - i*0.08) * (0.7 + Math.sin(t*0.1+i)*0.3);
    ctx.strokeStyle = `hsl(${hue},100%,65%)`;
    ctx.lineWidth = 4 - i;
    ctx.beginPath(); ctx.arc(wx, wy, r, 0, Math.PI*2); ctx.stroke();
    ctx.restore();
  }
  // Sparkles orbiting
  if (frames > 30) {
    for (let i = 0; i < 4; i++) {
      const a = t*0.08 + i*Math.PI/2;
      const hue = ((t*4 + i*90) % 360);
      ctx.save();
      ctx.globalAlpha = intensity * 0.8;
      ctx.fillStyle = `hsl(${hue},100%,70%)`;
      ctx.beginPath();
      ctx.arc(wx + Math.cos(a)*28, wy + Math.sin(a)*28, 3, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  }
}

function drawProgress() {
  const pct=Math.max(0,1-(gs.cat.wy/(gs.R*TILE)));
  const bx=CW-13,by=40,bh=CH-80;
  ctx.fillStyle='rgba(255,255,255,0.2)'; ctx.beginPath(); ctx.roundRect(bx-3,by,6,bh,3); ctx.fill();
  const fh=bh*pct;
  ctx.fillStyle='rgba(244,143,177,0.65)'; ctx.beginPath(); ctx.roundRect(bx-3,by+bh-fh,6,fh,3); ctx.fill();
  ctx.fillStyle='#f48fb1'; ctx.beginPath(); ctx.arc(bx,by+bh-fh,5,0,Math.PI*2); ctx.fill();
  ctx.font='12px serif'; ctx.textAlign='center'; ctx.fillText('ğŸ',bx,by+4);
  // Also draw interactable hints in world space
  ctx.save(); ctx.translate(0,-gs.camY); drawInteractableHints(); ctx.restore();
}

function spawnParticles(wx,wy,emoji='âœ¨') {
  const emojis=[emoji,'âœ¨','ğŸŒ¸','â­'];
  for (let i=0;i<5;i++) gs.particles.push({
    wx,wy,vx:(Math.random()-0.5)*3.5,vy:-2-Math.random()*2.5,
    life:1,size:12+Math.random()*6,emoji:emojis[Math.floor(Math.random()*emojis.length)]
  });
}

function spawnPop(wx,wy,text,color) {
  const layer=document.getElementById('popup-layer');
  const screenX=wx, screenY=wy-gs.camY-28;
  if (screenY<-20||screenY>CH+20) return;
  const el=document.createElement('div'); el.className='pop';
  el.style.left=Math.max(4,Math.min(CW-90,screenX-30))+'px';
  el.style.top=Math.max(4,screenY)+'px';
  el.style.color=color||'#5d4037';
  el.textContent=text; layer.appendChild(el);
  setTimeout(()=>el.remove(),1100);
}

function updateHUD() {
  document.getElementById('key-indicator').textContent=gs.hasKey?'ğŸ—ï¸ âœ“':'ğŸ—ï¸ âœ—';
  const waterEl = document.getElementById('watering-hud');
  if (waterEl) waterEl.style.display = gs.hasWateringCan ? '' : 'none';
  const dtEl = document.getElementById('daytime-hud');
  if (dtEl) dtEl.textContent = getDayOverlay().label;
  // Happy indicator
  const happyEl = document.getElementById('happy-hud');
  if (gs.cat.happyFrames > 0) {
    happyEl.style.display='';
    const secs = Math.ceil(gs.cat.happyFrames/60);
    document.getElementById('happy-display').textContent=`ğŸŒˆ ${secs}s`;
  } else {
    happyEl.style.display='none';
  }
}


function showGameOver() {
  stopMusic();
  document.getElementById('go-name').textContent=`Better luck next time, ${catName}! ğŸŒ¸`;
  setHudMode('hidden');
  document.getElementById('game-canvas-wrap').style.display='none';
  showScreen('gameover-screen');
}

function showLevelComplete() {
  stopMusic();
  if (currentLevel+1>unlockedLevels) unlockedLevels=currentLevel+1;
  const def=LEVEL_DEFS[currentLevel];
  document.getElementById('lc-emoji').textContent=def.icon||'ğŸ‰';
  document.getElementById('lc-title').textContent='You Did It! ğŸŠ';
  document.getElementById('lc-desc').textContent=def.completeTxt||'';
  setHudMode('hidden');
  document.getElementById('game-canvas-wrap').style.display='none';
  showScreen('levelcomplete-screen');
}

// Init
startPreviewAnim();
renderCatPreview('titleCatCanvas',130,130);
</script>
</body>
</html>
